<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/06/23/k8s/%E5%9C%A8k8s%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85nevida-docker2/"/>
    <url>/2022/06/23/k8s/%E5%9C%A8k8s%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85nevida-docker2/</url>
    
    <content type="html"><![CDATA[<h1 id="在k8s上面安装nevida-docker2"><a href="#在k8s上面安装nevida-docker2" class="headerlink" title="在k8s上面安装nevida-docker2"></a>在k8s上面安装nevida-docker2</h1><pre><code class="hljs awk">sudo yum-config-manager --add-repo=https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/</span>centos/docker-ce.repo</code></pre><pre><code class="hljs awk">curl -s -L https:<span class="hljs-regexp">//</span>nvidia.github.io<span class="hljs-regexp">/nvidia-docker/</span>centos7<span class="hljs-regexp">/x86_64/</span>nvidia-docker.repo | sudo tee <span class="hljs-regexp">/etc/yum</span>.repos.d/nvidia-docker.repo</code></pre><h3 id="0、daemon-json-配置"><a href="#0、daemon-json-配置" class="headerlink" title="0、daemon.json 配置"></a>0、daemon.json 配置</h3><pre><code class="hljs stylus">(base) <span class="hljs-selector-attr">[xinchenTest@master docker]</span>$ cat /etc/docker/daemon<span class="hljs-selector-class">.json</span> &#123;    <span class="hljs-string">&quot;default-runtime&quot;</span>: <span class="hljs-string">&quot;nvidia&quot;</span>,    <span class="hljs-string">&quot;runtimes&quot;</span>: &#123;        <span class="hljs-string">&quot;nvidia&quot;</span>: &#123;            <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;nvidia-container-runtime&quot;</span>,            <span class="hljs-string">&quot;runtimeArgs&quot;</span>: <span class="hljs-selector-attr">[]</span>        &#125;    &#125;,<span class="hljs-string">&quot;exec-opts&quot;</span>: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span>]</span>,<span class="hljs-string">&quot;registry-mirrors&quot;</span>:        <span class="hljs-selector-attr">[<span class="hljs-string">&quot;http://7e61f7f9.m.daocloud.io&quot;</span>]</span>,<span class="hljs-string">&quot;live-restore&quot;</span>: true,<span class="hljs-string">&quot;graph&quot;</span>: <span class="hljs-string">&quot;/data/docker&quot;</span>&#125;</code></pre><p>配置完别忘记</p><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reloadsudo <span class="hljs-params">system</span>ctl restart docker</code></pre><h3 id="1、移除nvidia-docker-1-0"><a href="#1、移除nvidia-docker-1-0" class="headerlink" title="1、移除nvidia-docker 1.0"></a>1、移除nvidia-docker 1.0</h3><pre><code class="hljs powershell">su <span class="hljs-keyword">do</span> docker volume <span class="hljs-built_in">ls</span> <span class="hljs-literal">-q</span> <span class="hljs-operator">-f</span> driver=nvidia<span class="hljs-literal">-docker</span> | xargs <span class="hljs-literal">-r</span> <span class="hljs-literal">-I</span>&#123;&#125; <span class="hljs-literal">-n1</span> docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-q</span> <span class="hljs-literal">-a</span> <span class="hljs-operator">-f</span> volume=&#123;&#125; | xargs <span class="hljs-literal">-r</span> docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span>sudo yum remove nvidia<span class="hljs-literal">-docker</span></code></pre><h3 id="2、安裝nvidia-docker-2-0"><a href="#2、安裝nvidia-docker-2-0" class="headerlink" title="2、安裝nvidia-docker 2.0"></a>2、安裝nvidia-docker 2.0</h3><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> nvidia-docker2</code></pre><h3 id="3、重新載入Docker-daemon的設定"><a href="#3、重新載入Docker-daemon的設定" class="headerlink" title="3、重新載入Docker daemon的設定"></a>3、重新載入Docker daemon的設定</h3><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pkill -SIGHUP dockerd</span></code></pre><h3 id="4、测试是否成功"><a href="#4、测试是否成功" class="headerlink" title="4、测试是否成功"></a>4、测试是否成功</h3><pre><code class="hljs routeros">sudo docker <span class="hljs-built_in">run</span> <span class="hljs-attribute">--runtime</span>=nvidia --rm nvidia/cuda:11.1.1-base-centos7 d  nvidia-smi</code></pre><p>5、</p><pre><code class="hljs awk">kubectl create -f https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/NVIDIA/</span>k8s-device-plugin<span class="hljs-regexp">/1.0.0-beta4/</span>nvidia-device-plugin.yml</code></pre><h5 id="Configure-containerd"><a href="#Configure-containerd" class="headerlink" title="Configure containerd"></a>Configure <code>containerd</code></h5><p>When running <code>kubernetes</code> with <code>containerd</code>, edit the config file which is usually present at <code>/etc/containerd/config.toml</code> to set up <code>nvidia-container-runtime</code> as the default low-level runtime:</p><pre><code class="hljs ini"><span class="hljs-attr">version</span> = <span class="hljs-number">2</span><span class="hljs-section">[plugins]</span>  <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span>    <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</span>      <span class="hljs-attr">default_runtime_name</span> = <span class="hljs-string">&quot;nvidia&quot;</span>      <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]</span>        <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.nvidia]</span>          <span class="hljs-attr">privileged_without_host_devices</span> = <span class="hljs-literal">false</span>          <span class="hljs-attr">runtime_engine</span> = <span class="hljs-string">&quot;&quot;</span>          <span class="hljs-attr">runtime_root</span> = <span class="hljs-string">&quot;&quot;</span>          <span class="hljs-attr">runtime_type</span> = <span class="hljs-string">&quot;io.containerd.runc.v2&quot;</span>          <span class="hljs-section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.nvidia.options]</span>            <span class="hljs-attr">BinaryName</span> = <span class="hljs-string">&quot;/usr/bin/nvidia-container-runtime</span></code></pre><p>journalctl -xe</p><pre><code class="hljs go"># 正常来说会输出已经安装过的程序$ rpm -qa | grep nvidia# 正常来说会输出已经安装过的程序$ rpm -qa | grep cuda</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/04/24/k8s/%E5%9C%A8centos%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85k8s/"/>
    <url>/2022/04/24/k8s/%E5%9C%A8centos%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85k8s/</url>
    
    <content type="html"><![CDATA[<h1 id="在centos上面安装k8s"><a href="#在centos上面安装k8s" class="headerlink" title="在centos上面安装k8s"></a>在centos上面安装k8s</h1><p>1、配置镜像源，在centos上面安装k8s</p><p>Kubernetes packages are not available from official CentOS 7 repositories,需要配置yum源</p><pre><code class="hljs awk">cat &lt;&lt;EOF &gt; <span class="hljs-regexp">/etc/yum</span>.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/kubernetes/yum</span><span class="hljs-regexp">/repos/</span>kubernetes-el7-x86_64/enabled=<span class="hljs-number">1</span>gpgcheck=<span class="hljs-number">0</span>EOF<span class="hljs-regexp">//</span> 安装kubeadm，kubectlsudo yum install -y kubelet-<span class="hljs-number">1.21</span>.<span class="hljs-number">0</span>  kubeadm-<span class="hljs-number">1.21</span>.<span class="hljs-number">0</span>  kubectl-<span class="hljs-number">1.21</span>.<span class="hljs-number">0</span>systemctl enable --now kubelet</code></pre><p><strong>ubuntu上面安装</strong></p><pre><code class="hljs bash"><span class="hljs-comment"># 使得 apt 支持 ssl 传输</span>apt-get update &amp;&amp; apt-get install -y apt-transport-https<span class="hljs-comment"># 下载 gpg 密钥   这个需要root用户否则会报错</span>curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - <span class="hljs-comment"># 添加 k8s 镜像源 这个需要root用户否则会报错</span><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><span class="hljs-string">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><span class="hljs-string">EOF</span><span class="hljs-comment"># 更新源列表</span>apt-get update<span class="hljs-comment"># 下载 kubectl，kubeadm以及 kubelet</span>apt-get install -y kubelet kubeadm kubectl</code></pre><p>2、安装docker</p><pre><code class="hljs livescript">sudo yum remove docker <span class="hljs-string">\</span>                  docker-client <span class="hljs-string">\</span>                  docker-client-latest <span class="hljs-string">\</span>                  docker-common <span class="hljs-string">\</span>                  docker-latest <span class="hljs-string">\</span>                  docker-latest-logrotate <span class="hljs-string">\</span>                  docker-logrotate <span class="hljs-string">\</span>                  docker-engine</code></pre><pre><code class="hljs awk">curl -sSL https:<span class="hljs-regexp">//g</span>et.daocloud.io/docker | sh</code></pre><p>配置docker</p><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>docker/daemon.json</code></pre><p>加入：</p><pre><code class="hljs prolog">&#123;  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [    <span class="hljs-string">&quot;https://dockerhub.azk8s.cn&quot;</span>,    <span class="hljs-string">&quot;https://reg-mirror.qiniu.com&quot;</span>,    <span class="hljs-string">&quot;https://quay-mirror.qiniu.com&quot;</span>  ],  <span class="hljs-string">&quot;exec-opts&quot;</span>: [ <span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span> ]&#125;</code></pre><p>然后重启docker</p><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reloadsudo <span class="hljs-params">system</span>ctl restart docker</code></pre><p>3、使用swap会影响性能。kubelet禁用swap</p><pre><code class="hljs awk"> sudo vim <span class="hljs-regexp">/etc/</span>fstab，注释掉swap那一行sudo swapoff -a</code></pre><p>4、下载所需要的镜像</p><pre><code class="hljs awk"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `kubeadm config images list`; <span class="hljs-keyword">do</span>   imageName=<span class="hljs-variable">$&#123;i#k8s.gcr.io/&#125;</span>  docker pull registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span><span class="hljs-variable">$imageName</span>  docker tag registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span><span class="hljs-variable">$imageName</span> k8s.gcr.io/<span class="hljs-variable">$imageName</span>  docker rmi registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span><span class="hljs-variable">$imageName</span>done;</code></pre><p>5、更改kubelet参数(只有centos需要)</p><pre><code class="hljs abnf">sudo vi /etc/sysconfig/kubelet改为如下参数KUBELET_EXTRA_ARGS<span class="hljs-operator">=</span>--cgroup-driver<span class="hljs-operator">=</span>systemd</code></pre><p>6、</p><pre><code class="hljs stylus">sudo kubeadm init <span class="hljs-attr">--image-repository</span>=registry<span class="hljs-selector-class">.aliyuncs</span>.com/google_containers <span class="hljs-attr">--pod-network-cidr</span> <span class="hljs-number">10.244</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span></code></pre><p>如果安装失败，可以使用下面命令重置</p><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo kubeadm reset</span></code></pre><p>然后会得到token 需要保存下来</p><pre><code class="hljs mipsasm">kubeadm <span class="hljs-keyword">join </span><span class="hljs-number">10</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">203</span>:<span class="hljs-number">6443</span> --token et430p.tuxyjzf2jl8l3nel \        --<span class="hljs-keyword">discovery-token-ca-cert-hash </span><span class="hljs-keyword">sha256:3b6ced67f2eacb0ad575e1dac245a7d0ec9a00bf25e928b722eade805f1e8d18 </span></code></pre><p>安装网络</p><p>kubectl apply -f “<a href="https://docs.projectcalico.org/manifests/calico.yaml&quot;">https://docs.projectcalico.org/manifests/calico.yaml&quot;</a></p><h2 id="Node-节点运行"><a href="#Node-节点运行" class="headerlink" title="Node 节点运行"></a>Node 节点运行</h2><pre><code class="hljs mipsasm">kubeadm <span class="hljs-keyword">join </span><span class="hljs-number">10</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">203</span>:<span class="hljs-number">6443</span> --token et430p.tuxyjzf2jl8l3nel \        --<span class="hljs-keyword">discovery-token-ca-cert-hash </span><span class="hljs-keyword">sha256:3b6ced67f2eacb0ad575e1dac245a7d0ec9a00bf25e928b722eade805f1e8d18 </span></code></pre><p>这里面有个问题，如果master和node不在一个内网，就访问不到，需要在node节点执行</p><pre><code class="hljs dns">iptables -t nat -<span class="hljs-keyword">A</span> OUTPUT -d <span class="hljs-number">192.168.0.1</span> -j DNAT --to-destination <span class="hljs-number">152.132.125.96</span></code></pre><p>注：第一个ip是master节点的内网ip，后一个ip是外网Ip</p><p>node 节点运行失败怎么卸载</p><pre><code class="hljs awk">rm -rf <span class="hljs-regexp">/etc/</span>kubernetes/</code></pre><h2 id="安装的时候遇到的错误"><a href="#安装的时候遇到的错误" class="headerlink" title="安装的时候遇到的错误"></a>安装的时候遇到的错误</h2><h4 id="1、It-seems-like-the-kubelet-isn‘t-running-or-healthy"><a href="#1、It-seems-like-the-kubelet-isn‘t-running-or-healthy" class="headerlink" title="1、It seems like the kubelet isn‘t running or healthy"></a>1、It seems like the kubelet isn‘t running or healthy</h4><p>查看官网介绍为 docker 和 kubelet 服务中的 cgroup 驱动不一致，有两种方法<br>方式一：驱动向 docker 看齐<br>方式二：驱动为向 kubelet 看齐<br>如果docker 不方便重启则统一向 kubelet看齐，并重启对应的服务即可</p><p><strong>解决方式</strong></p><p>kublete 配置文件<br>grep 截取一下,可以看得出来kubelet默认 cgoup 驱动为systemd</p><pre><code class="hljs gradle">root@controlplane:~# cat <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/kubelet/</span>config.yaml |<span class="hljs-keyword">grep</span> <span class="hljs-keyword">group</span>cgroupDriver: systemd</code></pre><p>重启kubelet （optional）</p><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo systemctl restart kubelet</span></code></pre><h4 id="2、msg-x3D-”getting-status-of-runtime-rpc-error-code-x3D-Unimplemented-desc-x3D-unknown-service-runtime-v1alpha2-RuntimeService”"><a href="#2、msg-x3D-”getting-status-of-runtime-rpc-error-code-x3D-Unimplemented-desc-x3D-unknown-service-runtime-v1alpha2-RuntimeService”" class="headerlink" title="2、msg&#x3D;”getting status of runtime: rpc error: code &#x3D; Unimplemented desc &#x3D; unknown service runtime.v1alpha2.RuntimeService”"></a>2、msg&#x3D;”getting status of runtime: rpc error: code &#x3D; Unimplemented desc &#x3D; unknown service runtime.v1alpha2.RuntimeService”</h4><p>解决方法:</p><pre><code class="hljs awk">rm <span class="hljs-regexp">/etc/</span>containerd/config.tomlsudo systemctl restart containerdrm -fr  <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.kube/</span>config</code></pre><h4 id="3、–apiserver-advertise-address-更改后的地址"><a href="#3、–apiserver-advertise-address-更改后的地址" class="headerlink" title="3、–apiserver-advertise-address  更改后的地址"></a>3、–apiserver-advertise-address  更改后的地址</h4><pre><code class="hljs routeros">sudo kubeadm init \<span class="hljs-attribute">--apiserver-advertise-address</span>=10.0.1.162 \--image-repository registry.aliyuncs.com/google_containers \<span class="hljs-attribute">--kubernetes-version</span>=v1.24.2 \<span class="hljs-attribute">--pod-network-cidr</span>=10.244.0.0/16 \<span class="hljs-attribute">--service-cidr</span>=10.96.0.0/12</code></pre><p>docker 配置</p><pre><code class="hljs prolog">&#123;    <span class="hljs-string">&quot;runtimes&quot;</span>: &#123;        <span class="hljs-string">&quot;nvidia&quot;</span>: &#123;            <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;nvidia-container-runtime&quot;</span>,            <span class="hljs-string">&quot;runtimeArgs&quot;</span>: []        &#125;    &#125;,    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://m3719grz.mirror.aliyuncs.com&quot;</span>]&#125;</code></pre><h4 id="4、kubelet-出现找不到Error-getting-node”-err-x3D-”node-quot-master-quot-not-found"><a href="#4、kubelet-出现找不到Error-getting-node”-err-x3D-”node-quot-master-quot-not-found" class="headerlink" title="4、kubelet 出现找不到Error getting node” err&#x3D;”node &quot;master&quot; not found"></a>4、kubelet 出现找不到Error getting node” err&#x3D;”node &quot;master&quot; not found</h4><p>执行 crictl images 发现 pause 的 TAG 是 3.5 没有 3.2，随即执行重新拉起镜像：</p><pre><code class="hljs gradle">[root@k8s-master ~]# crictl imagesIMAGE                                                             TAG                 IMAGE ID            <span class="hljs-keyword">SIZE</span>registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>coredns                   v1.<span class="hljs-number">8.4</span>              <span class="hljs-number">8</span>d147537fb7d1       <span class="hljs-number">13.7</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>coredns                   latest              <span class="hljs-number">8</span>d147537fb7d1       <span class="hljs-number">13.7</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>etcd                      <span class="hljs-number">3.5</span>.<span class="hljs-number">0</span>-<span class="hljs-number">0</span>             <span class="hljs-number">0048118155842</span>       <span class="hljs-number">99.9</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-apiserver            v1.<span class="hljs-number">22.1</span>             f30469a2491a5       <span class="hljs-number">31.3</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-controller-manager   v1.<span class="hljs-number">22.1</span>             <span class="hljs-number">6</span>e002eb89a881       <span class="hljs-number">29.8</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-proxy                v1.<span class="hljs-number">22.1</span>             <span class="hljs-number">36</span>c4ebbc9d979       <span class="hljs-number">35.9</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-scheduler            v1.<span class="hljs-number">22.1</span>             aca5ededae9c8       <span class="hljs-number">15</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>pause                     <span class="hljs-number">3.5</span>                 ed210e3e4a5ba       <span class="hljs-number">301</span>kB[root@k8s-master ~]# crictl pull registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>pause:<span class="hljs-number">3.2</span>Image is up to date <span class="hljs-keyword">for</span> sha256:<span class="hljs-number">80</span>d28bedfe5dec59da9ebf8e6260224ac9008ab5c11dbbe16ee3ba3e4439ac2c[root@k8s-master ~]# ctr -n k8s.io i tag --force registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>pause:<span class="hljs-number">3.2</span> k8s.gcr.io/pause:<span class="hljs-number">3.2</span>k8s.gcr.io/pause:<span class="hljs-number">3.2</span>[root@k8s-master ~]# crictl imagesIMAGE                                                             TAG                 IMAGE ID            <span class="hljs-keyword">SIZE</span>registry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>coredns                   v1.<span class="hljs-number">8.4</span>              <span class="hljs-number">8</span>d147537fb7d1       <span class="hljs-number">13.7</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>coredns                   latest              <span class="hljs-number">8</span>d147537fb7d1       <span class="hljs-number">13.7</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>etcd                      <span class="hljs-number">3.5</span>.<span class="hljs-number">0</span>-<span class="hljs-number">0</span>             <span class="hljs-number">0048118155842</span>       <span class="hljs-number">99.9</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-apiserver            v1.<span class="hljs-number">22.1</span>             f30469a2491a5       <span class="hljs-number">31.3</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-controller-manager   v1.<span class="hljs-number">22.1</span>             <span class="hljs-number">6</span>e002eb89a881       <span class="hljs-number">29.8</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-proxy                v1.<span class="hljs-number">22.1</span>             <span class="hljs-number">36</span>c4ebbc9d979       <span class="hljs-number">35.9</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>kube-scheduler            v1.<span class="hljs-number">22.1</span>             aca5ededae9c8       <span class="hljs-number">15</span>MBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>pause                     <span class="hljs-number">3.2</span>                 <span class="hljs-number">80</span>d28bedfe5de       <span class="hljs-number">300</span>kBk8s.gcr.io/pause                                                  <span class="hljs-number">3.2</span>                 <span class="hljs-number">80</span>d28bedfe5de       <span class="hljs-number">300</span>kBregistry.aliyuncs.com<span class="hljs-regexp">/google_containers/</span>pause</code></pre><p>执行kubeadm reset和init就好了</p><h4 id="5、在部署时忘记了token密码怎么办？"><a href="#5、在部署时忘记了token密码怎么办？" class="headerlink" title="5、在部署时忘记了token密码怎么办？"></a>5、在部署时忘记了token密码怎么办？</h4><p>首先，在每个节点上 执行 kubeadm reset命令即可，重新获取token（需要重新安装flanner网络组件）<br>关于如何重置k8s集群可以参考：重置kubernetes集群</p><p>1.重新生成新的token<br>默认token的有效期为24小时，当过期之后，该token就不可用了，在master节点上执行 kubeadm token create</p><pre><code class="hljs gauss">$ kubeadm <span class="hljs-built_in">token</span> <span class="hljs-keyword">create</span>c9afga.w3fue0yh3gzxczic</code></pre><p>查看token</p><pre><code class="hljs gauss">$ kubeadm <span class="hljs-built_in">token</span> list<span class="hljs-built_in">TOKEN</span>                     TTL       EXPIRES                     USAGES                   DESCRIPTION   EXTRA GROUPSc9afga.w3fue0yh3gzxczic   <span class="hljs-number">23</span>h       <span class="hljs-number">2019</span><span class="hljs-number">-07</span><span class="hljs-number">-26</span>T14:<span class="hljs-number">30</span>:<span class="hljs-number">54</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>   authentication,signing   &lt;none&gt;        <span class="hljs-keyword">system</span>:bootstrappers:kubeadm:default-node-<span class="hljs-built_in">token</span></code></pre><p>2.获取ca证书sha256编码hash值</p><pre><code class="hljs gradle">$ openssl x509 -pubkey -in <span class="hljs-regexp">/etc/</span>kubernetes<span class="hljs-regexp">/pki/</span>ca.crt | openssl rsa -pubin -outform der <span class="hljs-number">2</span>&gt;<span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span> | openssl dgst -sha256 -hex | sed <span class="hljs-string">&#x27;s/^.* //&#x27;</span><span class="hljs-number">8</span>b79b6461e58c07333cb2851fe74fd4374af8bbbe0bf7e040b415b86ad4fb89d</code></pre><p>3.节点加入集群<br>先清理环境，然后再kubeadm join （Node节点上执行）</p><pre><code class="hljs pgsql">sudo kubeadm <span class="hljs-keyword">reset</span>sudo iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -Xsudo sysctl net.bridge.bridge-nf-<span class="hljs-keyword">call</span>-iptables=<span class="hljs-number">1</span>sudo bash -c <span class="hljs-string">&#x27;echo 1 &gt; /proc/sys/net/ipv4/ip_forward&#x27;</span>sudo kubeadm <span class="hljs-keyword">join</span> <span class="hljs-number">10.0</span><span class="hljs-number">.1</span><span class="hljs-number">.162</span>:<span class="hljs-number">6443</span>  <span class="hljs-comment">--token 9kpu6t.e1jf89l5uzminfo2 \</span> <span class="hljs-comment">--discovery-token-ca-cert-hash sha256:3010d593b0b7d699ae53ae7b8939b2dc4169f5ff065650a8da18b4c959ac242a --node-name node1</span></code></pre><h4 id="6、镜像拉不下来怎么办"><a href="#6、镜像拉不下来怎么办" class="headerlink" title="6、镜像拉不下来怎么办"></a>6、镜像拉不下来怎么办</h4><p>先在镜像网站下载下来然后把docker镜像tag修改了</p><h4 id="7、swap没有关闭，防火墙没有关闭"><a href="#7、swap没有关闭，防火墙没有关闭" class="headerlink" title="7、swap没有关闭，防火墙没有关闭"></a>7、swap没有关闭，防火墙没有关闭</h4><p>会导致kubelet会有问题</p><h4 id="8、1-25-0版本的k8s拉不下来网络的镜像，导致node是notready"><a href="#8、1-25-0版本的k8s拉不下来网络的镜像，导致node是notready" class="headerlink" title="8、1.25.0版本的k8s拉不下来网络的镜像，导致node是notready"></a>8、1.25.0版本的k8s拉不下来网络的镜像，导致node是notready</h4><p>docker拉下来改tag也没用，降低版本1.21就好了</p><h4 id="9、pod-状态是evicted"><a href="#9、pod-状态是evicted" class="headerlink" title="9、pod 状态是evicted"></a>9、pod 状态是evicted</h4><p>没有gpu资源然后被驱逐了</p><p>10、k8s calico 插件错误：Number of node(s) with BGP peering established &#x3D; 0 calico&#x2F;node is not ready: BIRD is</p><p><a href="https://blog.csdn.net/baobaoxiannv/article/details/113119528">https://blog.csdn.net/baobaoxiannv/article/details/113119528</a></p><h4 id="10、describe-pod-发现network-error-getting-ClusterInformation-connection-is-unauthorized"><a href="#10、describe-pod-发现network-error-getting-ClusterInformation-connection-is-unauthorized" class="headerlink" title="10、describe pod 发现network: error getting ClusterInformation: connection is unauthorized:"></a>10、describe pod 发现network: error getting ClusterInformation: connection is unauthorized:</h4><p>除了执行这个命令</p><p><code>kubectl delete -f  &lt;yaml&gt;</code></p><p>    还要去&#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;目录下 删掉与calico相关的所有配置文件, 然后重启机器。 不然pod起不来，会报错 network: error getting ClusterInformation: connection is unauthorized: Unauthorized . 在这里发现的解决办法：source</p><h4 id="11、要关闭防火墙，或者开启特定端口，不能防火墙是failed状态"><a href="#11、要关闭防火墙，或者开启特定端口，不能防火墙是failed状态" class="headerlink" title="11、要关闭防火墙，或者开启特定端口，不能防火墙是failed状态"></a>11、要关闭防火墙，或者开启特定端口，不能防火墙是failed状态</h4><h4 id="12、node节点有taint-kubectl-taint-，node-kubernetes-io-x2F-disk-pressure-NoSchedule"><a href="#12、node节点有taint-kubectl-taint-，node-kubernetes-io-x2F-disk-pressure-NoSchedule" class="headerlink" title="12、node节点有taint kubectl taint ，node.kubernetes.io&#x2F;disk-pressure:NoSchedule-"></a>12、node节点有taint kubectl taint ，node.kubernetes.io&#x2F;disk-pressure:NoSchedule-</h4><pre><code class="hljs crmsh">kubectl taint <span class="hljs-keyword">node</span> <span class="hljs-title">node1</span>  node.kubernetes.io/disk-pressure:NoSchedule-</code></pre><p>node节点因为磁盘不够导致有污点上面的任务都被驱逐</p><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">cuda-vector-add</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span>  <span class="hljs-attr">containers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cuda-vector-add</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;k8s.gcr.io/cuda-vector-add:v0.1&quot;</span>      <span class="hljs-attr">resources:</span>        <span class="hljs-attr">limits:</span>          <span class="hljs-attr">nvidia.com/gpu:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># requesting 1 GPU</span></code></pre><p>13、安装docker-compose</p><pre><code class="hljs awk">sudo bash -c <span class="hljs-string">&#x27;curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose&#x27;</span>sudo chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-composesudo ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose <span class="hljs-regexp">/usr/</span>bin/docker-composedocker-compose --version</code></pre><p>14、harbor登陆不上去</p><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/docker.service</code></pre><pre><code class="hljs routeros"><span class="hljs-attribute">ExecStart</span>=/usr/bin/dockerd  <span class="hljs-attribute">--insecure-registry</span>=10.28.0.55:80</code></pre><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reloadsudo <span class="hljs-params">system</span>ctl restart docker</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/04/22/k8s/KubeDL%20%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2022/04/22/k8s/KubeDL%20%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="KubeDL-项目问题"><a href="#KubeDL-项目问题" class="headerlink" title="KubeDL 项目问题"></a>KubeDL 项目问题</h1><p>项目负责人你好，我叫应宇杰，来自杭州电子科技大学，是计科大三，无k8s基础，有一定docker使用经验。想参与2022年开源之夏的KubeDL项目，原因有二：</p><ul><li><p>我想参加开源之夏kubeDL项目，深入参与一次开源社区的开发，提高自己的能力</p></li><li><p>我在一个人工智能小公司实习，公司有一定的机器数量我想使用这个项目来提高公司的机器资源利用率（这个只是我想做的，公司还没和他们商量）。</p></li></ul><p>在尝试看文档使用本机<strong>mac m1</strong>复现quick start，但是遇到了一些困难，提了issue没人理，又不知道该找谁</p><h5 id="1、使用这个项目需要什么前置知识吗，举个例子：需要了解k8s内部service的调度"><a href="#1、使用这个项目需要什么前置知识吗，举个例子：需要了解k8s内部service的调度" class="headerlink" title="1、使用这个项目需要什么前置知识吗，举个例子：需要了解k8s内部service的调度"></a>1、使用这个项目需要什么前置知识吗，举个例子：需要了解k8s内部service的调度</h5><h5 id="2、在quict-start的时候，发现运行"><a href="#2、在quict-start的时候，发现运行" class="headerlink" title="2、在quict start的时候，发现运行"></a>2、在quict start的时候，发现运行</h5><p>（1）、<code>helm install kubedl ./helm/kubedl --create-namespace -n kubedl-system</code></p><p>会报错   <code>Error: INSTALLATION FAILED: path &quot;./helm/kubedl&quot; not found</code></p><p>（2）、运行 <code>kubectl apply -f https://raw.githubusercontent.com/kubedl-io/kubedl/master/example/tf/tf_job_mnist_distributed_simple.yaml</code></p><p>先是开了梯子也拉不下来，我就下载到本地，然后运行会报错</p><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>unable to recognize &quot;tf_job_mnist_distributed_simple.yaml&quot;: no matches for kind &quot;TFJob&quot; in version &quot;training.kubedl.io/v1alpha1&quot;</code></pre><p>发现这个项目无从下手，很难入门写个demo，请问能在快速开始这方面指导一下吗</p><h5 id="3、想请问一下今年开源之夏会有什么题目，想快点入门（有点心急），然后可以参与进来"><a href="#3、想请问一下今年开源之夏会有什么题目，想快点入门（有点心急），然后可以参与进来" class="headerlink" title="3、想请问一下今年开源之夏会有什么题目，想快点入门（有点心急），然后可以参与进来"></a>3、想请问一下今年开源之夏会有什么题目，想快点入门（有点心急），然后可以参与进来</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>美团后台开发工程师一面</title>
    <link href="/2022/03/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%9D%A2%E7%AD%8B/%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>/2022/03/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%9D%A2%E7%AD%8B/%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<p>这次面试官语言问的特别少，数据结构操作系统问的特别多，不同面试官有不同偏好吧，面试体验好，第一次说的不好他会引导你说出他想要知道的信息。</p><p><strong>1、自我介绍</strong></p><p><strong>2、为什么想来实习</strong>。 实习是就业的一个适应期，不想考研</p><p><strong>3、项目问题，介绍一下项目的背景，功能，和面向的人群，为什么要做这个项目</strong>（为了改进项目，节省硬件资源，提高用户体验）</p><p><strong>4、讲一下你在项目里面遇到的最大难题</strong>，（Mysql性能调优，项目结构的改良，将一个功能拆分成很多函数，对外提供一个执行的接口，在接口功能里面把一个个函数都写在里面，如果一个函数执行有错误就立马返回，能快速定位错误和符合开放封闭原则）</p><p><strong>5、Java学的多吗</strong>，只有上课学学的java</p><p><strong>6、c语言和golang语言的区别</strong></p><p><strong>7、了解编译型语言和解释型语言吗</strong>，不知道</p><p><strong>8、操作系统中A函数中执行B函数，讲一下这个栈内存中发生的事情</strong></p><p><strong>9、进程和线程的区别</strong></p><p><strong>10、进程间的通信是怎么做到的，线程间的通信是怎么做到的</strong>，进程是共享内存，管道，信号量，线程是共享进程的内存进行通信</p><p><strong>11、讲一下进程并发的概念</strong></p><p><strong>12、时间片的管理和调度算法</strong></p><p><strong>13、讲一下对虚拟内存的理解，作用是什么</strong></p><p><strong>14、讲一下有哪些数据结构</strong></p><p><strong>15、链表，和数组的区别和优点和缺点，增删改查的角度来说</strong></p><p><strong>16、为什么要有二叉树这个数据结构，发明出来是用在哪边的</strong></p><p><strong>17、有了平衡二叉树为什么还要有红黑树</strong></p><p><strong>18、hashmap听说过吗，能讲一下吗，讲一下他有什么用处</strong>，面试官说hash数很大怎么和槽位对应起来，我说如果槽位16是hash数和15&amp;一下 ，面试官说是%16，感觉作用一样</p><p><strong>19、mysql事务介绍一下</strong>，acid和数据库的隔离级别讲了一下，然后随便说了一下面试官就说差不多了，时间差不多了。</p><p>20、反问：问了美团的业务和职业规划之类的，问了面试官是干什么的</p><p>问的东西感觉偏基础而且很广，一部分靠日常积累。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动朝花夕拾服务器后端一面</title>
    <link href="/2022/03/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%9D%A2%E7%AD%8B/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2/"/>
    <url>/2022/03/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%9D%A2%E7%AD%8B/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>估计做服务器端需要c++，问了我c++虚函数是什么，c++11知道吗，c++我屁也没学，只有做算法题需要用，说不会，哎</p><p><strong>1、java的三大特性：继承、封装、多态，解释一下</strong></p><p><strong>2、c++有了解吗</strong> 只用算法的时候做过</p><p><strong>3、c++ 虚函数是什么</strong>，不知道</p><p><strong>4、讲一下对golang 里面interface的理解</strong></p><p><strong>5、c++，java、python、golang里面接口的相同点和不同点</strong></p><p><strong>6、golang里面 defer的是什么，作用是什么</strong>  使open和close代码放在一起防止忘记，捕获异常和崩溃日志。</p><p><strong>7、讲一下进程，线程，协程，和在golang里面的体现</strong></p><p><strong>8、讲一下对c++，python，java，golang的理解，python为什么运行慢？</strong>不知道，呜呜呜</p><p><strong>9、智力题，一个二维平面，在上面两个线段，怎么判断两个线段相不相交</strong></p><p><strong>10、25张红色扑克牌，25张黑色扑克牌，上面取一张，下面取一张，取得两张卡片颜色相等的概率。</strong></p><p><strong>11、项目里面使用amazon的lambda函数是什么东西，能讲一下吗</strong></p><p><strong>12、mysql底层用什么数据结构</strong>， b+树</p><p>算法题：leetcode：150. 逆波兰表达式求值</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/16/swift%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/16/swift%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1、ios模拟器的位置</p><p>&#x2F;Users&#x2F;jie&#x2F;Library&#x2F;Developer&#x2F;CoreSimulator&#x2F;Devices</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mac配置flutter问题合集</title>
    <link href="/2022/02/08/mac%E9%85%8D%E7%BD%AEflutter%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <url>/2022/02/08/mac%E9%85%8D%E7%BD%AEflutter%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h4 id="1、-x2F-Users-x2F-jie-x2F-Desktop-x2F-flutter-x2F-lemon-flutter-app-x2F-ios-x2F-Pods-x2F-Pods-xcodeproj-warning-The-iOS-Simulator-deployment-target-‘IPHONEOS-DEPLOYMENT-TARGET’-is-set-to-8-0-but-the-range-of-supported-deployment-target-versions-is-9-0-to-15-2-99-in-target-‘Toast’-from-project-‘Pods’"><a href="#1、-x2F-Users-x2F-jie-x2F-Desktop-x2F-flutter-x2F-lemon-flutter-app-x2F-ios-x2F-Pods-x2F-Pods-xcodeproj-warning-The-iOS-Simulator-deployment-target-‘IPHONEOS-DEPLOYMENT-TARGET’-is-set-to-8-0-but-the-range-of-supported-deployment-target-versions-is-9-0-to-15-2-99-in-target-‘Toast’-from-project-‘Pods’" class="headerlink" title="1、&#x2F;Users&#x2F;jie&#x2F;Desktop&#x2F;flutter&#x2F;lemon_flutter_app&#x2F;ios&#x2F;Pods&#x2F;Pods.xcodeproj: warning: The iOS Simulator deployment target ‘IPHONEOS_DEPLOYMENT_TARGET’ is set to 8.0, but the range of supported deployment target versions is 9.0 to 15.2.99. (in target ‘Toast’ from project ‘Pods’)"></a>1、&#x2F;Users&#x2F;jie&#x2F;Desktop&#x2F;flutter&#x2F;lemon_flutter_app&#x2F;ios&#x2F;Pods&#x2F;Pods.xcodeproj: warning: The iOS Simulator deployment target ‘IPHONEOS_DEPLOYMENT_TARGET’ is set to 8.0, but the range of supported deployment target versions is 9.0 to 15.2.99. (in target ‘Toast’ from project ‘Pods’)</h4><pre><code class="hljs awk">cd ios sudo rm -rf ~<span class="hljs-regexp">/Library/</span>Caches/CocoaPods   rm -rf Podfile.lock rm -rf Pods      rm -rf ~<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/Xcode/</span>DerivedData/*pod deintegrate  pod setup  pod install</code></pre><p>2、Failed to package &#x2F;Users&#x2F;jie&#x2F;Desktop&#x2F;flutter&#x2F;lemon_flutter_app&#x2F;ios&#x2F;…</p><p>Command PhaseScriptExecution failed with a nonzero exit code</p><pre><code class="hljs bash"><span class="hljs-string">&quot;<span class="hljs-variable">$FLUTTER_ROOT</span>/packages/flutter_tools/bin/xcode_backend.sh&quot;</span> build<span class="hljs-string">&quot;<span class="hljs-variable">$FLUTTER_ROOT</span>/packages/flutter_tools/bin/xcode_backend.sh&quot;</span> embed</code></pre><p>3、zsh: command not found: flatter</p><pre><code class="hljs stylus">vim ~/<span class="hljs-selector-class">.zshrc</span><span class="hljs-comment">// 在最后一行添加</span>source ~/<span class="hljs-selector-class">.zshrc</span><span class="hljs-selector-class">.pre-oh-my-zsh</span>source ~/<span class="hljs-selector-class">.bath_profile</span><span class="hljs-comment">// wq 保存退出重新打开终端即可</span></code></pre><p>4、rsync: link_stat “&#x2F;Users&#x2F;jie&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;Runner-bujxbaguzpyukvbumfgytsffnqlc&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;App.framework” failed: No such file or directory (2)</p><p>&#x2F;bin&#x2F;sh “&#x2F;Users&#x2F;jie&#x2F;sdk&#x2F;flutter&#x2F;packages&#x2F;flutter_tools&#x2F;bin&#x2F;xcode_backend.sh” embed_and_thin</p><p>5、ARC Semantic Issue (Xcode): No known class method for selector ‘updatePrivacyShow:privacyInfo:’&#x2F;Users&#x2F;jie&#x2F;sdk&#x2F;flutter&#x2F;.pubcache&#x2F;hosted&#x2F;pub.dartlang.org&#x2F;amap_flutter_location3.0.0&#x2F;ios&#x2F;Classes&#x2F;AMapFlutterLocationPlugin.m:92:29</p><pre><code class="hljs awk">cd ios sudo rm -rf ~<span class="hljs-regexp">/Library/</span>Caches/CocoaPods   rm -rf Podfile.lock rm -rf Pods      rm -rf ~<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/Xcode/</span>DerivedData/*pod deintegrate  pod setup  pod install</code></pre><p>6、Could not find module ‘WebView’ for target ‘x86_64-apple-ios-simulator’; found: arm64, arm64-apple-ios-simulator, at: &#x2F;Users&#x2F;jie&#x2F;Lib</p><p>在execuded archs 加入 x86_64</p><p>7、Error (Xcode): Framework not found tencent_kit</p><p>重新clone 项目</p><p>8、 line 132: ARCHS[@]: unbound variable</p><p>去掉用vscode打开 runner.xcodeproj  里面的EXCLUDED_ARCHS,VALID_ARCHS</p><p>9、Target Integrity (Xcode): The linked framework ‘Pods_Runner.framework’ is missing one or more architectures required by this target: arm64.</p><p>Runner-&gt;target-&gt;EXCLUDED_ARCHS-&gt;any ios simulate add arm64</p><p>10、Parse Issue (Xcode): Module ‘amap_flutter_location’ not found<br>&#x2F;Users&#x2F;jie&#x2F;Desktop&#x2F;flutter&#x2F;lemon_flutter_app&#x2F;ios&#x2F;Runner&#x2F;GeneratedPluginRegistrant.m:11:8</p><p>Encountered error while building for device.</p><p>把Xode 里面的Runner的ios版本改成高版本</p><p>11、TMS-90683: Missing Purpose String in Info.plist. Your app’s code references one or more APIs that access sensitive user data. The app’s Info.plist file should contain a NSCameraUsageDescription key with a user-facing purpose string explaining clearly and completely why your app needs the data. Starting Spring 2019, all apps submitted to the App Store that access user data are required to include a purpose string. If you’re using external libraries or SDKs, they may reference APIs that require a purpose string. While your app might not use these APIs, a purpose string is still required. You can contact the developer of the library or SDK and request they release a version of their code that doesn’t contain the APIs. Learn more (<a href="https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy">https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy</a>).</p><p>在info.plist文件里面加入</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>NSCameraUsageDescription<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>照片权限<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>NSPhotoLibraryUsageDescriptionn<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>相机权限<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></code></pre><p>12、ios真机调试无法打开“iproxy”，因为无法验证开发者。</p>]]></content>
    
    
    <categories>
      
      <category>flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万万没想到之聪明的编辑</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E8%81%AA%E6%98%8E%E7%9A%84%E7%BC%96%E8%BE%91/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E8%81%AA%E6%98%8E%E7%9A%84%E7%BC%96%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<h3 id="万万没想到之聪明的编辑"><a href="#万万没想到之聪明的编辑" class="headerlink" title="万万没想到之聪明的编辑"></a><font size=6px>万万没想到之聪明的编辑</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径：</p><p>\1. 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -&gt; hello</p><p>\2. 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -&gt; hello</p><p>\3. 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC</p><p>我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！</p><p>……</p><p>万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的……</p><p>请听题：请实现大锤的自动校对程序</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><pre><code class="hljs excel">第一行包括一个数字<span class="hljs-built_in">N</span>，表示本次用例包括多少个待校验的字符串。后面跟随<span class="hljs-built_in">N</span>行，每行为一个待校验的字符串。</code></pre><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><pre><code class="hljs excel"><span class="hljs-built_in">N</span>行，每行包括一个被修复后的字符串。</code></pre><h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><pre><code class="hljs">2helloowooooooow</code></pre><h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><pre><code class="hljs ebnf"><span class="hljs-attribute">hello</span><span class="hljs-attribute">woow</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>简单题，无思路</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span>fmt.Scan(&amp;n)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;fmt.Scan(&amp;str)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(str) &lt; <span class="hljs-number">3</span> &#123;fmt.Println(str)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(check(str))&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;correctStr := []<span class="hljs-type">byte</span>&#123;&#125;correctStr = <span class="hljs-built_in">append</span>(correctStr, <span class="hljs-type">byte</span>(str[<span class="hljs-number">0</span>]), <span class="hljs-type">byte</span>(str[<span class="hljs-number">1</span>]))k := <span class="hljs-number">2</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> || k == <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">if</span> correctStr[k<span class="hljs-number">-1</span>] == str[i] &amp;&amp; correctStr[k<span class="hljs-number">-1</span>] == correctStr[k<span class="hljs-number">-2</span>] &#123;<span class="hljs-keyword">continue</span>&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> correctStr[k<span class="hljs-number">-1</span>] == str[i] &amp;&amp; correctStr[k<span class="hljs-number">-1</span>] == correctStr[k<span class="hljs-number">-2</span>] &#123;<span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">if</span> correctStr[k<span class="hljs-number">-3</span>] == correctStr[k<span class="hljs-number">-2</span>] &amp;&amp; correctStr[k<span class="hljs-number">-1</span>] == str[i] &#123;<span class="hljs-keyword">continue</span>&#125;&#125;correctStr = <span class="hljs-built_in">append</span>(correctStr, <span class="hljs-type">byte</span>(str[i]))k++&#125;<span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(correctStr)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：5ms, 超过62.59%用Go提交的代码<br>  占用内存：1048KB, 超过21.33%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可转换最长子串</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%8F%AF%E8%BD%AC%E6%8D%A2%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%8F%AF%E8%BD%AC%E6%8D%A2%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="可转换最长子串"><a href="#可转换最长子串" class="headerlink" title="可转换最长子串"></a><font size=6px>可转换最长子串</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个仅包含’a’和’b’两种字符的字符串s，长度为n，每次操作可以把一个字符做一次转换（把一个’a’设置为’b’，或者把一个’b’置成’a’)；但是操作的次数有上限m，问在有限的操作数范围内，能够得到最大连续的相同字符的子串的长度是多少。.</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行两个整数 <span class="hljs-built_in">n</span> , m (<span class="hljs-number">1</span>&lt;=m&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">50000</span>)，第二行为长度为<span class="hljs-built_in">n</span>且只包含’a’和’b’的字符串s。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs css">输出在操作次数不超过 m 的情况下，能够得到的 最大连续 全’<span class="hljs-selector-tag">a</span>’子串或全’<span class="hljs-selector-tag">b</span>’子串的长度。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs apache"><span class="hljs-attribute">8</span> <span class="hljs-number">1</span><span class="hljs-attribute">aabaabaa</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">5</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs 1c">把第一个 &#x27;b&#x27; 或者第二个 &#x27;b&#x27; 置成 &#x27;a&#x27;，可得到长度为 <span class="hljs-number">5</span> 的全 &#x27;a&#x27; 子串。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用滑动窗口法</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;<span class="hljs-type">int</span> main()&#123;    char c[<span class="hljs-number">500001</span>];    <span class="hljs-type">int</span> n,m;    scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%c&quot;</span>,&amp;c[i]);    &#125;    <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>,l=<span class="hljs-number">0</span>,maxl=<span class="hljs-number">0</span>,an=<span class="hljs-number">0</span>,bn=<span class="hljs-number">0</span>;    while(r&lt;n)&#123;        <span class="hljs-keyword">if</span>(c[r]==<span class="hljs-string">&#x27;a&#x27;</span>) an++;        <span class="hljs-keyword">else</span> bn++;        <span class="hljs-keyword">if</span>(an&lt;=m||bn&lt;=m)&#123;            r++;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(r-l&gt;maxl) maxl = r-l;            <span class="hljs-keyword">if</span>(c[l]==<span class="hljs-string">&#x27;a&#x27;</span>)&#123;                an--;                l++;            &#125;<span class="hljs-keyword">else</span>&#123;                bn--;                l++;            &#125;            r++;        &#125;    &#125;    <span class="hljs-keyword">if</span>(r-l &gt;maxl) maxl = r-l;    printf(<span class="hljs-string">&quot;%d&quot;</span>,maxl);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：4ms, 超过61.29%用C提交的代码<br>   占用内存：416KB, 超过83.87%用C提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>string</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>头条校招</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%A4%B4%E6%9D%A1%E6%A0%A1%E6%8B%9B/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%A4%B4%E6%9D%A1%E6%A0%A1%E6%8B%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="头条校招"><a href="#头条校招" class="headerlink" title="头条校招"></a><font size=6px>头条校招</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队，每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来，在选题之前，我们对题目进行了盲审，并定出了每道题的难度系统。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a,b,c，我们希望这3道题能满足下列条件：<br>a&lt;&#x3D;b&lt;&#x3D;c<br>b-a&lt;&#x3D;10<br>c-b&lt;&#x3D;10<br>所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求，然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs armasm">输入的第一行包含一个整数n，表示目前已经出好的题目数量。第二行给出每道题目的难度系数<span class="hljs-built_in">d1</span>,<span class="hljs-built_in">d2</span>,...,<span class="hljs-meta">dn</span>。 数据范围对于<span class="hljs-number">30</span>%的数据，<span class="hljs-number">1</span> ≤ n,di ≤ <span class="hljs-number">5</span><span class="hljs-comment">;</span>对于<span class="hljs-number">100</span>%的数据，<span class="hljs-number">1</span> ≤ n ≤ <span class="hljs-number">10</span>^<span class="hljs-number">5</span>,<span class="hljs-number">1</span> ≤ di ≤ <span class="hljs-number">100</span>。在样例中，一种可行的方案是添加<span class="hljs-number">2</span>个难度分别为<span class="hljs-number">20</span>和<span class="hljs-number">50</span>的题目，这样可以组合成两场考试：（<span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">23</span>）和（<span class="hljs-number">35</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>）。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">输出只包括一行，即所求的答案。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span> <span class="hljs-symbol">20 </span><span class="hljs-number">35</span> <span class="hljs-number">23</span> <span class="hljs-number">40</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">2</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先找三个的，再找两个的，最后输出只有单独一个的*2+两个的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sort&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n,a,sum1,sum2  <span class="hljs-type">int</span>    fmt.Scan(&amp;n)    num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    flag := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scan(&amp;a)        num[i] = a    &#125;    sort.Ints(num)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;n;i++&#123;        <span class="hljs-comment">//找到三个数的</span>        <span class="hljs-keyword">if</span> flag[i<span class="hljs-number">-2</span>]==<span class="hljs-number">0</span>&amp;&amp;flag[i<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;flag[i]==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> num[i]-num[i<span class="hljs-number">-1</span>]&lt;=<span class="hljs-number">10</span>&amp;&amp;num[i<span class="hljs-number">-1</span>]-num[i<span class="hljs-number">-2</span>]&lt;=<span class="hljs-number">10</span>&#123;                flag[i],flag[i<span class="hljs-number">-1</span>],flag[i<span class="hljs-number">-2</span>] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>                sum1++            &#125;        &#125;    &#125;    <span class="hljs-comment">//找到两个数的</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> flag[i<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;flag[i]==<span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">if</span> num[i]-num[i<span class="hljs-number">-1</span>]&lt;=<span class="hljs-number">10</span>&#123;                flag[i],flag[i<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span>                sum2++            &#125;        &#125;    &#125;    fmt.Println(sum2+<span class="hljs-number">2</span>*(n<span class="hljs-number">-3</span>*sum1<span class="hljs-number">-2</span>*sum2))    &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字母交换</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E6%AF%8D%E4%BA%A4%E6%8D%A2/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E6%AF%8D%E4%BA%A4%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="字母交换"><a href="#字母交换" class="headerlink" title="字母交换"></a><font size=6px>字母交换</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>【编码题】字符串S由小写字母构成，长度为n。定义一种操作，每次都可以挑选字符串中任意的两个相邻字母进行交换。询问在至多交换m次之后，字符串中最多有多少个连续的位置上的字母相同？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs coq">第一行为一个字符串S与一个非负整数m。(<span class="hljs-number">1</span> &lt;= |<span class="hljs-type">S</span>| <span class="hljs-type">&lt;= 1000</span>, <span class="hljs-number">1</span> &lt;= m &lt;= <span class="hljs-number">1000000</span>)</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">一个非负整数，表示操作之后，连续最长的相同字母数量。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs apache"><span class="hljs-attribute">abcbaa</span> <span class="hljs-number">2</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">2</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs css">使<span class="hljs-number">2</span>个字母<span class="hljs-selector-tag">a</span>连续出现，至少需要<span class="hljs-number">3</span>次操作。即把第<span class="hljs-number">1</span>个位w置上的<span class="hljs-selector-tag">a</span>移动到第<span class="hljs-number">4</span>个位置。所以在至多操作<span class="hljs-number">2</span>次的情况下，最多只能使<span class="hljs-number">2</span>个<span class="hljs-selector-tag">b</span>或<span class="hljs-number">2</span>个<span class="hljs-selector-tag">a</span>连续出现。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划递推公式 dp【i】[j]&#x3D;  dp【i+1】【j-1】 + a[j]-a[i] -(j-i);,计算时只算上三角情况，每个字母单独计算，递归公式看懂就会做了。第一轮计算相邻相同字母的相邻距离，第二轮计算相差两个位置的字母靠近需要多少距离</p><p>上三角举例</p><p>0111</p><p>0011</p><p>0001</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;#include&lt;stdlib.h&gt;<span class="hljs-type">int</span> max(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;    <span class="hljs-keyword">return</span> a&gt;b?a:b;&#125;<span class="hljs-type">int</span> main()&#123;    char s[<span class="hljs-number">10001</span>];    <span class="hljs-type">int</span> m,max_seq;    scanf(<span class="hljs-string">&quot;%s%d&quot;</span>,s,&amp;m);    <span class="hljs-type">int</span> size_s = strlen(s);    <span class="hljs-keyword">for</span>(char c =<span class="hljs-string">&#x27;a&#x27;</span>;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span> ; c++)&#123;        <span class="hljs-type">int</span> *a = (<span class="hljs-type">int</span> *)malloc(sizeof(<span class="hljs-type">int</span>)*<span class="hljs-number">10002</span>);        <span class="hljs-type">int</span> size =<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size_s;i++)&#123;            <span class="hljs-comment">//把相同字符的位置求出来</span>            <span class="hljs-keyword">if</span>(s[i] ==c) a[size++] = i;        &#125;        <span class="hljs-keyword">if</span>(size)&#123;            <span class="hljs-type">int</span> dp[<span class="hljs-number">1002</span>][<span class="hljs-number">1001</span>];            memset(dp,<span class="hljs-number">0</span>,sizeof(dp));            <span class="hljs-type">int</span> seq = <span class="hljs-number">1</span>;            <span class="hljs-comment">//只计算上三角情况</span>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>;r&lt;size;r++)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size-r;i++)&#123;                    <span class="hljs-type">int</span> j = i+r;                    <span class="hljs-comment">// 在第一轮的情况下</span>                    <span class="hljs-keyword">if</span>(j==i+<span class="hljs-number">1</span>)&#123;                        dp[i][j] = a[j]-a[i]<span class="hljs-number">-1</span>;                    &#125;<span class="hljs-keyword">else</span>&#123;                        dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + a[j]-a[i] -(j-i);                    &#125;                    <span class="hljs-keyword">if</span>(dp[i][j]&lt;=m)                        seq = max(seq,j-i+<span class="hljs-number">1</span>);                &#125;            &#125;            max_seq = max(max_seq,seq);        &#125;    &#125;    printf(<span class="hljs-string">&quot;%d\n&quot;</span>,max_seq);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：11ms, 超过57.14%用C提交的代码<br>   占用内存：4348KB, 超过40.00%用C提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大点集</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%80%E5%A4%A7%E7%82%B9%E9%9B%86/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%80%E5%A4%A7%E7%82%B9%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="最大点集"><a href="#最大点集" class="headerlink" title="最大点集"></a><font size=6px>最大点集</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>P为给定的二维平面整数点集。定义P中某点x，如果x满足P中任意点都不在x的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复,坐标轴范围在[0, 1e9]内）</p><p>如下图：实心点为满足条件的点的集合。</p><p><img src="https://uploadfiles.nowcoder.com/images/20180711/305700_1531276401135_0787E0E2ECD199446DCB82BEAE571BDF" alt="img"></p><p>请实现代码找到集合P中的所有”最大“点的集合并输出。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行输入点集的个数<span class="hljs-built_in">N</span>， 接下来<span class="hljs-built_in">N</span>行，每行两个数字代表点的X轴和Y轴。<span class="hljs-number">1</span> ≤ <span class="hljs-built_in">n</span> ≤ <span class="hljs-number">500000</span></code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs tp">输出“最大的”点集合， 按照<span class="hljs-keyword">X</span>轴从小到大的方式输出，每行两个数字分别代表点的<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先按照x升序和y升序排序，然后从后到前判断</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;<span class="hljs-keyword">struct</span> num &#123;    <span class="hljs-type">int</span> a,b;&#125;;<span class="hljs-type">bool</span> cmp(<span class="hljs-keyword">struct</span> num num1,<span class="hljs-keyword">struct</span> num num2)&#123;    <span class="hljs-keyword">if</span> (num1.a &gt; num2.a)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num1.a &lt; num2.a)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span> (num1.b&lt;num2.b)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">struct</span> num nums[n];    <span class="hljs-keyword">struct</span> num res[n];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums[i].a);        scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;nums[i].b);    &#125;    sort(nums,nums+n,cmp);    <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;    <span class="hljs-type">int</span> max = nums[n<span class="hljs-number">-1</span>].b;    res[<span class="hljs-number">0</span>].a = nums[n<span class="hljs-number">-1</span>].a;    res[<span class="hljs-number">0</span>].b = nums[n<span class="hljs-number">-1</span>].b;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-keyword">if</span>(nums[i].b &gt;max)&#123;            max = nums[i].b;            res[k].a = nums[i].a;            res[k++].b = nums[i].b;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>,res[i].a,res[i].b);    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：173ms, 超过80.50%用C++提交的代码<br>   占用内存：12684KB, 超过44.93%用C++提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人跳跃问题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="机器人跳跃问题"><a href="#机器人跳跃问题" class="headerlink" title="机器人跳跃问题"></a><font size=6px>机器人跳跃问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。 </p><p>起初， 机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E, 下一步它将跳到第个k+1建筑。它将会得到或者失去正比于与H(k+1)与E之差的能量。如果 H(k+1) &gt; E 那么机器人就失去 H(k+1) - E 的能量值，否则它将得到 E - H(k+1) 的能量值。</p><p>游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs css">第一行输入，表示一共有 N 组数据.第二个是 N 个空格分隔的整数，<span class="hljs-selector-tag">H1</span>, <span class="hljs-selector-tag">H2</span>, <span class="hljs-selector-tag">H3</span>, ..., Hn 代表建筑物的高度</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">输出一个单独的数表示完成游戏所需的最少单位的初始能量</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">5</span><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><p>示例2</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span></code></pre><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><p>示例3</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">4</span></code></pre><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">3</code></pre><h2 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h2><pre><code class="hljs parser3"><span class="language-xml">数据约束：</span><span class="language-xml"></span><span class="hljs-number">1</span><span class="language-xml"> &lt;= N &lt;= </span><span class="hljs-number">10</span><span class="hljs-keyword">^5</span><span class="language-xml"></span><span class="language-xml"></span><span class="hljs-number">1</span><span class="language-xml"> &lt;= H(i) &lt;= </span><span class="hljs-number">10</span><span class="hljs-keyword">^5</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用动态规划,令 f(n)&#x3D;E(n)，</p><p>则 f(n+1)&#x3D;2f(n)–H(n+1)≥0，所以 f(n)&#x3D;⌈(f(n+1)+H(n+1))&#x2F;2⌉</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n,a <span class="hljs-type">int</span>    fmt.Scan(&amp;n)    num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        fmt.Scan(&amp;a)        num[i] = a    &#125;    <span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(num)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;        ans = ceil(ans , num[i])    &#125;    fmt.Println(ans)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ceil</span><span class="hljs-params">( a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> (a+b) %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> (a+b)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> (a+b)/<span class="hljs-number">2</span>    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：15ms, 超过9.84%用Go提交的代码<br>   占用内存：1036KB, 超过37.70%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业旅行问题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%AF%95%E4%B8%9A%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%AF%95%E4%B8%9A%E6%97%85%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="毕业旅行问题"><a href="#毕业旅行问题" class="headerlink" title="毕业旅行问题"></a><font size=6px>毕业旅行问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>小明目前在做一份毕业旅行的规划。打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。由于经费有限，希望能够通过合理的路线安排尽可能的省一些路上的花销。给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">城市个数<span class="hljs-built_in">n</span>（<span class="hljs-number">1</span>&lt;<span class="hljs-built_in">n</span>≤<span class="hljs-number">20</span>，包括北京）城市间的车票价钱 <span class="hljs-built_in">n</span>行<span class="hljs-built_in">n</span>列的矩阵 m[<span class="hljs-built_in">n</span>][<span class="hljs-built_in">n</span>]</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">最小车费花销 s</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">4</span><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><span class="hljs-symbol">6 </span><span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">13</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs tap">共<span class="hljs-number"> 4 </span>个城市，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 1 </span>的车费为0，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 2 </span>之间的车费为 2，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 3 </span>之间的车费为 6，城市<span class="hljs-number"> 1 </span>和城市<span class="hljs-number"> 4 </span>之间的车费为 5，依次类推。假设任意两个城市之间均有单程票可购买，且票价在1000元以内，无需考虑极端情况。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用状态压缩动态规划来写，1代表已经走过这个地方了，解释一下代码</p><p>第一层循环代表所有情况，第二层代表下一个要去的城市是第几个城市，第三层循环代表中间结点城市。</p><pre><code class="hljs 1c">i&gt;&gt;j <span class="hljs-meta">&amp;1 <span class="hljs-comment">//判断i的第j位是不是1</span></span></code></pre><p>i^(1&lt;&lt;j) &#x2F;&#x2F;把i的第j位置为1</p><pre><code class="hljs cpp">#### 代码:```golang<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;    <span class="hljs-keyword">if</span>(a &gt; b)&#123;        <span class="hljs-keyword">return</span> b;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-type">int</span> dp[<span class="hljs-number">1</span>&lt;&lt;n][n];        <span class="hljs-type">int</span> num[n][n];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num[i][j]);    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dp));    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i+=<span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;            <span class="hljs-keyword">if</span>((i&gt;&gt;j &amp;<span class="hljs-number">1</span>==<span class="hljs-number">0</span>)) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;                <span class="hljs-keyword">if</span>(j==k) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span>((i&gt;&gt;k)&amp;<span class="hljs-number">1</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)][k]+num[k][j]);            &#125;        &#125;    &#125;    <span class="hljs-type">int</span> res =<span class="hljs-number">9999</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        res = <span class="hljs-built_in">min</span>(res,dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][i]+num[i][<span class="hljs-number">0</span>]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：78ms, 超过33.33%用C提交的代码<br>   占用内存：18732KB, 超过15.69%用C提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>房间人数</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%88%BF%E9%97%B4%E4%BA%BA%E6%95%B0/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E6%88%BF%E9%97%B4%E4%BA%BA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="房间人数"><a href="#房间人数" class="headerlink" title="房间人数"></a><font size=6px>房间人数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有n个房间，现在i号房间里的人需要被重新分配，分配的规则是这样的：先让i号房间里的人全都出来，接下来按照 i+1, i+2, i+3, … 的顺序依此往这些房间里放一个人，n号房间的的下一个房间是1号房间，直到所有的人都被重新分配。</p><p>现在告诉你分配完后每个房间的人数以及最后一个人被分配的房间号x，你需要求出分配前每个房间的人数。数据保证一定有解，若有多解输出任意一个解。</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><pre><code class="hljs excel">第一行两个整数<span class="hljs-built_in">n</span>, x (<span class="hljs-number">2</span>&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">5</span>, <span class="hljs-number">1</span>&lt;=x&lt;=<span class="hljs-built_in">n</span>)，代表房间房间数量以及最后一个人被分配的房间号；第二行<span class="hljs-built_in">n</span>个整数 a_i(<span class="hljs-number">0</span>&lt;=a_i&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">9</span>) ，代表每个房间分配后的人数。</code></pre><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><pre><code class="hljs excel">输出<span class="hljs-built_in">n</span>个整数，代表每个房间分配前的人数。</code></pre><h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><span class="hljs-symbol">6 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span></code></pre><h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>需要考虑的情况是</p><pre><code class="hljs hsp"><span class="hljs-keyword">while</span>(room[<span class="hljs-keyword">pos</span>]!=mn)        <span class="hljs-keyword">pos</span>=<span class="hljs-keyword">pos</span>&gt;<span class="hljs-number">0</span>?<span class="hljs-keyword">pos</span><span class="hljs-number">-1</span>:n<span class="hljs-number">-1</span><span class="hljs-comment">;</span></code></pre><p>最后一个房间的人的前一个最小数才是真正的最小数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;limits.h&gt;#include&lt;algorithm&gt;using namespace std;#define ll long long<span class="hljs-type">int</span> n,x;ll room[<span class="hljs-number">1500005</span>];<span class="hljs-type">int</span> main(void)&#123;    scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);    ll mn=INT_MAX;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;room[i]);        mn=min(mn, room[i]);    &#125;    x-=<span class="hljs-number">1</span>;    <span class="hljs-type">int</span> pos=x;    while(room[pos]!=mn)        pos=pos&gt;<span class="hljs-number">0</span>?pos<span class="hljs-number">-1</span>:n<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        room[i]-=mn;    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i!=pos;i=i&gt;<span class="hljs-number">0</span>?i<span class="hljs-number">-1</span>:n<span class="hljs-number">-1</span>)&#123;        room[i]-=<span class="hljs-number">1</span>;        count+=<span class="hljs-number">1</span>;    &#125;    room[pos]+=count+n*mn;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        printf(<span class="hljs-string">&quot;%lld &quot;</span>,room[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选区间</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E9%80%89%E5%8C%BA%E9%97%B4/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E9%80%89%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="选区间"><a href="#选区间" class="headerlink" title="选区间"></a><font size=6px>选区间</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组序列,需要求选出一个区间,使得该区间是所有区间中经过如下计算的值最大的一个：</p><p>区间中的最小数*区间所有数的和</p><p>最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列 [6 2 1]则根据上述公式,可得到所有可以选定各个区间的计算值:</p><p>[6] &#x3D; 6 * 6 &#x3D; 36;</p><p>[2] &#x3D; 2 * 2 &#x3D; 4;</p><p>[1] &#x3D; 1 * 1 &#x3D; 1;</p><p>[6,2] &#x3D; 2 * 8 &#x3D; 16;</p><p>[2,1] &#x3D; 1 * 3 &#x3D; 3;</p><p>[6, 2, 1] &#x3D; 1 * 9 &#x3D; 9;</p><p>从上述计算可见选定区间[6]，计算值为36， 则程序输出为36。</p><p>区间内的所有数字都在[0, 100]的范围内;</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs">第一行输入数组序列个数，第二行输入数组序列。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs">输出数组经过计算后的最大值。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">3</span><span class="hljs-symbol">6 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">36</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把每个数当成最小数，从左到右遍历</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n,max=<span class="hljs-number">-1</span>,sum,res;    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-type">int</span> num[n+<span class="hljs-number">1</span>];    <span class="hljs-type">int</span> numSum[n+<span class="hljs-number">1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;num[i]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;=<span class="hljs-number">1</span>;j--)&#123;            <span class="hljs-keyword">if</span> (num[j]&gt;=num[i])&#123;                sum +=num[j];            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;            <span class="hljs-keyword">if</span> (num[j]&gt;=num[i])&#123;                sum +=num[j];            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        res = num[i]*sum;        sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (max &lt;res)&#123;            max = res;        &#125;    &#125;    printf(<span class="hljs-string">&quot;%d&quot;</span>,max);&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：1038ms, 超过19.45%用C++提交的代码<br>   占用内存：3472KB, 超过39.60%用C++提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动附加题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%99%84%E5%8A%A0%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%99%84%E5%8A%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="字节跳动附加题"><a href="#字节跳动附加题" class="headerlink" title="字节跳动附加题"></a><font size=6px>字节跳动附加题</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>存在n+1个房间，每个房间依次为房间1 2 3…i，每个房间都存在一个传送门，i房间的传送门可以把人传送到房间pi(1&lt;&#x3D;pi&lt;&#x3D;i),现在路人甲从房间1开始出发(当前房间1即第一次访问)，每次移动他有两种移动策略：<br>  A. 如果访问过当前房间 i 偶数次，那么下一次移动到房间i+1；<br>  B. 如果访问过当前房间 i 奇数次，那么移动到房间pi；<br>现在路人甲想知道移动到房间n+1一共需要多少次移动；</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行包括一个数字<span class="hljs-built_in">n</span>(<span class="hljs-comment">30%数据1&lt;=n&lt;=100，100%数据 1&lt;=n&lt;=1000</span>)，表示房间的数量，接下来一行存在<span class="hljs-built_in">n</span>个数字 <span class="hljs-built_in">pi</span>(<span class="hljs-number">1</span>&lt;=<span class="hljs-built_in">pi</span>&lt;=i), <span class="hljs-built_in">pi</span>表示从房间i可以传送到房间<span class="hljs-built_in">pi</span>。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs dns">输出一行数字，表示最终移动的次数，最终结果需要对<span class="hljs-number">1000000007</span> (<span class="hljs-number">10</span>e9 + <span class="hljs-number">7</span>) 取模。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs css">开始从房间<span class="hljs-number">1</span> 只访问一次所以只能跳到p1即 房间<span class="hljs-number">1</span>， 之后采用策略<span class="hljs-selector-tag">A</span>跳到房间<span class="hljs-number">2</span>，房间<span class="hljs-number">2</span>这时访问了一次因此采用策略<span class="hljs-selector-tag">B</span>跳到房间<span class="hljs-number">2</span>，之后采用策略<span class="hljs-selector-tag">A</span>跳到房间<span class="hljs-number">3</span>，因此到达房间<span class="hljs-number">3</span>需要 <span class="hljs-number">4</span> 步操作。</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一道递推题，dp【i】需要一次奇数和偶数移动，偶数移动 &#x3D; dp【i-1】+1,奇数移动是dp【i】&#x3D; dp【i-1】-dp【jump【i-1】】+1。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span>    fmt.Scan(&amp;n)    count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">2</span>)    jump := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">1</span>)    mod := <span class="hljs-number">1000000007</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        fmt.Scan(&amp;jump[i])    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++&#123;        count[i] = (<span class="hljs-number">2</span>*count[i<span class="hljs-number">-1</span>]%mod-count[jump[i<span class="hljs-number">-1</span>]]+<span class="hljs-number">2</span>)%mod    &#125;    fmt.Println(count[n+<span class="hljs-number">1</span>])&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：2 ms, 在所有 Go 提交中击败了100.00%的用户<br>   占用内存：988KB, 超过13.64%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程题2</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%BC%96%E7%A8%8B%E9%A2%982/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%BC%96%E7%A8%8B%E9%A2%982/</url>
    
    <content type="html"><![CDATA[<h3 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a><font size=6px>编程题2</font></h3><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有n个房间，现在i号房间里的人需要被重新分配，分配的规则是这样的：先让i号房间里的人全都出来，接下来按照 i+1, i+2, i+3, … 的顺序依此往这些房间里放一个人，n号房间的的下一个房间是1号房间，直到所有的人都被重新分配。</p><p>现在告诉你分配完后每个房间的人数以及最后一个人被分配的房间号x，你需要求出分配前每个房间的人数。数据保证一定有解，若有多解输出任意一个解。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行两个整数<span class="hljs-built_in">n</span>, x (<span class="hljs-number">2</span>&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">5</span>, <span class="hljs-number">1</span>&lt;=x&lt;=<span class="hljs-built_in">n</span>)，代表房间房间数量以及最后一个人被分配的房间号；第二行<span class="hljs-built_in">n</span>个整数 a_i(<span class="hljs-number">0</span>&lt;=a_i&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">9</span>) ，代表每个房间分配后的人数。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs excel">输出<span class="hljs-built_in">n</span>个整数，代表每个房间分配前的人数。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><span class="hljs-symbol">6 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找出last左右边最小的数，如果左右边最小的数相等，就选last左边的最小数，写的像屎一样的代码，不想写思路了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">var</span> n,last,min,min1 <span class="hljs-type">int</span>        fmt.Scan(&amp;n,&amp;last)    num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)    <span class="hljs-comment">//找出last左右边最小的数，如果左右边最小的数相等，就选last左边的最小数</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;last;i++&#123;        fmt.Scan(&amp;num[i])        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>&#123;            min = i        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> num[min] &gt;=num[i]&#123;                min = i            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=last;i&lt;n;i++&#123;        fmt.Scan(&amp;num[i])        <span class="hljs-keyword">if</span> i==last&#123;            min1 = i        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> num[min1] &gt;=num[i]&#123;                min1 = i            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> num[min]&gt;num[min1]&#123;        min = min1    &#125;    sum :=<span class="hljs-number">0</span>    minNum :=num[min]    <span class="hljs-keyword">if</span> last &lt; min+<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">for</span> i:=min+<span class="hljs-number">1</span>;i&lt;n;i++&#123;            num[i] -=minNum+<span class="hljs-number">1</span>           &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;last;i++&#123;            num[i] -=minNum+<span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">for</span> i:=last;i&lt;=min;i++&#123;            num[i] -=minNum        &#125;        sum = (last+n-(min+<span class="hljs-number">1</span>))*(minNum+<span class="hljs-number">1</span>)+(n-last-(n-(min+<span class="hljs-number">1</span>)))*minNum    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> last&gt;min+<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=min;i++&#123;            num[i] -=minNum        &#125;         <span class="hljs-keyword">for</span> i:=last;i&lt;n;i++&#123;            num[i] -=minNum        &#125;        <span class="hljs-keyword">for</span> i:=min+<span class="hljs-number">1</span>;i&lt;last;i++&#123;            num[i] -=minNum+<span class="hljs-number">1</span>        &#125;        sum = (last-min<span class="hljs-number">-1</span>) *(minNum+<span class="hljs-number">1</span>)+(n-(last-min)+<span class="hljs-number">1</span>)*minNum    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;            num[i]-=minNum        &#125;        sum = n*minNum    &#125;    num[min] = sum    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>&#123;            fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,num[i])        &#125;<span class="hljs-keyword">else</span>&#123;            fmt.Printf(<span class="hljs-string">&quot; %d&quot;</span>,num[i])        &#125;    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：686ms, 超过66.67%用Go提交的代码<br>   占用内存：6812KB, 超过83.33%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点排序</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%82%B9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E7%82%B9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="点排序"><a href="#点排序" class="headerlink" title="点排序"></a><font size=6px>点排序</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>P为给定的二维平面整数点集。定义 P 中某点x，如果x满足 P 中任意点都不在 x 的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复, 坐标轴范围在[0, 1e9) 内）</p><p>如下图：实心点为满足条件的点的集合。请实现代码找到集合 P 中的所有 ”最大“ 点的集合并输出。</p><p><img src="https://uploadfiles.nowcoder.com/images/20170817/300557_1502940399706_1329AFEA3FC7961DEA219781A71B3B5B" alt="img"></p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs excel">第一行输入点集的个数 <span class="hljs-built_in">N</span>， 接下来 <span class="hljs-built_in">N</span> 行，每行两个数字代表点的 X 轴和 Y 轴。对于 <span class="hljs-number">50%</span>的数据,  <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">N</span> &lt;= <span class="hljs-number">10000</span>;对于 <span class="hljs-number">100%</span>的数据, <span class="hljs-number">1</span> &lt;= <span class="hljs-built_in">N</span> &lt;= <span class="hljs-number">500000</span>;</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs tp">输出“最大的” 点集合， 按照 <span class="hljs-keyword">X</span> 轴从小到大的方式输出，每行两个数字分别代表点的 <span class="hljs-keyword">X</span> 轴和 <span class="hljs-keyword">Y</span>轴。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-number">5</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><span class="hljs-symbol">9 </span><span class="hljs-number">0</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;<span class="hljs-type">string</span>.h&gt;using namespace std;<span class="hljs-keyword">struct</span> node&#123;    <span class="hljs-type">int</span> x;    <span class="hljs-type">int</span> y;&#125;;<span class="hljs-type">bool</span> cmp(<span class="hljs-keyword">struct</span> node a,<span class="hljs-keyword">struct</span> node b)&#123;    <span class="hljs-keyword">if</span>(a.x&lt;b.x)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-type">int</span> max(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;    <span class="hljs-keyword">if</span>(a&gt;b)&#123;        <span class="hljs-keyword">return</span> a;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b;    &#125;&#125;<span class="hljs-type">int</span> main()&#123;    <span class="hljs-type">int</span> n;    scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">struct</span> node node1[n];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;node1[i].x,&amp;node1[i].y);    &#125;    sort(node1,node1+n,cmp);    <span class="hljs-type">int</span> maxNum[n];    memset(maxNum,<span class="hljs-number">0</span>,sizeof(maxNum));    maxNum[n<span class="hljs-number">-1</span>] = node1[n<span class="hljs-number">-1</span>].y;    <span class="hljs-comment">//找出这个点到最后的数中最大数</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;        maxNum[i] = max(maxNum[i+<span class="hljs-number">1</span>],node1[i].y);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        <span class="hljs-keyword">if</span>(node1[i].y==maxNum[i])&#123;            printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>,node1[i].x,node1[i].y);        &#125;    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：207ms, 超过89.17%用C++提交的代码<br>   占用内存：19556KB, 超过27.91%用C++提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>情侣间的日常琐事记录</title>
    <link href="/2022/01/21/%E6%83%85%E4%BE%A3%E7%94%9C%E8%9C%9C%E5%B0%8F%E6%97%A5%E5%B8%B8/"/>
    <url>/2022/01/21/%E6%83%85%E4%BE%A3%E7%94%9C%E8%9C%9C%E5%B0%8F%E6%97%A5%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="情侣间的日常琐事记录"><a href="#情侣间的日常琐事记录" class="headerlink" title="情侣间的日常琐事记录"></a>情侣间的日常琐事记录</h1><p class="label label-warning"style= "font-size:24px" >记录了一部分成为情侣之后的日常，超甜勿看</p><hr><h3 id="2020-7-10第一次约会去撸猫"><a href="#2020-7-10第一次约会去撸猫" class="headerlink" title="2020.7.10第一次约会去撸猫"></a>2020.7.10第一次约会去撸猫</h3><h3 id="2020-7-12-yyj生日、第一次一起去逛西湖"><a href="#2020-7-12-yyj生日、第一次一起去逛西湖" class="headerlink" title="2020.7.12 yyj生日、第一次一起去逛西湖"></a>2020.7.12 yyj生日、第一次一起去逛西湖</h3><h3 id="2020-7-19-答辩结束-yyj到家啦-虽然结果不咋地-但是收获了一个npy-不错"><a href="#2020-7-19-答辩结束-yyj到家啦-虽然结果不咋地-但是收获了一个npy-不错" class="headerlink" title="2020.7.19 答辩结束:yyj到家啦,虽然结果不咋地,但是收获了一个npy,不错~"></a>2020.7.19 答辩结束:yyj到家啦,虽然结果不咋地,但是收获了一个npy,不错~</h3><h3 id="2020-8-25第一个情人节-看了第一场电影、收获第一支玫瑰🌹"><a href="#2020-8-25第一个情人节-看了第一场电影、收获第一支玫瑰🌹" class="headerlink" title="2020.8.25第一个情人节,看了第一场电影、收获第一支玫瑰🌹"></a>2020.8.25第一个情人节,看了第一场电影、收获第一支玫瑰🌹</h3><h3 id="2020-9-6他来抗州找我玩，第一出去逛了宜家"><a href="#2020-9-6他来抗州找我玩，第一出去逛了宜家" class="headerlink" title="2020.9.6他来抗州找我玩，第一出去逛了宜家"></a>2020.9.6他来抗州找我玩，第一出去逛了宜家</h3><h3 id="2020-10-2获得了秋天第一个柚子"><a href="#2020-10-2获得了秋天第一个柚子" class="headerlink" title="2020.10.2获得了秋天第一个柚子"></a>2020.10.2获得了秋天第一个柚子</h3><hr>]]></content>
    
    
    <categories>
      
      <category>生活杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝绿部署、金丝雀部署的含义和区别</title>
    <link href="/2022/01/21/%E8%93%9D%E7%BB%BF%E9%83%A8%E7%BD%B2%E3%80%81%E9%87%91%E4%B8%9D%E9%9B%80%E9%83%A8%E7%BD%B2%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E8%93%9D%E7%BB%BF%E9%83%A8%E7%BD%B2%E3%80%81%E9%87%91%E4%B8%9D%E9%9B%80%E9%83%A8%E7%BD%B2%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="蓝绿部署、金丝雀部署的含义和区别"><a href="#蓝绿部署、金丝雀部署的含义和区别" class="headerlink" title="蓝绿部署、金丝雀部署的含义和区别"></a>蓝绿部署、金丝雀部署的含义和区别</h2><p>在一般情况下，升级服务器端应用，需要将应用源码或程序包上传到服务器，然后停止掉老版本服务，再启动新版本。但是这种简单的发布方式存在两个问题，一方面，在新版本升级过程中，服务是暂时中断的，另一方面，如果新版本有BUG，升级失败，回滚起来也非常麻烦，容易造成更长时间的服务不可用。<strong>为了解决这些（服务中断、失败回滚、……）问题，人们研究出了多种发布策略。</strong></p><h5 id="1、蓝绿部署-–-BlueGreenDeployment"><a href="#1、蓝绿部署-–-BlueGreenDeployment" class="headerlink" title="1、蓝绿部署 – BlueGreenDeployment"></a>1、蓝绿部署 – BlueGreenDeployment</h5><blockquote><p>It’s basically a technique for <em>releasing your application in a predictable</em> manner with an goal of <em>reducing any downtime associated with a release</em>. It’s a quick way to prime your app before releasing, and also quickly roll back if you find issues.</p></blockquote><p><strong>蓝绿部署的目的是——减少因发布导致的服务中断时间</strong>，同时它也支持发布失败时的快速回滚。</p><p><img src="https://ixyzero.com/blog/wp-content/uploads/2020/01/blue_green_deployments.png" alt="img"></p><p>蓝绿部署需要在发布过程中，同时运行两套程序。对硬件的要求也是当前所需的2倍，比如当前运行时，需要10台服务器支撑业务，那么使用蓝绿部署，你就需要购置20台服务器。</p><h5 id="2、滚动发布-x2F-更新"><a href="#2、滚动发布-x2F-更新" class="headerlink" title="2、滚动发布&#x2F;更新"></a>2、滚动发布&#x2F;更新</h5><p>所谓滚动发布，就是在发布过程中，并不一下子启动所有新版本，而是先启动一台新版本，再停止一台老版本，然后再启动一台新版本，再停止一台老版本，直到全部发布完成，这样的话，如果当前需要10台服务器支撑服务，那么升级过程中一共只需要11台就行了。</p><p><strong>滚动发布能够解决掉蓝绿部署时对硬件要求增倍的问题。</strong></p><p>但是滚动发布有一个问题，在开始滚动发布后，流量会直接流向已经启动起来的新版本，但是这个时候，新版本是不一定稳定&#x2F;符合预期的，可能需要进一步的测试才能确认。那么在滚动发布期间，整个系统就处于较为不稳定的状态，如果发现了问题，也比较难以确定是新版本还是老版本造成的问题。<br>为了解决这个问题，我们需要为滚动发布实现流量控制能力。也就是下面的金丝雀发布&#x2F;灰度发布。</p><h5 id="2-1、金丝雀发布-–-也叫灰度发布"><a href="#2-1、金丝雀发布-–-也叫灰度发布" class="headerlink" title="2.1、金丝雀发布 –  (也叫灰度发布)"></a>2.1、金丝雀发布 –  (也叫灰度发布)</h5><blockquote><p>17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离。</p><p>金丝雀发布(Canary Releases)名称的由来</p></blockquote><p>金丝雀发布指的是在生产环境中分阶段逐步更新后端应用的版本（需要具备流量控制能力），在小范围验证符合预期之后，再推广至整个生产环境。</p><p><img src="https://ixyzero.com/blog/wp-content/uploads/2020/01/canary-release-2.png" alt="img"></p><p><strong>金丝雀发布的好处在于可以用真实环境测试新版本</strong>，当新版本存在问题时最多只影响部分用户，且支持安全快速的回滚策略（将路由到新版本上的流量切换到其它的老版本机器上即可）。</p><p>但金丝雀发布并不是完美的，如果新版本有问题，那么路由到新版本的小部分流量会有问题，就跟矿井中毒发身亡的金丝雀一样。这种做法在非常敏感的业务中几乎无法接受，但是当系统复杂的到一定程度，错误无法完全避免的时候，为了避免出现更大的问题，牺牲一小部分流量，就可以将大部分错误的影响控制在一定范围内。</p><hr><h5 id="A-x2F-B测试-–-A-x2F-B-Testing"><a href="#A-x2F-B测试-–-A-x2F-B-Testing" class="headerlink" title="A&#x2F;B测试 – A&#x2F;B Testing"></a>A&#x2F;B测试 – A&#x2F;B Testing</h5><p><strong>首先需要明确的是，A&#x2F;B测试和蓝绿部署以及金丝雀发布，完全是不同类型的概念。</strong></p><p>蓝绿部署和金丝雀发布是发布策略，目标是确保新上线的系统稳定，关注的是新系统的BUG、隐患。</p><p><strong>A&#x2F;B测试是效果测试（一般用来验证某个想法是否符合预期）</strong>，同一时间有多个版本的服务对外服务，这些服务都是经过足够测试，达到了上线标准的服务，有差异但是没有新旧之分。它关注的是不同版本的服务的实际效果，譬如说转化率、订单情况等。</p><p>A&#x2F;B测试时，线上同时运行多个版本的服务，这些服务通常会有一些体验上的差异，譬如说页面样式、颜色、操作流程不同。相关人员通过分析各个版本服务的实际效果，以选出效果最好的版本。</p><p><img src="https://ixyzero.com/blog/wp-content/uploads/2020/01/abtesting.png" alt="img"></p><p>参考文章：<a href="https://ixyzero.com/blog/archives/4722.html">https://ixyzero.com/blog/archives/4722.html</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka和redis作为消息队列的差别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka%E5%92%8Credis%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%AE%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka%E5%92%8Credis%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%AE%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="kafka和redis作为消息队列的差别"><a href="#kafka和redis作为消息队列的差别" class="headerlink" title="kafka和redis作为消息队列的差别"></a>kafka和redis作为消息队列的差别</h2><p>1、需要使用多消费组情况的时候redis做不了，redis的list只能支持一个消费者pop，kafka可以使用多个group重复消费一个数据。</p><p>2、当订阅者断开重连会丢失断开期间发布者发布的消息，而kafka中会记录每个消费者消费的topic的offset，因此kafka可以从断开的offset继续消费。</p><p>3、高并发情况的下的list无法通过扩容解决问题，kafka可以扩partition。</p><p>4、没有确认机制，每当pop了之后消息就永远从list删除，消费者如果消费失败就永远不能找回这条消息了</p><p>5、redis断电无法保证数据完全不丢，kakfa不会，kafka可靠</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>encoder/json为什么慢</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/encoder:json%E4%B8%BA%E4%BB%80%E4%B9%88%E6%85%A2/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/encoder:json%E4%B8%BA%E4%BB%80%E4%B9%88%E6%85%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="encoder-x2F-json为什么慢"><a href="#encoder-x2F-json为什么慢" class="headerlink" title="encoder&#x2F;json为什么慢"></a>encoder&#x2F;json为什么慢</h3><p>因为使用了较多的反射，会导致时间变慢</p><h3 id="为什么jsoniter快"><a href="#为什么jsoniter快" class="headerlink" title="为什么jsoniter快"></a>为什么jsoniter快</h3><ul><li>减少不必要的内存复制。</li><li>减少 反射(<code>reflect</code>） 的使用，对同一类型的对象，<code>jsoniter </code>只反射一次之后即缓存下来。</li><li>获取部分内容的时候尽可能解析少的东西，按需解析</li></ul><p>和 encoding&#x2F;json 的区别是，标准库使用的是 reflect.ValueOf ，然后根据 json 的输入情况去找对应的 field 和 element 。而 jsoniter 的实现是反过来的，用 reflect.TypeOf 确定一个 json 的 schema ，然后根据 schema 产生对应的 decoder 。如果 json 输入不符合这个 decoder 则报错。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从前端到后端到数据库有什么优化办法</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%90%8E%E7%AB%AF%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E5%8A%9E%E6%B3%95/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%90%8E%E7%AB%AF%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>1、减少网络传输时间</p><ul><li>传输协议：使用rpc协议而不是http来进行传输。</li><li>多地部署服务，使用CDN把请求导引到最近的服务减少在网络传输的时间 。</li></ul><p>2、使用 k8s service的或者 nginx 反向代理负载均衡减少每个请求处理的时间。</p><p>3、数据库层面进行索引优化</p><ul><li>mysql表结构和索引进行优化，减少mysql查找时间。</li><li>使用redis等内存数据库作为缓存，使用先更新数据库再删redis来做到最终一致性。</li><li>数据库进行读写分离操作，提高查询效率。</li></ul><p>4、代码层面优化</p><ul><li><p>使用多个协程配合 channal 同步信息来做到充分利用多核cpu，减少代码运行时间</p></li><li><p>限制goroutine数量，防止太多导致cpu的时候都在goroutine上下文切换中</p></li></ul><p>5、增加硬件配置</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脑裂</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98-%E8%84%91%E8%A3%82/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98-%E8%84%91%E8%A3%82/</url>
    
    <content type="html"><![CDATA[<h1 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>集群中的Master或Leader节点往往是通过选举产生的。在网络正常的情况下，可以顺利的选举出Leader（后续以Zookeeper命名为例）。但当两个机房之间的网络通信出现故障时，选举机制就有可能在不同的网络分区中选出两个Leader。当网络恢复时，这两个Leader该如何处理数据同步？又该听谁的？这也就出现了“脑裂”现象。</p><h3 id="Zookeeper的解决方案-过半原则"><a href="#Zookeeper的解决方案-过半原则" class="headerlink" title="Zookeeper的解决方案-过半原则"></a>Zookeeper的解决方案-过半原则</h3><p>所谓的过半原则就是：在Leader选举的过程中，如果某台zkServer获得了超过半数的选票，则此zkServer就可以成为Leader了。</p><p>Zookeeper集群通过过半机制，达到了要么没有Leader，要没只有1个Leader，这样就避免了脑裂问题。</p><p>对于过半机制除了能够防止脑裂，还可以实现快速的选举。因为过半机制不需要等待所有zkServer都投了同一个zkServer就可以选举出一个Leader，所以也叫快速领导者选举算法。</p><p>假设某个Leader假死，其余的followers选举出了一个新的Leader。这时，旧的Leader复活并且仍然认为自己是Leader，向其他followers发出写请求也是会被拒绝的。</p><p>因为ZooKeeper维护了一个叫epoch的变量，每当新Leader产生时，会生成一个epoch标号（标识当前属于那个Leader的统治时期），epoch是递增的，followers如果确认了新的Leader存在，知道其epoch，就会拒绝epoch小于现任leader epoch的所有请求。</p><p>那有没有follower不知道新的Leader存在呢，有可能，但肯定不是大多数，否则新Leader无法产生。ZooKeeper的写也遵循quorum机制，因此，得不到大多数支持的写是无效的，旧leader即使各种认为自己是Leader，依然没有什么作用。</p><p>并且Zookeeper一般是奇数个数</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口限流方式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="接口限流算法"><a href="#接口限流算法" class="headerlink" title="接口限流算法"></a>接口限流算法</h2><p>常用的限流算法有<strong>令牌桶和和漏桶</strong>，而Google开源项目Guava中的RateLimiter使用的就是令牌桶控制算法。</p><h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。</p><p><img src="https://segmentfault.com/img/remote/1460000015967925?w=443&h=299" alt="img"></p><p>漏斗有一个进水口 和 一个出水口，出水口以一定速率出水，并且有一个最大出水速率：</p><p>在漏斗中没有水的时候，</p><ul><li>如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，此时，不会积水</li><li>如果进水速率大于最大出水速率，那么，漏斗以最大速率出水，此时，多余的水会积在漏斗中</li></ul><p>在漏斗中有水的时候</p><ul><li>出水口以最大速率出水</li><li>如果漏斗未满，且有进水的话，那么这些水会积在漏斗中</li><li>如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外</li></ul><h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。</p><p>令牌桶算法的原理是系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p><p><img src="https://segmentfault.com/img/remote/1460000015967926?w=363&h=215" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大二上半学期学期总结</title>
    <link href="/2022/01/21/%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%8D%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/21/%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%8D%8A%E5%AD%A6%E6%9C%9F%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>​    </p><p>​    很快半年就过去了，都懒得写半年总结，每天都在催自己写，每天都说明天一定写，真的人人都笑贝塔，人人都是贝塔，贝塔最经典的语录就是，在寝室晚上的时候“明天一定学习，阿健明天带我去图书馆学习”，然后在寝室玩了一天电脑，其实我也差不多，寒假在家当个废物，不想写算法题不想起床，在家写了一会就不想写了，就叫女朋友打游戏去了。最近有点丧，想个办法改变一下，越玩愧疚感越大。</p><p>​    总的来说，大二上这半年是失败的，考试考试没考好，方法没用对，平时也不怎么努力学，平时都在写acm布置的作业（ps：这作业每周要花好久写），因为想早点去公司实习，要早点开始准备企业的面试，就好好写这个作业，然后其他作业很多都是很草率，什么工程经济学项目管理课都是乱来的，想不去就不去，因为每天差不多一点睡，早上8点起，感觉有报复性迟到的心理，只要是早八课就必迟到。</p><p>​    先说说班级的事情吧，大二转专业来到一个新班级，真就个个是学霸，确实班级里面就有很多大佬，跟他们相处之后发现大一一年一点计算机没学确实落后很多，会比你更早进入实验室、老师的项目、新苗之类的，哦对了，还是选择当班长，班长很水，事情没多少，听着还威风呢，然后还有李子睿同学全程安排了一次班会，班级水果捞，水果吃的很开心，还有班级小游戏玩的很开心。</p><p>​    再说说学业上面做了什么，参加了数学建模认证杯，成功拿了一个参赛奖，还干了啥，上课睡觉，早课迟到，这学期过的很水，感觉有些课真的不太听得懂，比如数据结构，都是好多都是课后自学的。哦对，还有创新实践，我承认这个创新实践是乱选的（听学长推荐的），选了嵌入式，不过老师真的很不错，很和善，教的还好，她带的研究生教的也好，很热心回答问题，我导师她还帮我找了服务外包大赛的队员，谢谢张桦老师。</p><p>  说说我学到了什么，这个确实还是挺多的，加入了杭电助手的后台部，跟着社团接触到了golang语言和它的gorm和gin框架，最近就用goalng写力扣，上acm课系统的学了一遍算法，上数据结构课基础的数据结构都能掌握，上创新实践也了解了一点硬件的知识，硬件和电脑用串口和wifi的两种通信方式，还有学了sql serve，了解了关系型数据库基本的构建过程，就是先画er图之后在建表这些，我还用hexo弄了个静态的博客，现在我打算把它部署到服务器上面，每天更换一张好看的图片到首页，让他变成动态。</p><p>​    说说爱情方面，想想我们这半年都去过什么地方，去过杭州动物园，去良渚看风景，和一起做了一顿饺子（皮厚馅少，面包蟹好吃），一起做了一度饭（好家伙忘记买米了，还没了一把雨伞和忘记拿充电头），一起吃了炸鸡，自助烤肉，牛排，奶酸菜鱼，肯德基，吴山烤禽，一起去点了痣。。。。。</p><p>​    总的来说，是失败的，失败中藏着胜利，这个寒假要做的事情还是很多的，准备浙大的pat考试乙级，学习js，在寒假也开始做服务外包大赛的前期准备，还问了学长接下来go该怎么做，他教我让我自己包装一个阿里dns接口，然后把我的博客用nginx弄成动态再acme部署https证书，还是有很多事情做（自己还这么懒，打自己两巴掌）想好了之后大方向是想做后端&#x2F;算法岗位，不过阿里和字节都举办了前端练习生活动，大公司前端岗位缺失，也会考虑一下前端吧，再说。</p>]]></content>
    
    
    <categories>
      
      <category>生活杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解释型语言和编译型语言的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="解释型语言和编译型语言的区别"><a href="#解释型语言和编译型语言的区别" class="headerlink" title="解释型语言和编译型语言的区别"></a>解释型语言和编译型语言的区别</h2><h3 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h3><p>定于：编译型语言是需通过编译器(compiler)将源代码编译成机器码之后才能执行的语言。一般需经过编译(compile)、链接(linker)这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。</p><p>执行过程：源代码-&gt;汇编代码-&gt;机器码-&gt;CPU执行</p><p>特点：执行效率高：只须编译一次就可以把源代码编译成机器码，后面的执行无须重新编译，直接使用之前的编译结果，可以脱离语言环境独立运行(不需要虚拟机)</p><p>适用范围：编译型语言由于程序执行速度快，同等条件下对系统的要求比较低，因此像开发操作系统、大型应用程序、数据库系统等软件时一般采用它</p><p>跨平台性差：依赖于编译器，编译之后如果需要修改就要将整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件</p><h3 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h3><p>解释型语言的程序不需要编译，相比编译型语言省了道工序，解释性语言在运行程序的时候才逐行翻译。</p><p>执行过程：源代码-&gt;字节码-&gt;解释器-&gt;机器码-&gt;CPU执行</p><p>解释型语言能跨平台，是指源代码跨平台，而不是解释器跨平台。解释器用来将源代码转换成字节码，它就是一个可执行程序，是绝对不能跨平台的。在不同的平台下，解释器会将相同的源代码转换成不同的机器码，解释器帮助我们屏蔽了不同平台之间的差异</p><p>参考文章：<a href="https://blog.csdn.net/weixin_34025386/article/details/116487152?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-116487152.pc_agg_new_rank&amp;utm_term=go%E8%AF%AD%E8%A8%80%E6%98%AF%E7%BC%96%E8%AF%91%E5%9E%8B%E8%BF%98%E6%98%AF%E8%A7%A3%E9%87%8A%E5%9E%8B&amp;spm=1000.2123.3001.4430">https://blog.csdn.net/weixin_34025386/article/details/116487152?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-116487152.pc_agg_new_rank&amp;utm_term=go%E8%AF%AD%E8%A8%80%E6%98%AF%E7%BC%96%E8%AF%91%E5%9E%8B%E8%BF%98%E6%98%AF%E8%A7%A3%E9%87%8A%E5%9E%8B&amp;spm=1000.2123.3001.4430</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大一生活的总结</title>
    <link href="/2022/01/21/%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%A4%A7%E5%AD%A6%E4%B8%80%E5%B9%B4%E7%94%9F%E6%B4%BB%E7%9A%84%E6%84%9F%E6%82%9F/"/>
    <url>/2022/01/21/%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%A4%A7%E5%AD%A6%E4%B8%80%E5%B9%B4%E7%94%9F%E6%B4%BB%E7%9A%84%E6%84%9F%E6%82%9F/</url>
    
    <content type="html"><![CDATA[<p>​      </p><p>大一生活最大的收获就是从经济转去了计算机，顺便在转去的时候拿了个一等奖学金。</p><p>​      大一的时候把全部精力都投入怎么提高绩点的路上了，其实现在想起来哦，好多东西都学的太迟了，在大一下的时候才从学长学姐那边了解到以后就业分前后端两个大方向，前端是做页面，在vue，react等主流框架下写代码，后端与数据库打交道，写完后写api接口给前端用，其实我最开始选择后端是因为赚钱多，毕竟后端的任务比较难，前端好上手，一写代码就能看到成果，但是好像以后就业活会比较枯燥比较机械，现在开始加入杭助后端，开始学golang和数据库，和大佬比学的太迟了。</p>  <h2>学习篇：</h2><p>​    在大一下疫情在家的时间，自学了c，学习了指针，链表，结构体，数据结构也学了栈，队列，还有到现在都没理解的分治算法（递归的方式看不懂），二叉树，还有自学了python，但是只能写写基础语法，然后在大一下学了前端的html和css语言（确实很好上手，没有什么逻辑关系，就是没有if语句这些判断），最后还有大一下买的吉他，谈了几天到学校就没时间谈学（现在已经积灰了）。</p> <h2>竞赛篇：</h2> <p>大一下参加证卷投资大赛，发现选导师真的很重要，如果他是你的评委老师你做的东西对他口味分数就会高，其实这个比赛策略组根本就不需要基础，导师会给你题目，给你模板和大概方向，你只需要一定时间把word写长和ppt做漂亮，然后给导师改一下，就能得奖。感觉统调，金融创新应该都差不多，含金量不高，还是大创含金量相对高一点，不过最后还是要花大量时间写word和ppt，一般比赛的时候熬夜是常态，推荐竞赛的话血推数模，acm（这比赛大一就要训练，一般人还参加不了），真的挺硬核。你说大一没人带不敢参加竞赛，其实感兴趣大胆参加，你说没想法，你可以只找一个最粗略的想法，然后找导师问问，如果最粗略也没有，只要你脸皮够厚，直接找导师要，毕竟你拿奖了对导师也有好处，最好早点找导师，迟了可能导师人太多不要你，这是我个人意见，看看就好了。（竞赛真的要多参加哦，说不定有意外惊喜，我女朋友就是竞赛认识的）</p>  <h2>社团篇：</h2><p>社团粗略分为三类，学生会杭助非技术部这种干活交朋友写策划社团，滑轮滑板等兴趣社团，红家、杭电助手技术部这种技术社团，当然还有这种特点都有的社团，我大一参加了经济学院学生会，说一下体验吧，几乎学院一半的人都加入了学生会，你可以在里面交到各种各样的人，还有部门联谊，部长也很亲切，不过一般最亲切的还是同部门的人，举办活动还有东西吃圣诞节还会给你送糖果吃，如果你加入了也最好别退，因为你退了的话本来属于你的活就要平均分配到其他小干事身上和部长身上。其实本质来说哦，就是招你去干活的，事情会挺多，真的贼多，好多活动会轮到你们部门出策划，大家就想想法，出策划，不过等你们部门想的活动节目顺利办完了的时候还是有点小成就感的。我感觉我不适合这种部门，而且竞赛和学业这两个事情有可能会和社团的事情重合，那就有你的爽了。兴趣社团我也去，杭助也才刚刚二面，等体验过了以后再说。</p><hr><p>  最后说说我最近的状态吧，等转到计算机，我熬夜已经成为常态，天天1点睡，4天有早课，然后水课补课，主要选了acm（这课很值），数据结构这种课，要花好长时间写作业，还有报了社团，得花很多时间学东西，还有勤工俭学，帮老师改作业，事情太多了，感觉最近人有点累和迷茫了，得找个时间出去散散心。<br>    1、不是特别清楚下一步怎么走，不知道怎么找老师怎么找项目做，2、不知道从学校到实习这一步改怎么走（打算问问已经工作学长学姐），3、不知道怎么去规划自己的后端学习路线（打算问问部长），好迷茫压，感觉最近学习效率也不高，学了一会不想学了。算了，其实也没关系，都是有办法解决的，跨过这座山，他们就会听见你的故事，先写到这里吧，等我 把这3个问题都解决了就更我的未来学习打算，恋爱部分这边不提了，我整一个完整的板块写。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>幂等性</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%B9%82%E7%AD%89%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>幂等，这个词来源自数学领域。幂等性衍生到软件工程中，它的语义是指：函数&#x2F;接口可以使用相同的参数重复执行, 不应该影响系统状态，也不会对系统造成改变。</p><p>举一个简单的例子：正常设计的查询接口，不管调用多少次，都不会破坏当前的系统或数据，这就是一个幂等操作。</p><p>由于分布式天然特性的时序问题以及网络的不可靠性(机器、机架、机房故障、电缆被挖断等等)， 重复请求很常见，接口幂等性设计就显得尤为重要。</p><p>幂等需要考虑的场景有很多，例如系统A是处理用户客户端发送过来的请求，无论是前端bug、脚本恶意发包、用户重复点击又或是网络超时导致的网络重发，都会造成系统A收到相同参数的网络请求。</p><h3 id="保障幂等性的原理"><a href="#保障幂等性的原理" class="headerlink" title="保障幂等性的原理"></a>保障幂等性的原理</h3><p>对于分布式系统来说，在JVM层面的锁已经失去作用，所以保证系统幂等性需要满足3个条件:</p><ol><li>请求唯一标识：每一个请求必须有一个唯一标识。</li><li>处理唯一标识：每次处理完请求之后，必须有一个记录标识这个请求处理过了。</li><li>逻辑判断处理：每次接收请求需要进行判断之前是否处理过的逻辑处理。根据请求唯一标识查询是否存在处理唯一标识。</li></ol><h2 id="幂等性实现方案"><a href="#幂等性实现方案" class="headerlink" title="幂等性实现方案"></a>幂等性实现方案</h2><h3 id="1-token机制"><a href="#1-token机制" class="headerlink" title="1. token机制"></a>1. token机制</h3><p>针对客户端重复连续多次点击的情况，例如用户购物提交订单，提交订单的接口就可以通过token机制实现防止重复提交。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5086501/41ebd6f037094556b29d7cdb6b607a78.png?imageView2/2/w/1620" alt="img"></p><p>主要流程就是：</p><ol><li>服务端提供生成请求token的接口。在存在幂等问题的业务执行前，向<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>获取请求token，服务器会把token保存到<a href="https://cloud.tencent.com/product/crs?from=10680">Redis</a>中。</li><li>然后调用业务接口请求时，把请求token携带过去，一般放在请求头部。</li><li>服务器判断请求token是否存在redis中：存在则表示第一次请求，这时把Redis中的token删除，继续执行业务；如果判断token不存在redis中，就表示是重复操作，直接返回重复标记给client，这样就保证了业务代码，不被重复执行。</li></ol><blockquote><p>这里要结合业务考虑这种场景：如果请求处理失败，前端是否需要重新申请token进行重试（因为此时token在服务端已经被删除）。</p></blockquote><h3 id="2-数据库唯一索引"><a href="#2-数据库唯一索引" class="headerlink" title="2. 数据库唯一索引"></a>2. <a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>唯一索引</h3><p>往数据库表里插入数据的时候，利用数据库的唯一索引特性，保证唯一的逻辑。唯一序列号可以是一个字段，例如订单的订单号，也可以是多字段的唯一性组合。</p><blockquote><p>事务中包含多表数据的更新，业务要考虑处理事务回滚的问题。</p></blockquote><h3 id="3-Redis实现"><a href="#3-Redis实现" class="headerlink" title="3. Redis实现"></a>3. Redis实现</h3><p>Redis实现的方式就是将唯一序列号作为Key存入Redis，在请求处理之前，先查看Key是否存在。唯一序列号可以是一个字段，例如订单的订单号，也可以是多字段的唯一性组合。当然这里需要设置一个key的过期时间，否则Redis中会存在过多的key。具体校验流程如下图所示：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5086501/f0fcf4c410824d93a2be939cadf0bd5a.png?imageView2/2/w/1620" alt="img"></p><p>如果想要基于Redis实现幂等性防重框架，需要考虑如下两个问题：</p><ol><li>如果第一次请求失败了，客户端重试，是否需要放行？</li><li>网络请求可能是get或者post（内部rpc协议除外），唯一序列号参数可能在url或是在body体里。则使用防重框架的新接口以及之前老业务接口能否做到版本兼容性？</li></ol><blockquote><p>建议业务使用方最好针对指定业务进行Redis的幂等方案。</p></blockquote><p>Zookeeper同样也能实现上述功能，但由于Zookeeper是CP模型，性能不如Redis，另外针对防重场景，也并不需要Zookeeper高可靠性，所以优先推荐Redis。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分模块刷力扣题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/1%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E7%89%9B%E5%AE%A2%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/1%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E7%89%9B%E5%AE%A2%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><style>table th:first-of-type {    width: 20%;}table th:nth-of-type(2) {    width: 50%;}table th:nth-of-type(3) {    width: 20%;} table th:nth-of-type(4) {    width: 30%;}</style><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">题目</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">万万没想到之抓捕孔连顺</td><td align="center"></td><td align="center">golang</td><td align="center">普通</td></tr><tr><td align="center">机器人跳跃问题</td><td align="center">认真读题目</td><td align="center">golang</td><td align="center">普通</td></tr><tr><td align="center">选区间</td><td align="center"></td><td align="center">c</td><td align="center">中等</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">万万没想到之聪明的编辑</td><td align="center"></td><td align="center">go</td><td align="center">入门</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">字节跳动附加题</td><td align="center">熟悉了递推式</td><td align="center">go</td><td align="center">普通</td></tr><tr><td align="center">编程题2</td><td align="center"></td><td align="center">go</td><td align="center">中等</td></tr><tr><td align="center">字母交换</td><td align="center">看懂递推式</td><td align="center">c</td><td align="center">普通</td></tr><tr><td align="center">毕业旅行问题</td><td align="center">学会压缩状态动态规划</td><td align="center">c</td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">头条校招</td><td align="center"></td><td align="center">go</td><td align="center">普通</td></tr><tr><td align="center">最大点集</td><td align="center"></td><td align="center">c</td><td align="center">普通</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MT4 直方图内最大矩形</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/MT4%20%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%86%85%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/MT4%20%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%86%85%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="直方图内最大矩形"><a href="#直方图内最大矩形" class="headerlink" title="直方图内最大矩形"></a><font size=6px>直方图内最大矩形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组heights，长度为n，height[i]是在第i点的高度，那么height[i]表示的直方图，能够形成的最大矩形是多少?</p><p>1.每个直方图宽度都为1</p><p>2.直方图都是相邻的</p><p>3.如果不能形成矩形，返回0即可</p><p>4.保证返回的结果不会超过231-1</p><p>数据范围:</p><p>0 &lt;&#x3D; heights[i] &lt;&#x3D; 10^40&lt;&#x3D;<em>h<strong>e</strong>i<strong>g</strong>h<strong>t</strong>s</em>[<em>i</em>]&lt;&#x3D;104</p><p>0 &lt;&#x3D; heights.length &lt;&#x3D;10^50&lt;&#x3D;<em>h<strong>e</strong>i<strong>g</strong>h<strong>t</strong>s</em>.<em>l<strong>e</strong>n<strong>g</strong>t**h</em>&lt;&#x3D;105</p><p>如输入[3,4,7,8,1,2]，那么如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20211106/301499_1636186669482/D4212B8149018E3A3A42996A461EA3FC" alt="img"></p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><pre><code class="hljs accesslog"><span class="hljs-string">[3,4,7,8,1,2]</span></code></pre><p>复制</p><p>返回值：</p><pre><code class="hljs">14</code></pre><p>复制</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><pre><code class="hljs dns">[<span class="hljs-number">1,7,3,2</span>,<span class="hljs-number">4,5,8,2</span>,<span class="hljs-number">7</span>]</code></pre><p>返回值：</p><pre><code class="hljs">16</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>单调栈思路做，如果一个数比之前的大就入栈，确保栈里面的数据是有序的，然后遇到比自己小的就出栈直到栈有序，这里有个技巧是加入哨兵就可以简化判断边界情况的复杂度。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">( heights []<span class="hljs-type">int</span> )</span></span> <span class="hljs-type">int</span> &#123;        <span class="hljs-keyword">var</span>  stack []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> heights == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-comment">// 插入一个数防止栈空</span>    stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-number">0</span>)    heights = <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>&#125;, heights...)    maxNum := heights[<span class="hljs-number">1</span>]    heights = <span class="hljs-built_in">append</span>(heights, <span class="hljs-number">-1</span>)    n := <span class="hljs-built_in">len</span>(heights)    secondTop := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        top := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack )&gt;<span class="hljs-number">1</span>&#123;            secondTop = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-2</span>]        &#125;<span class="hljs-keyword">else</span>&#123;            secondTop = top        &#125;            <span class="hljs-keyword">for</span> heights[top]&gt;heights[i]&#123;                maxNum = max((i - secondTop<span class="hljs-number">-1</span>) * heights[top], maxNum)                stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]                top = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">1</span>&#123;                    secondTop = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-2</span>]                &#125;<span class="hljs-keyword">else</span>&#123;                    secondTop = top                &#125;            &#125;        stack = <span class="hljs-built_in">append</span>(stack, i)    &#125;    <span class="hljs-keyword">return</span> maxNum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：35ms超过56.52% 用Go提交的代码<br>   占用内存：10292KB超过39.13%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为2016校园招聘上机笔试题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%8D%8E%E4%B8%BA2016%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E4%B8%8A%E6%9C%BA%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%8D%8E%E4%B8%BA2016%E6%A0%A1%E5%9B%AD%E6%8B%9B%E8%81%98%E4%B8%8A%E6%9C%BA%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs gcode">时间复杂度：<span class="hljs-comment">()</span>,空间复杂度：<span class="hljs-comment">()</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>万万没想到之抓捕孔连顺</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E6%8A%93%E6%8D%95%E5%AD%94%E8%BF%9E%E9%A1%BA/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E6%8A%93%E6%8D%95%E5%AD%94%E8%BF%9E%E9%A1%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="万万没想到之抓捕孔连顺"><a href="#万万没想到之抓捕孔连顺" class="headerlink" title="万万没想到之抓捕孔连顺"></a><font size=6px>万万没想到之抓捕孔连顺</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议</p><ol><li><p>我们在字节跳动大街的N个建筑中选定3个埋伏地点。</p></li><li><p>为了相互照应，我们决定相距最远的两名特工间的距离不超过D。</p></li></ol><p>我特喵是个天才! 经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！</p><p>……</p><p>万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！</p><p>请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。</p><p>注意：</p><ol><li><p>两个特工不能埋伏在同一地点</p></li><li><p>三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用</p></li></ol><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code class="hljs mathematica">第一行包含空格分隔的两个数字 <span class="hljs-built_in">N</span>和<span class="hljs-built_in">D</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span> ≤ <span class="hljs-built_in">N</span> ≤ <span class="hljs-number">1000000</span><span class="hljs-operator">;</span> <span class="hljs-number">1</span> ≤ <span class="hljs-built_in">D</span> ≤ <span class="hljs-number">1000000</span><span class="hljs-punctuation">)</span>第二行包含<span class="hljs-built_in">N</span>个建筑物的的位置，每个位置用一个整数（取值区间为<span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-operator">,</span> <span class="hljs-number">1000000</span><span class="hljs-punctuation">]</span>）表示，从小到大排列（将字节跳动大街看做一条数轴）</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code class="hljs dns">一个数字，表示不同埋伏方案的数量。结果可能溢出，请对 <span class="hljs-number">99997867</span> 取模</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">4</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs gcode">可选方案 <span class="hljs-comment">(1, 2, 3)</span>, <span class="hljs-comment">(1, 2, 4)</span>, <span class="hljs-comment">(1, 3, 4)</span>, <span class="hljs-comment">(2, 3, 4)</span></code></pre><p>示例2</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">19</span><span class="hljs-symbol">1 </span><span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">30</span> <span class="hljs-number">50</span></code></pre><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><pre><code class="hljs">1</code></pre><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><pre><code class="hljs gcode">可选方案 <span class="hljs-comment">(1, 10, 20)</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先选一个数，然后从后开始遍历找到符合条件（num【j】-num【i】&lt;&#x3D;distance）的第一个数，然后从i+1到j里面选2个数字出来就可以，排列组合问题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a, n, dis,i,j,sum <span class="hljs-type">int</span>mod := <span class="hljs-number">99997867</span>fmt.Scan(&amp;n, &amp;dis)<span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span> &#123;fmt.Println(<span class="hljs-number">0</span>)&#125; <span class="hljs-keyword">else</span> &#123;num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;fmt.Scan(&amp;a)num[i] = a&#125;<span class="hljs-keyword">for</span> i ,j= <span class="hljs-number">0</span>, <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<span class="hljs-keyword">for</span> ;i&gt;=<span class="hljs-number">2</span>&amp;&amp;num[i]-num[j]&gt;dis;&#123;j++&#125;sum += ((i-j)*(i-j<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)&#125;&#125;sum %= modfmt.Println(sum)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：510ms, 超过77.73%用Go提交的代码<br>   占用内存：5636KB, 超过75.78%用Go提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MT1 最大差值</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/MT1%20%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/MT1%20%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="最大差值"><a href="#最大差值" class="headerlink" title="最大差值"></a><font size=6px>最大差值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有一个长为 n 的数组 A ，求满足 0 ≤ a ≤ b &lt; n 的 A[b] - A[a] 的最大值。</p><p>给定数组 A 及它的大小 n ，请返回最大差值。</p><p>数据范围： 2 &lt; n \le 2<em>10^5\2&lt;<em>n</em>≤2∗105 ，数组中的值满足 0 \le |val| \le 5</em>10^8 \0≤∣<em>v<strong>a</strong>l</em>∣≤5∗108 </p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入：</p><pre><code class="hljs angelscript"><span class="hljs-string">[5,1]</span>,<span class="hljs-number">2</span></code></pre><p>复制</p><p>返回值：</p><pre><code class="hljs">0</code></pre><p>复制</p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>输入：</p><pre><code class="hljs angelscript"><span class="hljs-string">[5,6]</span>,<span class="hljs-number">2</span></code></pre><p>复制</p><p>返回值：</p><pre><code class="hljs">1</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>模拟即可</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang">class Solution &#123;public:    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * @param A int整型vector </span><span class="hljs-comment">     * @param n int整型 </span><span class="hljs-comment">     * @return int整型</span><span class="hljs-comment">     */</span>    <span class="hljs-type">int</span> getDis(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> n) &#123;        <span class="hljs-comment">// write code here</span>        <span class="hljs-keyword">if</span> (A.size() &lt;n)&#123;            n = A.size();        &#125;        <span class="hljs-type">int</span> min = A[<span class="hljs-number">0</span>];        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n;i++)&#123;            <span class="hljs-keyword">if</span>(min &gt; A[i])&#123;                min = A[i];            &#125;            res = max(res, A[i]-min);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   运行时间：55ms,超过64.24% 用C++提交的代码<br>   占用内存：8060KB ,超过33.24%用C++提交的代码</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动2017客户端工程师实习生笔试题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82017%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82017%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="4、或与加"><a href="#4、或与加" class="headerlink" title="4、或与加"></a><font size=6px>4、或与加</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定 x, k ，求满足 x + y &#x3D; x | y 的第 k 小的正整数 y 。 | 是二进制的或(or)运算，例如 3 | 5 &#x3D; 7。</p><p>比如当 x&#x3D;5，k&#x3D;1时返回 2，因为5+1&#x3D;6 不等于 5|1&#x3D;5，而 5+2&#x3D;7 等于 5 | 2 &#x3D; 7。</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><pre><code class="hljs llvm">每组测试用例仅包含一组数据，每组数据为两个正整数 <span class="hljs-keyword">x</span> <span class="hljs-punctuation">,</span> k。 满足 <span class="hljs-number">0</span> &lt; <span class="hljs-keyword">x</span> <span class="hljs-punctuation">,</span> k ≤ <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">000</span><span class="hljs-punctuation">,</span><span class="hljs-number">000</span><span class="hljs-punctuation">,</span><span class="hljs-number">000</span>。</code></pre><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><pre><code class="hljs">输出一个数y。</code></pre><h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">1</span></code></pre><h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><pre><code class="hljs">2</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>x+y&#x3D;x|y </p><p>  这里可以推出一个结论，x&amp;y&#x3D;0。也就是说，在二进制上看，x取1的地方，y必定不能取1。从最低位考虑，若x与y在某一位上同时取1，则x+y在该位上为0，x|y在该位上为1，前面说这是最低一位x  y同时取1，也就是说没有更低位加法的进位，所以这里两个结果不相等，出现了矛盾。 </p><p>  例子： </p><p>  x &#x3D; 001010 </p><p>  y &#x3D; 110110 </p><p>  x + y &#x3D;  1000000 </p><p>  x | y &#x3D; 111110 </p><p>  偏差产生的原因是倒数第二位，x+y&#x3D;0 x|y&#x3D;1 且倒数第一位加法没有进位 </p><p>  结论：<strong>x在二进制取1的位上，y不能做出改变，只能取0</strong></p><p>  —-方法—-</p><p>  有了上述结论，可以进一步推出只要在x取0的地方，y可以做出改变</p><p>  例如</p><p>  x &#x3D; 10010010011</p><p>  y &#x3D; 00000000(0)00  k &#x3D; 0</p><p>  y &#x3D; 00000000(1)00  k &#x3D; 1</p><p>  y &#x3D; 0000000(1)(0)00 k &#x3D; 2</p><p>  y &#x3D; 0000000(1)(1)00 k &#x3D; 3</p><p>  y &#x3D; 00000(1)0(0)(0)00 k &#x3D; 4</p><p>  y &#x3D; 00000(1)0(0)(1)00 k &#x3D; 5</p><p>  …</p><p>  注意观察括号里的数，为x取0的比特位，而如果把括号里的数连起来看，正好等于k。</p><p>  得出结论，<strong>把k表示成二进制数，填入x取0的比特位，x取1的比特位保持为0，得到y</strong>。 </p><p>  —代码说明—</p><p>  思路有了，接着就是代码，显然用位操作是最合适的方式。 </p><p>  循环的思想是每次取得k的最低一位，填入到低位开始，x中比特位为0的位置上。 </p><p>  所以用while来判断k是否大于0，若是，说明k还未完全填完 </p><p>  循环体内，需要找到x当前可以填的位置，我们用bitNum来从右往左扫描x的每一位 </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"></code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CI/CD介绍</title>
    <link href="/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/CI:CD%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/CI:CD%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>持续集成，持续交付和持续部署是人们谈论现代开发实践时常提到的几个概念，三者究竟是什么，又有何联系和区别呢？我们翻译了以下这篇文章来探讨这些问题。</p><p>第一次开始学习持续集成和持续交付的时候，想必很多人都多多少少有一些疑惑。别着急，在理解这些术语之前，我们首先需要知道一个概念———<strong>流水线</strong>（pipeline）。</p><blockquote><p>在软件开发领域，流水线就是一系列流程的序列，例如按照顺序一个接着一个执行的过程或者指令。有的时候，上一步的输出即是下一步的输入。</p></blockquote><p>在详述每个连续性流程的细节之前，我们可以先来看一看组成流水线的步骤：</p><p>首先，将在本地进行的代码更改提交并推送到中央仓库中；接下来，通过一个自动系统将其检出，该系统将项目构建为我们的浏览器可以理解的代码段；然后针对代码进行测试以确保我们的更改没有任何中断，最后部署到用户可以使用的最终环境。</p><p>这些步骤实质上构成了持续集成&#x2F;持续部署的核心，并且一起构成了软件开发的流程。既然已经知道了流水线是什么，我们接下来谈谈本文的重点。</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a><strong>持续集成</strong></h2><p>顾名思义，<strong>持续集成</strong>（Continuous integration，简称 CI）是指每次对代码库进行更改时都运行集成测试。每当提交更改并将其推送到代码仓库时，持续集成系统都会重建分支，并运行所有相关的测试用例，以验证新更改不会破坏现有应用程序的运行。然而要实施持续集成，必须满足一些先决条件。</p><p><strong>条件是什么</strong></p><p>为了使应用程序做好持续集成的准备，需要事先采取一些措施。最显而易见的是如果没有构建系统或测试要运行，则无法构建和测试应用程序。尽管看起来可能要花费额外的精力（特别是在代码没有进行过任何测试的情况下），持续集成可以带来很多好处。例如，自动化单元和集成测试能够在 bug 进入生产环境之前就捕获它们，这样一来更少的 bug 会被交付到生产中。事实上，防止一个潜在 bug 进入生产阶段的有效措施就是用一个测试用例覆盖它们，以确保它们不会导致产品回滚。除此之外，由于持续集成可以在短短几分钟内运行数百个测试用例，花费在手动测试上的时间也将大大减少，这意味着测试人员可以专注于更重要的改进而不是耗费大量精力在反复测试现有功能上。</p><p>为了进一步开发和拓展持续集成机制以实现更高的自动化程度，我们引进了持续交付这一理念。</p><h2 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h2><p><strong>持续交付</strong>（Continuous delivery，简称 CD）是持续集成的扩展。从本质上讲，这意味着每次代码更改通过测试时都要对其进行重新部署。这不仅自动化了构建和测试阶段，而且还自动化了大部分发布过程，运维人员只要点一下按钮就可以部署应用程序。</p><p>和持续集成相比，持续交付的好处是什么？</p><p>有了持续交付，由于在构建和测试应用程序后大部分步骤已经自动化，部署的复杂性得以降低。开发团队可以加快迭代速度并部署更小的更改，从而减少引入生产 bug 的可能性。通过持续交付，我们可以更轻松地定位 bug并将其修复。</p><h2 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h2><p>持续交付是持续集成的扩展，而部署则建立在交付之上。与持续交付相比，<strong>持续部署</strong>（Continuous deployment，简称 CD）更进一步，因为它可以自动将代码更改部署到生产中而无需人工干预。这也意味着为了避免出现回滚和其他问题，您的测试包必须是一流的，因为它决定了您的发布过程。</p><p>在持续交付的基础上，项目团队将获取更快的部署速度，因为每项更改都可以进行自动处理，代码合并后几分钟就能够在生产环境中看到本地开发的功能；另一方面，代码发布的风险也能够进一步降低，因为您应该尽可能进行小批量部署，这样的话在出现任何问题时更容易排除故障。通过所有这些连续性环节，最终用户将体验到应用程序中的持续改进，而不是时不时看到重大版本的变化。</p><p>最后，为了可视化整个过程以及这三个概念之间的核心区别，以下这张流程图可以加深您的印象。</p><p><img src="https://pic4.zhimg.com/80/v2-cf2cd577a31d628709abcd4b9d5376c3_1440w.jpg" alt="img"></p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/103554905">https://zhuanlan.zhihu.com/p/103554905</a></p>]]></content>
    
    
    <categories>
      
      <category>自动化博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac自动push</title>
    <link href="/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/mac%E8%87%AA%E5%8A%A8push/"/>
    <url>/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/mac%E8%87%AA%E5%8A%A8push/</url>
    
    <content type="html"><![CDATA[<h3 id="1、编写脚本"><a href="#1、编写脚本" class="headerlink" title="1、编写脚本"></a>1、编写脚本</h3><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> upload.<span class="hljs-keyword">sh</span></code></pre><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">plist</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="hljs-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>upload.github.code.plist<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>ProgramArguments<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>/Users/jie/Desktop/myblog/upload.sh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span> //脚本位置<span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>StartCalendarInterval<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>Minute<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">integer</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">integer</span>&gt;</span>   //每天18点执行一次        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>Hour<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">integer</span>&gt;</span>18<span class="hljs-tag">&lt;/<span class="hljs-name">integer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>KeepAlive<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">false</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>RunAtLoad<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span></code></pre><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">cd</span> /Users/jie/Desktop/mybloggit add .git commit -m <span class="hljs-string">&quot;update&quot;</span>git push</code></pre><p>给权限</p><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">755</span> upload.sh</code></pre><h3 id="2、建立plist"><a href="#2、建立plist" class="headerlink" title="2、建立plist"></a>2、建立plist</h3><pre><code class="hljs awk">cd <span class="hljs-regexp">/Library/</span>LaunchDaemons/sudo vim upload.github.code.plist</code></pre><pre><code class="hljs stylus">plutil -lint upload<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.code</span><span class="hljs-selector-class">.plist</span> 检查是否编写错误chmod <span class="hljs-number">600</span> upload<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.code</span><span class="hljs-selector-class">.plist</span>  给权限sudo launchctl load upload<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.code</span><span class="hljs-selector-class">.plist</span> 加载脚本sudo launchctl start upload<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.code</span><span class="hljs-selector-class">.plist</span> 开始脚本</code></pre>]]></content>
    
    
    <categories>
      
      <category>自动化博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈git的使用</title>
    <link href="/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%B5%85%E8%B0%88git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%B5%85%E8%B0%88git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="观前提醒：我写这个主要是来巩固我学的git操作"><a href="#观前提醒：我写这个主要是来巩固我学的git操作" class="headerlink" title="观前提醒：我写这个主要是来巩固我学的git操作"></a><p class="note note-primary">观前提醒：我写这个主要是来巩固我学的git操作</p></h2><p>在程序中#这个符号后面代表我的注释</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h4 id="0、先安装git，这里我引用别人的文章git安装"><a href="#0、先安装git，这里我引用别人的文章git安装" class="headerlink" title="0、先安装git，这里我引用别人的文章git安装"></a>0、先安装git，这里我引用别人的文章<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">git安装</a></h4><h4 id="1、创建一个文件夹，创建一个readme-txt文件，里面写入hello-git文字（这个之后会用到）"><a href="#1、创建一个文件夹，创建一个readme-txt文件，里面写入hello-git文字（这个之后会用到）" class="headerlink" title="1、创建一个文件夹，创建一个readme.txt文件，里面写入hello git文字（这个之后会用到）"></a>1、创建一个文件夹，创建一个readme.txt文件，里面写入hello git文字（这个之后会用到）</h4><h4 id="2、在文件夹中右键，会有一个Git-Bosh-Here，点这个"><a href="#2、在文件夹中右键，会有一个Git-Bosh-Here，点这个" class="headerlink" title="2、在文件夹中右键，会有一个Git Bosh Here，点这个"></a>2、在文件夹中右键，会有一个Git Bosh Here，点这个</h4><p><img src="/img/gitbosh.png"></p><h4 id="3、配置环境，输入提交人的名字和邮箱"><a href="#3、配置环境，输入提交人的名字和邮箱" class="headerlink" title="3、配置环境，输入提交人的名字和邮箱"></a>3、配置环境，输入提交人的名字和邮箱</h4><pre><code class="hljs stylus"><span class="hljs-variable">$git</span> config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;输入你的名字&quot;</span><span class="hljs-variable">$git</span> config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;输入你的邮箱&quot;</span><span class="hljs-variable">$git</span> config <span class="hljs-attr">--global</span> -l  #查看仓库配置，用来查看你是否配置成功</code></pre><h4 id="4-建立仓库"><a href="#4-建立仓库" class="headerlink" title="4.建立仓库"></a>4.建立仓库</h4><pre><code class="hljs autoit">$git init     <span class="hljs-meta">#会给你创建一个.git隐藏文件，用来存放你的操作记录，注意在你的路径里面最好不要有中文</span></code></pre><h2 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h2><p>创建好文件夹和txt文件之后，在git里面输入</p><pre><code class="hljs autoit">$git status <span class="hljs-meta">#查看现在的仓库状态</span></code></pre><p>会出现这样的语句</p><pre><code class="hljs smali">Untracked files:  <span class="hljs-comment">#有个未被跟踪的readme.txt文件</span>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include in what will be committed)        readme .txtno changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span><span class="hljs-built_in"> and/or </span><span class="hljs-string">&quot;git commit -a&quot;</span>)</code></pre><p>然后添加文件</p><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> readme.txt</code></pre><p>如果提交了没提示那就是提交正确了，输入了命令什么都没提示就是最好的提示。</p><p>最后提交文件</p><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m&quot;写你提交了什么东西，方便回溯的时候看回溯到哪个版本&quot;  #可以<span class="hljs-keyword">add</span>多个文件一起<span class="hljs-keyword">commit</span></code></pre><p>现在再输入git status会显示</p><pre><code class="hljs pgsql">$ git status<span class="hljs-keyword">On</span> branch dev<span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean #没有东西可以提交</code></pre><p>用 git log命令能知道提交人的id和提交日期</p><pre><code class="hljs llvm">$ git logcommit <span class="hljs-number">507671</span>f<span class="hljs-number">473</span>bbbfa<span class="hljs-number">18</span>ec<span class="hljs-number">0</span><span class="hljs-keyword">c</span><span class="hljs-number">2</span>de<span class="hljs-number">9</span>ed<span class="hljs-number">80</span><span class="hljs-keyword">c</span><span class="hljs-number">27</span><span class="hljs-keyword">cc</span><span class="hljs-number">483</span>b<span class="hljs-number">53</span>Author: jess-weigou &lt;<span class="hljs-number">895006375</span><span class="hljs-title">@qq.com</span>&gt;Date:   Fri Nov <span class="hljs-number">13</span> <span class="hljs-number">00</span>:<span class="hljs-number">10</span>:<span class="hljs-number">45</span> <span class="hljs-number">2020</span> +<span class="hljs-number">0800</span>wrote a readme.file</code></pre><p>用 git show命令能知道最近一个人的提交id，id后面回溯的时候要用到</p><pre><code class="hljs sql">$ git <span class="hljs-keyword">show</span><span class="hljs-keyword">commit</span> <span class="hljs-number">20</span>b009be6781d2fe5df568f8bf859bdf7e489408 (HEAD <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> dev) #这一串字母就是                                                                    #<span class="hljs-keyword">commit</span> idAuthor: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Thu Nov <span class="hljs-number">26</span> <span class="hljs-number">09</span>:<span class="hljs-number">44</span>:<span class="hljs-number">19</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    write a readme.txt</code></pre><p>我们再在readme.txt文件中“hello git。”的基础上再添加“hello world”文字，并保存。</p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>  我们来讲git最有趣的回溯功能,先用git log功能看提交的记录和提交人的id,这里我提交了多次。</p><pre><code class="hljs sql">$ git log<span class="hljs-keyword">commit</span> <span class="hljs-number">80</span>ee417c0d4eb1803202b762dbabe747fa38d1f6 (HEAD <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> dev)Author: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Mon Nov <span class="hljs-number">30</span> <span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    <span class="hljs-keyword">add</span> hello world<span class="hljs-keyword">commit</span> <span class="hljs-number">3</span>bb0b8bfb6f2f9178d31a4d0cb372b3d87b461aeAuthor: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Sun Nov <span class="hljs-number">29</span> <span class="hljs-number">09</span>:<span class="hljs-number">46</span>:<span class="hljs-number">26</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    <span class="hljs-keyword">add</span> hello world<span class="hljs-keyword">commit</span> <span class="hljs-number">20</span>b009be6781d2fe5df568f8bf859bdf7e489408Author: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Thu Nov <span class="hljs-number">26</span> <span class="hljs-number">09</span>:<span class="hljs-number">44</span>:<span class="hljs-number">19</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    write a readme.txt<span class="hljs-keyword">commit</span> <span class="hljs-number">268</span>d66e08b1ebf50d9ddbf20096504592463051dAuthor: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Thu Nov <span class="hljs-number">26</span> <span class="hljs-number">09</span>:<span class="hljs-number">34</span>:<span class="hljs-number">36</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    write a readme.txt</code></pre><p>用git reset –hard “写提交的id”</p><pre><code class="hljs maxima">$ git <span class="hljs-built_in">reset</span> --hard <span class="hljs-number">20b009</span> #只要前几个字母id就可以匹配到你的提交idHEAD <span class="hljs-built_in">is</span> now <span class="hljs-built_in">at</span> 20b009b write a readme.txt</code></pre><p>这里说head指针已经指向20b009b,我们打开readme.txt，会发现写的“hello world”已经不见了。</p><p><strong>如果回退到以前的版本了还想回会到最新的版本，那咋办？</strong></p><p>找到之前git log的界面，就像我之前git log，那一条最新的日志记录</p><pre><code class="hljs sql">$ git log<span class="hljs-keyword">commit</span> <span class="hljs-number">80</span>ee417c0d4eb1803202b762dbabe747fa38d1f6 (HEAD <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> dev)Author: jess<span class="hljs-operator">-</span>weigou <span class="hljs-operator">&lt;</span><span class="hljs-number">895006375</span><span class="hljs-variable">@qq</span>.com<span class="hljs-operator">&gt;</span><span class="hljs-type">Date</span>:   Mon Nov <span class="hljs-number">30</span> <span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span> <span class="hljs-number">2020</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span>    <span class="hljs-keyword">add</span> hello world</code></pre><p>输入 git reset –hard “80ee417”就可以回退到之前的最新版本</p><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 80ee417c0</span>HEAD <span class="hljs-keyword">is</span> now at <span class="hljs-number">80</span>ee417 <span class="hljs-keyword">add</span> hello world</code></pre><p>你会发现hello world又出现了，所以别轻易清屏，清屏了也没关系，用git reflog查看历史命令</p><pre><code class="hljs pgsql">$ git reflog<span class="hljs-number">80</span>ee417 (HEAD -&gt; dev) HEAD@&#123;<span class="hljs-number">0</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">80</span>ee417c0<span class="hljs-number">20</span>b009b HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">20</span>b009<span class="hljs-number">80</span>ee417 (HEAD -&gt; dev) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> hello world<span class="hljs-number">3</span>bb0b8b HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> hello world<span class="hljs-number">20</span>b009b HEAD@&#123;<span class="hljs-number">4</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">write</span> a readme.txt<span class="hljs-number">268</span>d66e HEAD@&#123;<span class="hljs-number">5</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">write</span> a readme.txte845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">6</span>&#125;: checkout: moving <span class="hljs-keyword">from</span> master <span class="hljs-keyword">to</span> deve845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">7</span>&#125;: checkout: moving <span class="hljs-keyword">from</span> dev <span class="hljs-keyword">to</span> mastere845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">8</span>&#125;: checkout: moving <span class="hljs-keyword">from</span> master <span class="hljs-keyword">to</span> deve845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">9</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> e845<span class="hljs-number">507671</span>f HEAD@&#123;<span class="hljs-number">10</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> <span class="hljs-number">50767</span>e845d2b (github/master, master) HEAD@&#123;<span class="hljs-number">11</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> <span class="hljs-keyword">some</span> words<span class="hljs-number">507671</span>f HEAD@&#123;<span class="hljs-number">12</span>&#125;: <span class="hljs-keyword">commit</span> (initial): wrote a readme.file</code></pre>]]></content>
    
    
    <categories>
      
      <category>自动化博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>把hexo博客部署到windows服务器中</title>
    <link href="/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%8A%8A%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD/"/>
    <url>/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%8A%8A%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary"; style="font-size:22px">   前提需要：一个三个月以上时间的windows服务器，一个已经备案好的域名，已经会熟悉使用hexo，为了把hexo从github中部署到自己的服务器中。</p><h4 id="1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码"><a href="#1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码" class="headerlink" title="1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码"></a>1、搜索windows工具搜到远程桌面连接工具，用远程桌面连接连接到服务器，然后输入设置的账号密码</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0geh1147mj20d808y0te.jpg"></p><h4 id="2、把IE增强的安全配置给关了（安全就代表麻烦），win-gt-服务器管理器-gt-IE增强的安全配置：启动点进去然后关闭"><a href="#2、把IE增强的安全配置给关了（安全就代表麻烦），win-gt-服务器管理器-gt-IE增强的安全配置：启动点进去然后关闭" class="headerlink" title="2、把IE增强的安全配置给关了（安全就代表麻烦），win-&gt;服务器管理器-&gt;IE增强的安全配置：启动点进去然后关闭"></a>2、把IE增强的安全配置给关了（安全就代表麻烦），win-&gt;服务器管理器-&gt;IE增强的安全配置：启动点进去然后关闭</h4><h4 id="3、下载宝塔-选windows版本，点下载，用来集成配置服务器的好工具"><a href="#3、下载宝塔-选windows版本，点下载，用来集成配置服务器的好工具" class="headerlink" title="3、下载宝塔,选windows版本，点下载，用来集成配置服务器的好工具"></a>3、下载<a href="https://www.bt.cn/">宝塔</a>,选windows版本，点下载，用来集成配置服务器的好工具</h4><p>、<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0geo2ismyj20is0eiabx.jpg"></p><h4 id="4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以"><a href="#4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以" class="headerlink" title="4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以"></a>4、点击打开，登陆，创建一个宝塔账号，然后，进入，选Apach和Nginx套餐都可以</h4><h4 id="5、宝塔先放放，等下再绑定域名，现在先下载-git和node-（点击可获得安装包，可能不是最新版的也可以去官网下载"><a href="#5、宝塔先放放，等下再绑定域名，现在先下载-git和node-（点击可获得安装包，可能不是最新版的也可以去官网下载" class="headerlink" title="5、宝塔先放放，等下再绑定域名，现在先下载**git和node **（点击可获得安装包，可能不是最新版的也可以去官网下载"></a>5、宝塔先放放，等下再绑定域名，现在先下载**<a href="http://hkctfsys.com/Git-2.30.0.2-64-bit.exe">git</a><strong>和</strong><a href="http://hkctfsys.com/node-v15.10.0-x64.msi">node</a> **（点击可获得安装包，可能不是最新版的也可以去官网下载</h4><p>下载完之后安装，一直点next就行）</p><p>node下载安装有一个注意点是,到这一步要选Add To Path</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gelil50mj20dz0b1dh7.jpg"></p><h4 id="6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git-bosh"><a href="#6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git-bosh" class="headerlink" title="6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git bosh"></a>6、右键打开git，点击gitbosh安装hexo，创建一个hexo名字的或者任何名字的文件夹，进去，然后右击点git bosh</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gela2e7oj208a0a7mxd.jpg"></p><pre><code class="hljs undefined">npm install -g hexo-cli //如果没反应可以到cmd运行这个代码</code></pre><p>初始化hexo程序，如果有hexo 的人可以直接把hexo文件复制进去就可</p><pre><code class="hljs kotlin">hexo <span class="hljs-keyword">init</span></code></pre><p>然后输入</p><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span></code></pre><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span></code></pre><p>打开网页，输入<a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到hexo界面了，说明成功一大半了</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0geojqhh7j21800ouad9.jpg"></p><h4 id="7、下载和配置Nginx"><a href="#7、下载和配置Nginx" class="headerlink" title="7、下载和配置Nginx"></a>7、下载和配置Nginx</h4><p><a href="http://hkctfsys.com/nginx-1.16.1.zip">Nginx安装包</a>，下载了之后点击nginx-1.16.1-&gt;conf-&gt;nginx,这个文件用txt打开，然后把下放的root改成你hexo的public地方，其他不用改</p><pre><code class="hljs pgsql"><span class="hljs-keyword">server</span> &#123;        <span class="hljs-keyword">listen</span>       <span class="hljs-number">80</span>;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.<span class="hljs-keyword">access</span>.<span class="hljs-keyword">log</span>  main;        <span class="hljs-keyword">location</span> / &#123;            root   C:\Users\Administrator\Desktop\hexo\<span class="hljs-built_in">public</span>;            <span class="hljs-keyword">index</span>  <span class="hljs-keyword">index</span>.html <span class="hljs-keyword">index</span>.htm;        &#125;</code></pre><p>下面介绍为什么要下载nignx和为什么要把root 地址改成hexo的public文件夹，因为source文件夹中makedown文件执行hexo g被编译成html文件放在public文件夹中，并且把网站的根目录指向public文件夹，用Nginx反向代理使得人们可以访问我这个网站。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gene2lewj20m80dcjro.jpg"></p><h4 id="8、接下来让网站根目录指向public文件夹，打开宝塔软件-信息输入密码之后点保存，然后通过面板地址，http-f-x2F-hkctfsys-com-8990-x2F-OEsp376s（这是我的面板地址，在面板最上面找）"><a href="#8、接下来让网站根目录指向public文件夹，打开宝塔软件-信息输入密码之后点保存，然后通过面板地址，http-f-x2F-hkctfsys-com-8990-x2F-OEsp376s（这是我的面板地址，在面板最上面找）" class="headerlink" title="8、接下来让网站根目录指向public文件夹，打开宝塔软件,信息输入密码之后点保存，然后通过面板地址，http: f&#x2F;hkctfsys. com: 8990&#x2F;OEsp376s（这是我的面板地址，在面板最上面找）"></a>8、接下来让网站根目录指向public文件夹，打开宝塔软件,信息输入密码之后点保存，然后通过面板地址，http: f&#x2F;hkctfsys. com: 8990&#x2F;OEsp376s（这是我的面板地址，在面板最上面找）</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gekb9somj20jh0gmq4t.jpg"></p><p>然后点开网站-&gt;添加站点,把根目录指向hexo的public文件夹，大功告成啦</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gek24os0j216z0mxjth.jpg"></p><p>现在在浏览器里面输入你的域名，可以正常显示了</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gekr3d8lj21hc0szgt0.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>自动化博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器自动拉取push到github上面的代码</title>
    <link href="/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96push%E5%88%B0github%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E6%8B%89%E5%8F%96push%E5%88%B0github%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>d </p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019-8-19字节校招笔试</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/2019-8-19%E5%AD%97%E8%8A%82%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/2019-8-19%E5%AD%97%E8%8A%82%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1、上学闹钟"><a href="#1、上学闹钟" class="headerlink" title="1、上学闹钟"></a>1、<font size=6px>上学闹钟</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p> 题目从牛客网上找</p><p>小明定了n个闹钟，他只能在闹钟响起时出发去学校，每个闹钟时间分别为hi点mi分，小明家到学校要x分钟，学校上课时间a点b分 （0-24 小时，0-59分钟），求他最晚几点起 </p><blockquote><p>   输入：  </p><p>   3 &#x2F;&#x2F;定了几个闹钟<br> 5 0 &#x2F;&#x2F;第1个闹钟的小时数和分钟数<br> 6 0   &#x2F;&#x2F;第2个闹钟的小时数和分钟数<br> 7 0   &#x2F;&#x2F;第3个闹钟的小时数和分钟数<br> 59 &#x2F;&#x2F;到学校要多少分钟<br> 6 59   &#x2F;&#x2F;上课的小时数和分钟数  </p><p>   输出：  </p><p>   6 0 &#x2F;&#x2F;最晚的起床时间</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>可以把时间都换成分钟，然后从大到小排序，找到第一个能够到达的闹钟从而找到起床时间。</p><pre><code class="hljs pgsql">// 这是别的人ac代码struct <span class="hljs-type">Time</span>&#123;    <span class="hljs-type">int</span> h;    <span class="hljs-type">int</span> m;    friend <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">Time</span> a, <span class="hljs-type">TIme</span> b)&#123;        <span class="hljs-keyword">if</span>(a.h == b.h)&#123;            <span class="hljs-keyword">return</span> a.m &gt; b.m;        &#125;        <span class="hljs-keyword">return</span> a.h &gt; b.h;    &#125;&#125;<span class="hljs-type">int</span> main()&#123;<span class="hljs-type">int</span> n, x, a, b, rest;cin &gt;&gt; n;<span class="hljs-type">Time</span>* <span class="hljs-type">time</span> = (<span class="hljs-type">Time</span>*)malloc(n * sizeof(<span class="hljs-type">Time</span>));<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;cin &gt;&gt; <span class="hljs-type">time</span>[i].h &gt;&gt; <span class="hljs-type">time</span>[i].m;&#125;sort(<span class="hljs-type">time</span>, <span class="hljs-type">time</span> + n);cin &gt;&gt; x;cin &gt;&gt; a &gt;&gt; b;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;rest = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (<span class="hljs-type">time</span>[i].h &lt; a || <span class="hljs-type">time</span>[i].h == a &amp;&amp; <span class="hljs-type">time</span>[i].m &lt; b)&#123;rest = (a - <span class="hljs-type">time</span>[i].h) * <span class="hljs-number">60</span> + b - <span class="hljs-type">time</span>[i].m;<span class="hljs-keyword">if</span> (rest &gt;= x)&#123;cout &lt;&lt; <span class="hljs-type">time</span>[i].h &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-type">time</span>[i].m &lt;&lt; endl;break;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="2-加密通信-O-n"><a href="#2-加密通信-O-n" class="headerlink" title="2. 加密通信 O(n)"></a>2. 加密通信 O(n)</h2><p>小明和小红采用密码加密通信，每次通信有固定的明文长度n和加密次数k。 </p><p>  比如：密码二进制明文是1001010，加密次数是4，则每次将密文右移1位与明文做异或操作 ，总共位移3次（k&#x3D;4, 所以 k - 1 &#x3D; 3） </p><blockquote><p>   输入：  </p><p>   7 4 &#x2F;&#x2F; n k<br>   1110100110 &#x2F;&#x2F;密文  </p><p>   输出：<br>   1001010 &#x2F;&#x2F;明文  </p><p>   解释：  </p><p>   1001010—<br>   -1001010–<br>   –1001010-<br>   —1001010<br>   加密次数为4，故对于明文右移4-1&#x3D;3轮，每轮与当前密文进行一次异或，故  1001010对应密文为  1110100110</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>前置知识：异或的数字异或一次就会变成原数字，举例，101 和011 异或成110，110和011 异或之后变成原来数字101。</p><p>首先密文和明文 <strong>第1位是一样的</strong>，看一下上方样例里的解释就懂了。 </p><p>  然后考虑 <strong>第2到k-1位</strong>，可以发现这一段的每一位都是由 <strong>前一位密文的</strong> <strong>异或</strong> <strong>结果</strong> <strong>再</strong> <strong>与当前位明文异或</strong>得到的。 </p><p>  接下来考虑 <strong>第k到n-1位</strong>，观察规律可以发现这一段的每一位都是由 <strong>前一位密文与第i-k位明文异或得到的结果再与当前位明文异或</strong>得到的。 </p><p>  如何消除异或影响大家应该都能理解，因此只要把参与异或的部分再与密文异或一下即可得到明文。</p><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<span class="hljs-built_in">int</span> n, k, tmp;<span class="hljs-built_in">string</span> s,ans=<span class="hljs-string">&quot;&quot;</span>;cin &gt;&gt; n &gt;&gt; k;cin &gt;&gt; s;ans += s[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; k; i++)&#123;tmp = (<span class="hljs-built_in">int</span>)(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) ^ (<span class="hljs-built_in">int</span>)(s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>);ans += tmp + <span class="hljs-string">&#x27;0&#x27;</span>;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = k; i &lt; n; i++)&#123;ans += (<span class="hljs-built_in">int</span>)(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) ^ (<span class="hljs-built_in">int</span>)(s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) ^ (<span class="hljs-built_in">int</span>)(ans[i - k] - <span class="hljs-string">&#x27;0&#x27;</span>) + <span class="hljs-string">&#x27;0&#x27;</span>;&#125;cout &lt;&lt; ans;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="3-发工资O-n-x2F-O-nlogn"><a href="#3-发工资O-n-x2F-O-nlogn" class="headerlink" title="3.发工资O(n)&#x2F;O(nlogn)"></a>3.发工资O(n)&#x2F;O(nlogn)</h2><p>王大锤要给员工发工资，员工从左到右坐成一排，每个员工知道彼此的资历，每个员工只知道自己左右员工的工资，如果某员工比左边或右边的人资历老，那他一定比这个人工资高100元，每个人最低工资100元，求王大锤最低给多少工资。 </p><blockquote><p>   样例  </p><p>   输入：  </p><p>   4 &#x2F;&#x2F;几个员工<br> 3 9 2 7 &#x2F;&#x2F;员工顺序以及对应的资历  </p><p>   输出：<br> 600 &#x2F;&#x2F;100  元，20  0元，100元，200元</p><p> 6<br> 1 2 3 4 5 6<br> 2100 &#x2F;&#x2F;100，200，300，400，500，600</p><p> 5<br> 1 1 1 1 1  </p><p>   500 &#x2F;&#x2F;100，100，100，100，100  </p><p> 8<br> 1 2 3 4 3 2 3 4  </p><p>   1800 &#x2F;&#x2F;100 200 300 400 200 100 200 300<br> 8<br> 3 4 3 4 3 4 3 4  </p><p>   1200 &#x2F;&#x2F;100 200 100 200 100 200 100 200<br> 5<br> 1 2 3 4 1   </p><p>   1100 &#x2F;&#x2F;100 200 300 400 500</p></blockquote><h4 id="思路1-（时间复杂度为o（n））"><a href="#思路1-（时间复杂度为o（n））" class="headerlink" title="思路1 （时间复杂度为o（n））"></a>思路1 （时间复杂度为o（n））</h4><p><strong>广度优先搜索</strong>，可以把员工序列看作一棵 <strong>多根树</strong>，每个 <strong>工资最低的员工就是根节点</strong>，一个员工的工资其实就是他在 <strong>多根树里的深度</strong>， </p><p>  首先在输入的时候找到比左右资历都年轻的员工入队，每次从队列pop一个员工，然后判断该员工的最小工资，然后判断左右员工是否可以入队，直到所有员工出队</p><pre><code class="hljs excel"><span class="hljs-built_in">int</span> main() &#123;<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, <span class="hljs-built_in">now</span>;long long ans = <span class="hljs-number">0</span>;cin &gt;&gt; <span class="hljs-built_in">n</span>;<span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> == <span class="hljs-number">0</span>)&#123;cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;return <span class="hljs-number">0</span>;&#125;vector&lt;<span class="hljs-built_in">int</span>&gt; epy(<span class="hljs-built_in">n</span>, <span class="hljs-number">0</span>), depth(<span class="hljs-built_in">n</span>, <span class="hljs-number">0</span>);queue&lt;<span class="hljs-built_in">int</span>&gt; sal;for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++)&#123;cin &gt;&gt; epy[i];<span class="hljs-built_in">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; epy[i - <span class="hljs-number">1</span>] &lt;= epy[i - <span class="hljs-number">2</span>] &amp;&amp; epy[i - <span class="hljs-number">1</span>] &lt;= epy[i])&#123;depth[i - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;sal.push(i - <span class="hljs-number">1</span>);&#125;&#125;<span class="hljs-built_in">if</span> (epy[<span class="hljs-number">0</span>] &lt;= epy[<span class="hljs-number">1</span>])&#123;depth[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;sal.push(<span class="hljs-number">0</span>);&#125;<span class="hljs-built_in">if</span> (epy[<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>] &lt;= epy[<span class="hljs-built_in">n</span> - <span class="hljs-number">2</span>])&#123;depth[<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;sal.push(<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>);&#125;while (!sal.empty())&#123;<span class="hljs-built_in">now</span> = sal.front();<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = (<span class="hljs-built_in">now</span> &gt; <span class="hljs-number">0</span> &amp;&amp; epy[<span class="hljs-built_in">now</span>-<span class="hljs-number">1</span>] &lt; epy[<span class="hljs-built_in">now</span>]) ? depth[<span class="hljs-built_in">now</span> - <span class="hljs-number">1</span>] <span class="hljs-symbol">:</span> <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = (<span class="hljs-built_in">now</span> &lt; <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span> &amp;&amp; epy[<span class="hljs-built_in">now</span> + <span class="hljs-number">1</span>] &lt; epy[<span class="hljs-built_in">now</span>]) ? depth[<span class="hljs-built_in">now</span> + <span class="hljs-number">1</span>] <span class="hljs-symbol">:</span> <span class="hljs-number">0</span>;sal.pop();<span class="hljs-built_in">if</span> (depth[<span class="hljs-built_in">now</span>] == <span class="hljs-number">0</span>)&#123;depth[<span class="hljs-built_in">now</span>] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>) + <span class="hljs-number">1</span>;&#125;//<span class="hljs-built_in">left</span><span class="hljs-built_in">if</span> (<span class="hljs-built_in">now</span> &gt; <span class="hljs-number">0</span> &amp;&amp; depth[<span class="hljs-built_in">now</span> - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; (<span class="hljs-built_in">now</span> == <span class="hljs-number">1</span> || epy[<span class="hljs-built_in">now</span> - <span class="hljs-number">2</span>] &gt; epy[<span class="hljs-built_in">now</span> - <span class="hljs-number">1</span>] || depth[<span class="hljs-built_in">now</span> - <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>))&#123;sal.push(<span class="hljs-built_in">now</span> - <span class="hljs-number">1</span>);&#125;//<span class="hljs-built_in">right</span><span class="hljs-built_in">if</span> (<span class="hljs-built_in">now</span> &lt; <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span> &amp;&amp; (depth[<span class="hljs-built_in">now</span> + <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">now</span> == <span class="hljs-built_in">n</span> - <span class="hljs-number">2</span> || epy[<span class="hljs-built_in">now</span> + <span class="hljs-number">2</span>] &gt; epy[<span class="hljs-built_in">now</span> + <span class="hljs-number">1</span>] || depth[<span class="hljs-built_in">now</span> + <span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span>))&#123;sal.push(<span class="hljs-built_in">now</span> + <span class="hljs-number">1</span>);&#125;&#125;for (auto salary <span class="hljs-symbol">:</span> depth) &#123;ans += salary;&#125;cout &lt;&lt; ans * <span class="hljs-number">100</span> &lt;&lt; endl;&#125;</code></pre><h4 id="思考2-（时间复杂度olog（n））"><a href="#思考2-（时间复杂度olog（n））" class="headerlink" title="思考2 （时间复杂度olog（n））"></a>思考2 （时间复杂度olog（n））</h4><p>用贪心思路，先全部输入结构体内，然后按照分数大小排序，从最小的开始如果旁边有没有分数那就是100，如果有就比有分数最高的多100.</p>]]></content>
    
    
    <categories>
      
      <category>牛客刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/HashMap/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/HashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>定义：HashMap是我们常见的一种数据结构，实现Map接口，用来存储键值对,允许null键&#x2F;值、非同步、不保证有序(比如插入的顺序)。那HashMap中最核心的部分就是哈希函数，又称散列函数。也就是说，哈希函数是通过把key的hash值映射到数组中的一个位置来进行访问。</p><h4 id="初始容量"><a href="#初始容量" class="headerlink" title="初始容量"></a>初始容量</h4><p> static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1&lt;&lt;4;</p><h4 id="最大容量"><a href="#最大容量" class="headerlink" title="最大容量"></a>最大容量</h4><p> MAXIMUM_CAPACITY &#x3D; 1&lt;&lt;30;</p><h4 id="扩容条件"><a href="#扩容条件" class="headerlink" title="扩容条件"></a>扩容条件</h4><p>DEFAULT_LOAD_FACTOR &#x3D; 0.75f;  在容量3&#x2F;4时扩容</p><h3 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h3><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>) &#123;        <span class="hljs-type">int</span> h;        <span class="hljs-title function_">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);    &#125;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/16390890-8018e0b694b486d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/586/format/webp"></p><p>一个hashCode的前16位和他的后16为进行异或，将算出来的值和（n-1）&amp;一下就是要插入的槽位。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Synchronize</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/Synchronize/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/Synchronize/</url>
    
    <content type="html"><![CDATA[<p>悲观锁（Pessimistic Lock）：<br>每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。</p><p>乐观锁（Optimistic Lock）：<br>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。<br>由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。</p><p>悲观锁比较适合强一致性的场景，但效率比较低，特别是读的并发低。<br>乐观锁则适用于读多写少，并发冲突少的场景。</p><p>Synchronized：<br>Java在JDK1.5之前都是靠 synchronized关键字保证同步的。这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。这就是一种独占锁，独占锁其实就是一种悲观锁。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile怎么样才能最小</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/Dockerfile%E6%80%8E%E4%B9%88%E6%A0%B7%E6%89%8D%E8%83%BD%E6%9C%80%E5%B0%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/Dockerfile%E6%80%8E%E4%B9%88%E6%A0%B7%E6%89%8D%E8%83%BD%E6%9C%80%E5%B0%8F/</url>
    
    <content type="html"><![CDATA[<p>Dockerfile怎么样才能最小</p><p>1、每一层尽可能的多做事情，只有一层layer能够做到尽可能少的打包内容，但是管理成本很大，无法复用和使用本地cache</p><p>2、选择基础镜像的时候选的小一点</p><p>3、编译和运行分开，使用from来传输编译好的数据，使用rebuild</p><p>Dockerfile最下面那层添加代码，倒数第二层删除代码，有什么不好</p><p>1、每次打包docker时,都会使用资源打包无意义的东西</p><p>2、打包会导致源代码泄漏，造成很严重的安全事故</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s service</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20service/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20service/</url>
    
    <content type="html"><![CDATA[<h3 id="service的负载均衡机制"><a href="#service的负载均衡机制" class="headerlink" title="service的负载均衡机制"></a>service的负载均衡机制</h3><p>从服务ip到后端pod的负载均衡机制，是由每个node上面的kube-proxy实现的</p><h4 id="kube-proxy-代理模式"><a href="#kube-proxy-代理模式" class="headerlink" title="kube-proxy 代理模式"></a>kube-proxy 代理模式</h4><h5 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h5><p>这种模式，<code>kube-proxy</code> 会监视 Kubernetes 控制节点对 Service 对象和 Endpoints 对象的添加和移除。 对每个 Service，它会配置 iptables 规则，从而捕获到达该 Service 的 <code>clusterIP</code> 和端口的请求，进而将请求重定向到 Service 的一组后端中的某个 Pod 上面。 对于每个 Endpoints 对象，它也会配置 iptables 规则，这个规则会选择一个后端组合。</p><p>默认的策略是，kube-proxy 在 iptables 模式下随机选择一个后端。</p><p>使用 iptables 处理流量具有较低的系统开销，因为流量由 Linux netfilter 处理， 而无需在用户空间和内核空间之间切换。 这种方法也可能更可靠。</p><p>如果 kube-proxy 在 iptables 模式下运行，并且所选的第一个 Pod 没有响应，则连接失败。 这与用户空间模式不同：在这种情况下，kube-proxy 将检测到与第一个 Pod 的连接已失败， 并会自动使用其他后端 Pod 重试。</p><p>你可以使用 Pod <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes">就绪探测器</a> 验证后端 Pod 可以正常工作，以便 iptables 模式下的 kube-proxy 仅看到测试正常的后端。 这样做意味着你避免将流量通过 kube-proxy 发送到已知已失败的 Pod。</p><p><img src="https://d33wubrfki0l68.cloudfront.net/27b2978647a8d7bdc2a96b213f0c0d3242ef9ce0/e8c9b/images/docs/services-iptables-overview.svg" alt="iptables 代理模式下 Service 概览图"></p><h3 id="IPVS-代理模式"><a href="#IPVS-代理模式" class="headerlink" title="IPVS 代理模式"></a>IPVS 代理模式</h3><p><strong>特性状态：</strong> <code>Kubernetes v1.11 [stable]</code></p><p>在 <code>ipvs</code> 模式下，kube-proxy 监视 Kubernetes 服务和端点，调用 <code>netlink</code> 接口相应地创建 IPVS 规则， 并定期将 IPVS 规则与 Kubernetes 服务和端点同步。该控制循环可确保 IPVS 状态与所需状态匹配。访问服务时，IPVS 将流量定向到后端 Pod 之一。</p><p>IPVS 代理模式基于类似于 iptables 模式的 netfilter 挂钩函数， 但是使用哈希表作为基础数据结构，并且在内核空间中工作。 这意味着，与 iptables 模式下的 kube-proxy 相比，IPVS 模式下的 kube-proxy 重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。 与其他代理模式相比，IPVS 模式还支持更高的网络流量吞吐量。</p><p>IPVS 提供了更多选项来平衡后端 Pod 的流量。这些是：</p><ul><li><code>rr</code>：轮替（Round-Robin）</li><li><code>lc</code>：最少链接（Least Connection），即打开链接数量最少者优先</li><li><code>dh</code>：目标地址哈希（Destination Hashing）</li><li><code>sh</code>：源地址哈希（Source Hashing）</li><li><code>sed</code>：最短预期延迟（Shortest Expected Delay）</li><li><code>nq</code>：从不排队（Never Queue）</li></ul><h5 id="ipvs"><a href="#ipvs" class="headerlink" title="ipvs"></a>ipvs</h5><p>服务发现：</p><p>通过DNS来做</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker组成</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/docker%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/docker%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h2 id="docker基础组成"><a href="#docker基础组成" class="headerlink" title="docker基础组成"></a>docker基础组成</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59qurl3dsj21ao0p3gpe.jpg"></p><p>命名空间（Namespaces） 、控制组（Control Groups）和联合文件系统（Union File System）为底层提供的实现，Docker将其封装，开发者并不直接操作。在Docker中，另外提供出了一些软件层面的概念，是操作Docker所针对的对象。</p><p>它们分别是：<strong>镜像（Image</strong>）、<strong>容器</strong>（<strong>Container</strong>）、<strong>网络</strong>（<strong>Network</strong>）、<strong>数据卷</strong>（<strong>Volume</strong>）。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59qwhlezwj20zk0dm74h.jpg"></p><h3 id="docker和vm的区别"><a href="#docker和vm的区别" class="headerlink" title="docker和vm的区别"></a>docker和vm的区别</h3><p>VM是一个运行在宿主机之上的完整的操作系统，VM运行自身操作系统会占用较多的CPU、内存、硬盘资源。Docker不同于VM，只包含应用程序以及依赖库，基于libcontainer运行在宿主机上，并处于一个隔离的环境中，这使得Docker更加轻量高效，启动容器只需几秒钟之内完成。由于Docker轻量、资源占用少，使得Docker可以轻易的应用到构建标准化的应用中。但Docker目前还不够完善，比如隔离效果不如VM，共享宿主机操作系统的一些基础库等；网络配置功能相对简单，主要以桥接方式为主；查看日志也不够方便灵活。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h59quy8wlvj21c80u0afi.jpg"></p><h3 id="Docker-容器有几种在状态？"><a href="#Docker-容器有几种在状态？" class="headerlink" title="Docker 容器有几种在状态？"></a>Docker 容器有几种在状态？</h3><ul><li>starting 运行状态</li><li>Exited 退出状态</li><li>Paused 暂停状态</li><li>healthy 健康状态</li><li>unhealthy 非健康状态</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>taint 和 Toleration</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20taint/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20taint/</url>
    
    <content type="html"><![CDATA[<h3 id="taint类型"><a href="#taint类型" class="headerlink" title="taint类型"></a>taint类型</h3><ul><li>NoSchedule：不能容忍此污点的 Pod 不会被调度到节点上；现有 Pod 不会从节点中逐出。</li><li>PreferNoSchedule：Kubernetes 会避免将不能容忍此污点的 Pod 安排到节点上。</li><li>NoExecute：如果 Pod 已在节点上运行，则会将该 Pod 从节点中逐出；如果尚未在节点上运行，则不会将其安排到节点上。</li></ul><h4 id="容忍度（Toleration）"><a href="#容忍度（Toleration）" class="headerlink" title="容忍度（Toleration）"></a>容忍度（Toleration）</h4><pre><code class="hljs dts"><span class="hljs-symbol">tolerations:</span>- key: <span class="hljs-string">&quot;key1&quot;</span><span class="hljs-symbol">  operator:</span> <span class="hljs-string">&quot;Equal&quot;</span><span class="hljs-symbol">  value:</span> <span class="hljs-string">&quot;value1&quot;</span><span class="hljs-symbol">  effect:</span> <span class="hljs-string">&quot;NoSchedule&quot;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s网络</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h50depznptj20s50e13zh.jpg"></p><p>docker使用网桥模式，通过虚拟化出网卡来，不同容器之间通信是通过docker0网桥转发。</p><p>每个容器里面都有个etho，然后docker0有个对应的veth。</p><h4 id="k8s不同node是怎么进行通信的"><a href="#k8s不同node是怎么进行通信的" class="headerlink" title="k8s不同node是怎么进行通信的"></a>k8s不同node是怎么进行通信的</h4><p>k8s不同node通信也是和</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s 探针</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20%E6%8E%A2%E6%B4%BB%E6%8C%87%E9%92%88/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/k8s%20%E6%8E%A2%E6%B4%BB%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="探针的三种机制"><a href="#探针的三种机制" class="headerlink" title="探针的三种机制"></a>探针的三种机制</h3><p>HTTP GET：该类型的探针对容器的ip地址和执行HTTP GET请求，如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。<br>TCP套接字：该类型的探针尝试与容器指定端口建立TCP连接，如果端口打开，则诊断被认为是成功的。<br>Exec：该类型的探针在容器内执行任意的命令，如果命令退出时返回码为 0 则认为诊断成功<br>每次探测都将获得以下三种结果之一：</p><p>Success（成功）：容器通过了诊断。<br>Failure（失败）：容器未通过诊断。<br>Unknown（未知）：诊断失败，因此不会采取任何行动。</p><h3 id="探针的三种类型"><a href="#探针的三种类型" class="headerlink" title="探针的三种类型"></a>探针的三种类型</h3><p>存活指针，就绪指针，启动指针</p><h3 id="liveness（存活指针）"><a href="#liveness（存活指针）" class="headerlink" title="liveness（存活指针）"></a>liveness（存活指针）</h3><p>存活指针,该指针用来指示容器是否正在运行。kubernetes根据存活指针来检查容器是否正常运行，若探测失败，则 kubelet 会杀死容器， 并且容器将根据其重启策略去处理。</p><h3 id="Readiness（就绪指针）"><a href="#Readiness（就绪指针）" class="headerlink" title="Readiness（就绪指针）"></a>Readiness（就绪指针）</h3><p>该指针用来指示容器是否准备好为请求提供服务。如果就绪态探测失败，kubelet将该Pod提供的所有服务的endpoint列表中删除该Pod的 IP地址。<br>Kubernetes根据就绪指针来检测pod中的容器是否已经就绪，在发布应用时很有必要在pod中添加该指针，K8s会根据pod是否就绪决定是否将该pod放入该服务中，从而保证服务集群中的pod都是可以提供服务的。</p><p>与存活指针的区别在于，若容器未通过检查准备，则不会被终止或重新启动。存活探针通过杀死异常的容器并用新的容器去替代他们的工作，而就绪探针确保只有准备好处理请求的pod才能在服务集群中。</p><h3 id="启动指针"><a href="#启动指针" class="headerlink" title="启动指针"></a>启动指针</h3><p>该指针用来指示容器中的应用是否已经启动，如果使用了启动探针，则所有其他探针都会被禁用，直到此探针成功为止。如果启动探测失败，kubelet将杀死容器，而容器依其重启策略进行重启。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>master节点有什么组件</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/master%E8%8A%82%E7%82%B9%E6%9C%89%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/master%E8%8A%82%E7%82%B9%E6%9C%89%E4%BB%80%E4%B9%88%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="master节点有什么组件"><a href="#master节点有什么组件" class="headerlink" title="master节点有什么组件"></a>master节点有什么组件</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4s6dbhvbgj20ru0k7myt.jpg"></p><p><strong>api server：</strong>负责对外提供restful的Kubernetes API服务，提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制。我们操作kubectl 和其他Master组件都通过调用api server提供的rest接口实现各自的功能，如controller就是通过api server来实时监控各个资源的状态的。</p><p><strong>etcd：</strong>是 Kubernetes 提供的一个高可用的键值数据库，用于保存集群所有的网络配置和资源对象的状态信息，也就是保存了整个集群的状态。数据变更都是通过api server进行的。整个kubernetes系统中一共有两个服务需要用到etcd用来协同和存储配置，分别是：<br>1）网络插件flannel，其它网络插件也需要用到etcd存储网络的配置信息；<br>2）kubernetes本身，包括各种资源对象的状态和元信息配置。</p><p><strong>scheduler：</strong>监听新建pod副本信息，并通过调度算法为该pod选择一个最合适的Node节点。会检索到所有符合该pod要求的Node节点，执行pod调度逻辑。调度成功之后，会将pod信息绑定到目标节点上，同时将信息写入到etcd中。一旦绑定，就由Node上的kubelet接手pod的接下来的生命周期管理。Kubernetes目前提供了调度算法，但是同样也保留了接口，用户可以根据自己的需求定义自己的调度算法。</p><p><strong>controller manager：</strong>负责维护集群的状态，比如故障检测、自动扩展、滚动更新等。每个资源一般都对应有一个控制器，这些controller通过api server实时监控各个资源的状态，controller manager就是负责管理这些控制器的。当有资源因为故障导致状态变化，controller就会尝试将系统由“现有状态”恢复到“期待状态”，保证其下每一个controller所对应的资源始终处于期望状态。比如我们通过api server创建一个pod，当这个pod创建成功后，api server的任务就算完成了。其中一个pod出现问题，controller会自动恢复创建新的pod。</p><h3 id="Node节点有什么组件"><a href="#Node节点有什么组件" class="headerlink" title="Node节点有什么组件"></a>Node节点有什么组件</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4s6ogvdamj20rp0k276g.jpg"></p><p>kubelet: 会监视已分配给节点的pod，负责pod的生命周期管理，同时与Master密切协作，维护和管理该Node上面的所有容器，实现集群管理的基本功能。即Node节点通过kubelet与master组件交互，可以理解为kubelet是Master在每个Node节点上面的agent。本质上，它负责使Pod的运行状态与期望的状态一致。</p><p>kube-proxy: 是实现service的通信与负载均衡机制的重要组件，将到service的请求转发到后端的pod上。</p><p>docker-engine(docker): 是负责容器的创建和管理工作。</p><p>Pod: 最小部署单元，一个Pod 有一个或多个容器组成，容器中共享存储和网络，在同一台docker主机上运行。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sidecar</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/sidecar/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/sidecar/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Sidecar模式？"><a href="#什么是Sidecar模式？" class="headerlink" title="什么是Sidecar模式？"></a>什么是Sidecar模式？</h2><p>Sidecar模式是一种将应用功能从应用本身剥离出来作为单独进程的方式。该模式允许我们向应用无侵入添加多种功能，避免了为满足第三方组件需求而向应用添加额外的配置代码。</p><p>就像边车加装在摩托车上一样，在软件架构中，sidecar附加到主应用，或者叫父应用上，以扩展&#x2F;增强功能特性，同时Sidecar与主应用是松耦合的。</p><p>举个例子，假设现在有6个相互通信的微服务，每个微服务都需要具有可观察性、监控、日志记录、配置、断路器等功能，而所有这些功能都是在微服务中使用一些第三方库实现的。</p><p>这样一组服务的实际情况可能会非常复杂，增加了应用的整体复杂性，尤其是当每个微服务用不同的语言编写、使用不同的基于.net、Java、Python等语言的第三方库……</p><h2 id="Sidecar模式的好处"><a href="#Sidecar模式的好处" class="headerlink" title="Sidecar模式的好处"></a>Sidecar模式的好处</h2><ul><li>通过将公用基础设施相关功能抽象到不同的层来降低微服务的代码复杂性</li><li>由于我们不需要在每个微服务中编写配置代码，因此减少了微服务架构中的代码重复</li><li>P应用和底层平台之间实现了松耦合</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>daemonset适用场景</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/daemonset%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/k8s:docker/daemonset%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<ol><li>在集群的每个节点上运行存储 Daemon，比如 glusterd 或 ceph。</li><li>在每个节点上运行日志收集 Daemon，比如 flunentd 或 logstash。</li><li>在每个节点上运行监控 Daemon，比如 Prometheus Node Exporter 或 collectd。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka内部积压</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka/kafka%E5%86%85%E9%83%A8%E7%A7%AF%E5%8E%8B%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka/kafka%E5%86%85%E9%83%A8%E7%A7%AF%E5%8E%8B%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    
    <content type="html"><![CDATA[<p>1、kafka内部速度比较慢，rebalance（比较少）</p><p>排查分区数据发生倾斜</p><p>2、业务数据量增多</p><p>增大分区，增大并行度，排查消费者速率是否出现问题</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka如何保证消息的顺序性</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/kafka/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>我举个例子，我们以前做过一个 mysql <code>binlog</code> 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如<a href="https://cloud.tencent.com/solution/bigdata?from=10680">大数据</a> team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p><p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 <code>binlog</code> 日志，接着这三条 <code>binlog</code> 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</p><p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p><p>先看看顺序会错乱的俩场景：</p><ul><li>RabbitMQ：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1&#x2F;data2&#x2F;data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>，然后是 data1&#x2F;data3。这不明显乱了。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/1692602/3iq10gkba3.png?imageView2/2/w/1620" alt="img"></p><ul><li>Kafka：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。 消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞多个线程来并发处理消息。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/1692602/ej36p1xzs7.png?imageView2/2/w/1620" alt="img"></p><p>解决方案</p><p>RabbitMQ</p><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 </p><p><img src="https://ask.qcloudimg.com/http-save/1692602/51b3nl839e.png?imageView2/2/w/1620" alt="img"></p><p>Kafka</p><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><p><img src="https://ask.qcloudimg.com/http-save/1692602/5k5yv4ef95.png?imageView2/2/w/1620" alt="img"></p><p>参考文章：<a href="https://cloud.tencent.com/developer/article/1543005?from=article.detail.1839597">https://cloud.tencent.com/developer/article/1543005?from=article.detail.1839597</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要用补码表示数字</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%AD%97/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么要用补码表示数字"><a href="#为什么要用补码表示数字" class="headerlink" title="为什么要用补码表示数字"></a>为什么要用补码表示数字</h3><p>1、计算机里面只有加法，没有减法，能够处理数字的减法</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟内存</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要有虚拟内存？"><a href="#为什么要有虚拟内存？" class="headerlink" title="为什么要有虚拟内存？"></a>为什么要有虚拟内存？</h2><p>1、保证数据的安全性，因为如果程序运行在物理内存的话会很容易内存越界访问到其他程序的数据，并且这个会导致操作系统把这个程序杀掉，这样恶意进程就不容易访问到其他进程的数据。</p><p>2、通过分段或者分页方式在内存和硬盘之间构建一层中间层，通过页表把虚拟内存和物理块连接起来，可以提高内存使用率。</p><p>3、可以把一个超过需要内存大小的程序导入到内存中，每次导入一部分，如果缺少数据就缺页中断把缺少的数据从硬盘中导入到内存。</p><p>因为每个进程都使用虚拟内存，无法知道其他进程的地址，这样如果进程间要通话的话需要借助其他方式。</p><h4 id="进程通话方式"><a href="#进程通话方式" class="headerlink" title="进程通话方式"></a><a href="http://sjy.我爱你/2022/03/25/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F">进程通话方式</a></h4>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>io多路复用</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="io多路复用概念"><a href="#io多路复用概念" class="headerlink" title="io多路复用概念"></a>io多路复用概念</h3><p>​    IO多路复用是一种同步IO模型，一个线程监听多个IO事件，当有IO事件就绪时，就会通知线程去执行相应的读写操作，没有就绪事件时，就会阻塞交出cpu。多路是指网络链接，复用指的是复用同一线程。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ol><li>用户线程调用select，将fd_set从用户空间拷贝到内核空间</li><li>内核在内核空间对fd_set遍历一遍，检查是否有就绪的socket描述符，如果没有的话，就会进入休眠，直到有就绪的socket描述符</li><li>内核返回select的结果给用户线程，即就绪的文件描述符数量</li><li>用户拿到就绪文件描述符数量后，再次对fd_set进行遍历，找出就绪的文件描述符</li><li>用户线程对就绪的文件描述符进行读写操作</li></ol><p>优点</p><ol><li>所有平台都支持，良好的跨平台性</li></ol><p>缺点</p><ol><li>每次调用select，都需要将fd_set从用户空间拷贝到内核空间，当fd很多时，这个开销很大</li><li>最大连接数（支持的最大文件描述符数量）有限制，一般为1024</li><li>每次有活跃的socket描述符时，都需要遍历一次fd_set，造成大量的时间开销，时间复杂度是O(n)</li><li>将fd_set从用户空间拷贝到内核空间，内核空间也需要对fd_set遍历一遍</li></ol><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>数据结构定义如下，<strong>链表</strong>存储</p><pre><code class="hljs c"><span class="hljs-comment">/* Data structure describing a polling request.  */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span></span><span class="hljs-class">  &#123;</span>    <span class="hljs-type">int</span> fd;<span class="hljs-comment">/* File descriptor to poll.  */</span>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> events;<span class="hljs-comment">/* Types of events poller cares about.  */</span>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> revents;<span class="hljs-comment">/* Types of events that actually occurred.  */</span>  &#125;;</code></pre><p>与select的异同点</p><p>相同点：</p><p>（执行过程与select类似）</p><ol><li>内核线程都需要遍历文件描述符，并且当内核返回就绪的文件描述符数量后，还需要遍历一次找出就绪的文件描述符</li><li>需要将文件描述符数组或链表从用户空间拷贝到内核空间</li><li>性能开销会随文件描述符的数量而线性增大</li></ol><p>不同点：</p><ol><li>select存储的数据结构是文件描述符数组，poll采用链表</li><li>select有最大连接数限制，poll没有最大限制，因为poll采用链表存储</li></ol><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ol><li><p>epoll_create创建eventpoll对象（红黑树，双链表）</p></li><li><p>一棵红黑树，存储监听的所有文件描述符，并且通过epoll_ctl将文件描述符添加、删除到红黑树</p></li><li><p>一个双链表，存储就绪的文件描述符列表，epoll_wait调用时，检测此链表中是否有数据，有的话直接返回</p></li><li><p>所有添加到eventpoll中的事件都与设备驱动程序建立回调关系</p></li></ol><p>缺点</p><ol><li>只能工作在linux下</li></ol><p>优点</p><ol><li>时间复杂度为O(1)，当有事件就绪时，epoll_wait只需要检测就绪链表中有没有数据，如果有的话就直接返回</li><li>不需要从用户空间到内核空间频繁拷贝文件描述符集合，使用了内存映射(mmap)技术</li><li>当有就绪事件发生时采用回调的形式通知用户线程</li></ol><ul><li>应用场景<ol><li>连接数较少并且都很活跃,用select和poll效率更高</li><li>连接数较多并且都不很活跃,使用epoll效率更高</li></ol></li></ul><p>参考文章：<a href="https://juejin.cn/post/6931543528971436046">https://juejin.cn/post/6931543528971436046</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组和链表查询效率区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="数组和链表查询效率区别"><a href="#数组和链表查询效率区别" class="headerlink" title="数组和链表查询效率区别"></a>数组和链表查询效率区别</h2><pre><code class="hljs gcode">CPU 寄存器 – immediate access <span class="hljs-comment">(0-1个CPU时钟周期)</span>CPU L<span class="hljs-number">1</span> 缓存  – fast access <span class="hljs-comment">(3个CPU时钟周期)</span>CPU L<span class="hljs-number">2</span> 缓存 – slightly slower access <span class="hljs-comment">(10个CPU时钟周期)</span>内存 <span class="hljs-comment">(RAM)</span>   – slow access <span class="hljs-comment">(100个CPU时钟周期)</span>硬盘 <span class="hljs-comment">(file system)</span> – very slow <span class="hljs-comment">(10,000,000个CPU时钟周期)</span></code></pre><p>​    CPU缓存会把一片连续的内存空间读入，因为数组结构是连续的内存地址，所以数组全部或者部分元素被连续存在CPU缓存里面，平均读取每个元素的时间只要3个CPU时钟周期。 而链表的节点是分散在堆空间里面的，这时候CPU缓存帮不上忙，只能是去读取内存，平均读取时间需要100个CPU时钟周期。这样算下来，数组访问的速度比链表快33倍！ （这里只是介绍概念，具体的数字因CPU而异）。</p><h5 id="操作系统局部性原理"><a href="#操作系统局部性原理" class="headerlink" title="操作系统局部性原理"></a>操作系统局部性原理</h5><ul><li>时间局部性</li><li>空间局部性</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>僵尸进程</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>一个父进程开启了一堆子进程, 当子进程比父进程先运行完(死掉),操作系统会释放子进程占用的重型资源(内存空间, CPU资源, 打开的文件),但会保留子进程的关键信息(PID, 退出状态, 运行时间等),目的是为了让父进程能随时查看自己的子进程信息(不管该子进程有没有死掉),这种已经死掉的子进程都会进入僵尸状态, ‘‘僵尸进程’’是Linux系统的一种数据结构<br>这些子进程完成执行后会发送一个 Exit 信号然后死掉。这个 Exit 信号需要被父进程所读取。父进程需要随后调用 wait 命令来读取子进程的退出状态，并将子进程从进程表中移除。</p><p>若父进程正确第读取了子进程的 Exit 信号，则子进程会从进程表中删掉。</p><p>但若父进程未能读取到子进程的 Exit 信号，则这个子进程虽然完成执行处于死亡的状态，但也不会从进程表中删掉。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>程序在运行中奔溃了，估计是框架又帮忙重启了，导致会产生僵尸进程</p><h3 id="坏处："><a href="#坏处：" class="headerlink" title="坏处："></a>坏处：</h3><p>虽然不会浪费内存、cpu资源等文件，但是会浪费pid，多了之后pid会不够用。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul><li>操作系统保留子进程信息供父进程查看</li><li>当父进程觉得<strong>不再需要</strong>查看的时候, 会向操作系统发送一个 <strong>wait &#x2F; waitpid</strong> 系统调用</li><li>于是操作系统<strong>再次清理</strong>僵尸进程的残余信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程和线程上下文切换的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="进程和线程上下文切换的区别"><a href="#进程和线程上下文切换的区别" class="headerlink" title="进程和线程上下文切换的区别"></a>进程和线程上下文切换的区别</h2><h4 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h4><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-d831951a5e41bbfb1e0e1151a8a2b649_1440w.jpg" alt="img"></p><p>进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。</p><p>在这个过程中就发生了 CPU 上下文切换，整个过程是这样的：<br>1、保存 CPU 寄存器里原来用户态的指令位<br>2、为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。<br>3、跳转到内核态运行内核任务。<br>4、当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。</p><p>所以，<strong>一次系统调用的过程，其实是发生了两次 CPU 上下文切换</strong>。（用户态-内核态-用户态）</p><p>不过，需要注意的是，<strong>系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程</strong>。这跟我们通常所说的进程上下文切换是不一样的：<strong>进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行。</strong></p><h2 id="进程上下文切换跟系统调用又有什么区别呢"><a href="#进程上下文切换跟系统调用又有什么区别呢" class="headerlink" title="进程上下文切换跟系统调用又有什么区别呢"></a>进程上下文切换跟系统调用又有什么区别呢</h2><p>首先，<strong>进程是由内核来管理和调度的，进程的切换只能发生在内核态</strong>。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p><p>因此，<strong>进程的上下文切换就比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈</strong>。</p><p>如下图所示，保存上下文和恢复上下文的过程并不是“免费”的，需要内核在 CPU 上运行才能完成。</p><p><img src="https://pic3.zhimg.com/80/v2-440bb1699b2fa0f0340b38eabcbd7452_1440w.jpg" alt="img"></p><h2 id="发生进程上下文切换的场景"><a href="#发生进程上下文切换的场景" class="headerlink" title="发生进程上下文切换的场景"></a>发生进程上下文切换的场景</h2><ol><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</li><li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li></ol><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>线程与进程最大的区别在于：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><p>所以，对于线程和进程，我们可以这么理解： - 当进程只有一个线程时，可以认为进程就等于线程。 - 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。 - 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p><h2 id="发生线程上下文切换的场景"><a href="#发生线程上下文切换的场景" class="headerlink" title="发生线程上下文切换的场景"></a>发生线程上下文切换的场景</h2><ol><li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li><li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</li></ol><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/52845869">https://zhuanlan.zhihu.com/p/52845869</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux由哪几部分组成</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E7%94%B1%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E7%94%B1%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h3 id="Linux由哪几部分组成"><a href="#Linux由哪几部分组成" class="headerlink" title="Linux由哪几部分组成"></a>Linux由哪几部分组成</h3><p>一．Linux内核<br>内核是操作系统的核心，具有很多最基本功能，如虚拟内存、多任务、共享库、需求加载、可执行程序和TCP&#x2F;IP网络功能。Linux内核的模块分为以下几个部分：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等。<br>二．Linux shell<br>shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。<br>三．Linux文件系统<br>文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、EXT3、FAT、FAT32、VFAT和ISO9660。<br>四．Linux应用程序<br>标准的Linux系统一般都有一套都有称为应用程序的程序集，它包括文本编辑器、编程语言、XWindow、办公套件、Internet工具和数据库等。</p><h4 id="内核的作用是什么"><a href="#内核的作用是什么" class="headerlink" title="内核的作用是什么"></a>内核的作用是什么</h4><ol><li><strong>内存管理：</strong>追踪记录有多少内存存储了什么以及存储在哪里</li><li><strong>进程管理：</strong>确定哪些进程可以使用中央处理器（CPU）、何时使用以及持续多长时间</li><li><strong>设备驱动程序：</strong>充当硬件与进程之间的调解程序&#x2F;解释程序</li><li><strong>系统调用和安全防护：</strong>从流程接受服务请求</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL有哪些数据类型</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Mysql-有哪些数据类型，使用的时候有没有什么注意点"><a href="#Mysql-有哪些数据类型，使用的时候有没有什么注意点" class="headerlink" title="Mysql 有哪些数据类型，使用的时候有没有什么注意点"></a>Mysql 有哪些数据类型，使用的时候有没有什么注意点</h3><p><strong>整数类型</strong>：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、INT、BIG INT<br><strong>浮点数类型：</strong>FLOAT、DOUBLE、DECIMAL<br><strong>字符串类型：</strong>CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、MEDIUM BLOB、LONG BLOB<br><strong>日期类型：</strong>Date、DateTime、TIMESTAMP、TIME、YEAR<br>使用的时候建议遵循从小原则。</p><p>使用char和vahrchar的时候，注意char会去掉字符串末尾的空格<br>使用text和blob的时候，注意定期清理碎片空间，使用OPTIMIZE TABLE命令<br>浮点数会造成精度丢失，尽量使用定点数DECIMAL</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU和LFU等淘汰算法</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/LRU%E5%92%8CLFU%E7%AD%89%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/LRU%E5%92%8CLFU%E7%AD%89%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>算法介绍：一个双向链表，一个map记录链表中的节点，访问一个节点，如果在链表里面，就把这个节点从原来的地方删除并且插入到链表头部。</p><p>优点：考虑了时间的因素</p><p>缺点：没有考虑频率的原因，容易因为扫库把热点数据扫出去</p><h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><p>算法介绍： 在最前面的是访问频率最多的数据，访问一次就把这个数据的访问次数加一并且排序把序列有序，如果满了就把频率最低的节点淘汰</p><p><strong>可以使用最小堆或者优先队列实现，时间复杂度O（logn）</strong></p><p>优点：考虑了频率的因素</p><p>缺点：没有考虑时间的原因，容易收到历史数据的影响。</p><h2 id="冷热LRU（mysql的缓存池做法）"><a href="#冷热LRU（mysql的缓存池做法）" class="headerlink" title="冷热LRU（mysql的缓存池做法）"></a>冷热LRU（mysql的缓存池做法）</h2><p>把一个LRU链表中的5&#x2F;8作为热点数据链表，3&#x2F;8作为冷LRU链表</p><p>插入：节点不在链表时就先插入到冷链表，第二次在遇到这个节点就插入到热链表中，也像lru链表一样，每次遇到就会插入到前面，热链表再次遇到就插入到最前面，冷链表中再次遇到就插入到热链表的最前面，</p><p>淘汰：每次都淘汰冷链表中最后几个数据页。</p><p>优点：防止扫库把热点数据淘汰了，既考虑了时间，也考虑了频率。</p><h4 id="什么时候将LRU链表中的冷热数据中的缓存页刷盘"><a href="#什么时候将LRU链表中的冷热数据中的缓存页刷盘" class="headerlink" title="什么时候将LRU链表中的冷热数据中的缓存页刷盘"></a>什么时候将LRU链表中的冷热数据中的缓存页刷盘</h4><p>定时刷盘，MySQL会起一个后台线程，运行定时任务，每隔一定的时间就将LRU链表的冷数据区域尾部的一些缓存页刷盘，然后清空这些缓存页，并放入<code>free链表</code>，从<code>LRU链表</code>删除，从<code>Flush链表</code>删除</p><h2 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h2><p>​    LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法”缓存污染”的问题，其核心思想是将”最近使用过1次”的判断标准扩展为”最近使用过K次”</p><p>常用实现如下</p><p>数据第一次被访问，加入到访问历史列表；如果数据在访问历史列表里后没有达到K次访问，则按照LRU淘汰；当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；缓存数据队列中被再次访问后，重新排序；需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即淘汰”倒数第K次访问离现在最久”的数据。</p><p>命中率分析</p><p>LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。LRU-K降低了”缓存污染”带来的问题，命中率比LRU要高。</p><p>2Q与LRU-2类似，不同点在于将LRU-2算法中的访问历史队列改成了一个FIFO队列</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua脚本为什么支持原子性</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/lua%E8%84%9A%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/lua%E8%84%9A%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h4 id="Redis事务满足原子性吗"><a href="#Redis事务满足原子性吗" class="headerlink" title="Redis事务满足原子性吗"></a>Redis事务满足原子性吗</h4><p>有两种错误：语法错误和运行错误</p><p>语法错误可以保障原子性，但是运行错误无法保障原子性，正常语句还是能够正常执行</p><h4 id="为什么redis不支持回滚"><a href="#为什么redis不支持回滚" class="headerlink" title="为什么redis不支持回滚"></a>为什么redis不支持回滚</h4><p>官方给出了解释</p><ul><li>redis命令失败只会发生在语法错误或数据类型错误的情况，这一结果都是由编程过程中的错误导致，这种情况应该在开发环境中检测出来，而不是生产环境。</li><li>不使用回滚，能使redis内部设计更简单，速度更快</li><li>回滚不能避免编程逻辑中的错误，如果想要将一个键的值增加2却只增加了1，这种情况即使提供回滚也无法提供帮助。</li></ul><p>基于以上原因，redis官方选择了更简单、更快的方法，不支持错误回滚。这样的话，如果在我们的业务场景中需要保证原子性，那么就要求了开发者通过其他手段保证命令全部执行成功或失败，例如在执行命令前进行参数类型的校验，或在事务执行出现错误时及时做事务补偿。</p><h4 id="Lua脚本满足原子性吗"><a href="#Lua脚本满足原子性吗" class="headerlink" title="Lua脚本满足原子性吗"></a>Lua脚本满足原子性吗</h4><p>结论：运行错误的话只会执行错误之前的语句，还是不支持原子性</p><h4 id="Lua脚本满足原子性的原因："><a href="#Lua脚本满足原子性的原因：" class="headerlink" title="Lua脚本满足原子性的原因："></a>Lua脚本满足原子性的原因：</h4><p>在redis中是使用的同一个lua解释器来执行所有命令，也就保证了当一段lua脚本在执行时，不会有其他脚本或redis命令同时执行，保证了操作不会被其他指令插入或打扰，实现的仅仅是这种程度上的原子操作。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>radis</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/radis/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/radis/</url>
    
    <content type="html"><![CDATA[<h2 id="radis基本数据类型"><a href="#radis基本数据类型" class="headerlink" title="radis基本数据类型"></a>radis基本数据类型</h2><h4 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1. String（字符串）"></a>1. String（字符串）</h4><p>String是简单的 key-value 键值对，value 不仅可以是 String，也可以是数字。String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p><h4 id="2-List（列表）"><a href="#2-List（列表）" class="headerlink" title="2. List（列表）"></a>2. List（列表）</h4><p>Redis列表是简单的字符串列表，可以类比到C++中的std::list，简单的说就是一个链表或者说是一个队列。可以从头部或尾部向Redis列表添加元素。列表的最大长度为2^32 - 1，也即每个列表支持超过40亿个元素。</p><p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p><h4 id="3-Hash（字典，哈希表）"><a href="#3-Hash（字典，哈希表）" class="headerlink" title="3. Hash（字典，哈希表）"></a>3. Hash（字典，哈希表）</h4><p>类似C#中的dict类型或者C++中的hash_map类型。</p><p>Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。</p><h4 id="4-Set（集合）"><a href="#4-Set（集合）" class="headerlink" title="4. Set（集合）"></a>4. Set（集合）</h4><p>可以理解为一堆值不重复的列表，类似数学领域中的集合概念，且Redis也提供了针对集合的求交集、并集、差集等操作。</p><p>set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p><h4 id="5-Sorted-Set（有序集合）"><a href="#5-Sorted-Set（有序集合）" class="headerlink" title="5. Sorted Set（有序集合）"></a>5. Sorted Set（有序集合）</h4><p>Redis有序集合类似Redis集合，不同的是增加了一个功能，即集合是有序的。一个有序集合的每个成员带有分数，用于进行排序。</p><p>Redis有序集合添加、删除和测试的时间复杂度均为O(1)(固定时间，无论里面包含的元素集合的数量)。列表的最大长度为2^32- 1元素(4294967295，超过40亿每个元素的集合)。</p><p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>定义：大量缓存同时失效，导致大量请求打到数据库导致数据库宕机。</p><p>解决办法：让缓存失效的时间尽量均匀</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>定义：缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。</p><p>解决办法：通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>定义：缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p><p>解决办法：使用布隆过滤器判断是否在数据库中。</p><h3 id="reids是单线程为什么这么快"><a href="#reids是单线程为什么这么快" class="headerlink" title="reids是单线程为什么这么快"></a>reids是单线程为什么这么快</h3><p>Redis的性能非常之高，每秒可以承受10W+的QPS，它如此优秀的性能主要取决于以下几个方面：</p><ul><li>纯内存操作</li><li>使用IO多路复用技术</li><li>非CPU密集型任务</li><li>单线程的优势</li></ul><h3 id="纯内存操作"><a href="#纯内存操作" class="headerlink" title="纯内存操作"></a>纯内存操作</h3><p>Redis是一个内存数据库，它的数据都存储在内存中，这意味着我们读写数据都是在内存中完成，这个速度是非常快的。</p><p>Redis是一个KV内存数据库，它内部构建了一个哈希表，根据指定的KEY访问时，只需要O(1)的时间复杂度就可以找到对应的数据。同时，Redis提供了丰富的数据类型，并使用高效的操作方式进行操作，这些操作都在内存中进行，并不会大量消耗CPU资源，所以速度极快。</p><h5 id="redis-hash-key-冲突了怎么办"><a href="#redis-hash-key-冲突了怎么办" class="headerlink" title="redis hash key 冲突了怎么办"></a>redis hash key 冲突了怎么办</h5><p>​    Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p><h4 id="使用IO多路复用技术"><a href="#使用IO多路复用技术" class="headerlink" title="使用IO多路复用技术"></a>使用IO多路复用技术</h4><p>Redis采用单线程，那么它是如何处理多个客户端连接请求呢？</p><p>Redis采用了IO多路复用技术和非阻塞IO，这个技术由操作系统实现提供，Redis可以方便地操作系统的API即可。Redis可以在单线程中监听多个Socket的请求，在任意一个Socket可读&#x2F;可写时，Redis去读取客户端请求，在内存中操作对应的数据，然后再写回到Socket中。</p><p>整个过程非常高效，Redis利用了IO多路复用技术的事件驱动模型，保证在监听多个Socket连接的情况下，只针对有活动的Socket采取反应。</p><h4 id="非CPU密集型任务"><a href="#非CPU密集型任务" class="headerlink" title="非CPU密集型任务"></a>非CPU密集型任务</h4><p>采用单线程的缺点很明显，无法使用多核CPU。Redis作者提到，由于Redis的大部分操作并不是CPU密集型任务，而Redis的瓶颈在于内存和网络带宽。</p><p>在高并发请求下，Redis需要更多的内存和更高的网络带宽，否则瓶颈很容易出现在内存不够用和网络延迟等待的情况。</p><p>当然，如果你觉得单个Redis实例的性能不足以支撑业务，Redis作者推荐部署多个Redis节点，组成集群的方式来利用多核CPU的能力，而不是在单个实例上使用多线程来处理。</p><h4 id="单线程的优势"><a href="#单线程的优势" class="headerlink" title="单线程的优势"></a>单线程的优势</h4><p>基于以上特性，Redis采用单线程已足够达到非常高的性能，所以Redis没有采用多线程模型。</p><p>另外，单线程模型还带了以下好处：</p><ul><li>没有了多线程上下文切换的性能损耗</li><li>没有了访问共享资源加锁的性能损耗</li><li>开发和调试非常友好，可维护性高</li></ul><p>所以Redis正是基于以上这些方面，所以采用了单线程模型来完成请求处理的工作。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>上面介绍了单线程可以达到如此高的性能，并不是说它就没有缺点了。</p><p><strong>单线程处理最大的缺点就是，如果前一个请求发生耗时比较久的操作，那么整个Redis就会阻塞住，其他请求也无法进来，直到这个耗时久的操作处理完成并返回，其他请求才能被处理到。</strong></p><p>我们平时遇到Redis变慢或长时间阻塞的问题，90%也都是因为Redis处理请求是单线程这个原因导致的。</p><p>所以，我们在使用Redis时，一定要避免非常耗时的操作，例如使用时间复杂度过高的方式获取数据、一次性获取过多的数据、大量key集中过期导致Redis淘汰key压力变大等等，这些场景都会阻塞住整个处理线程，直到它们处理完成，势必会影响业务的访问。</p><p>我会在后期的文章中专门介绍具体有哪些场景会引发Redis阻塞的问题，并提供规避问题的方法和优化方案。</p><h1 id="什么是大key问题"><a href="#什么是大key问题" class="headerlink" title="什么是大key问题"></a>什么是大key问题</h1><p>就是一个key的value特别大，比如一个hashmap中存了超多k,v;<br>或者一个列表key中存了超长列表，等等；<br>多大算大： hashmap中有100w的k,v &#x3D;&gt; 1s延迟；<br>删除大Key的时间复杂度: O(N), N代表大key里的值数量，因为redis是单线程一个个删。<br>所以删大key也会卡qps。</p><p>因为redis是单线程处理，如果处理一些长时间的操作会造成阻塞</p><p>1.内存不均：单value较大时，可能会导致节点之间的内存使用不均匀，间接地影响key的部分和负载不均匀；<br>2.阻塞请求：redis为单线程，单value较大读写需要较长的处理时间，会阻塞后续的请求处理；<br>3.阻塞网络：单value较大时会占用服务器网卡较多带宽，可能会影响该服务器上的其他Redis实例或者应用。</p><h3 id="redis-大key怎么处理"><a href="#redis-大key怎么处理" class="headerlink" title="redis 大key怎么处理"></a>redis 大key怎么处理</h3><h4 id="1、-lazyfree机制"><a href="#1、-lazyfree机制" class="headerlink" title="1、 lazyfree机制"></a>1、 lazyfree机制</h4><p><code>unlink</code>命令：代替DEL命令；<br>会把对应的大key放到<code>BIO_LAZY_FREE</code>后台线程任务队列，然后在后台异步删除；</p><p>类似的异步删除命令:</p><pre><code class="hljs csharp">flushdb <span class="hljs-keyword">async</span>: 异步清空数据库flushall <span class="hljs-keyword">async</span>: 异步清空所有数据库</code></pre><p>异步删除配置:</p><pre><code class="hljs coq">slave-<span class="hljs-built_in">lazy</span>-flush: slave接受完rdb文件后，异步清空数据库；lazyfree-<span class="hljs-built_in">lazy</span>-eviction: 异步淘汰key;lazyfree-<span class="hljs-built_in">lazy</span>-expire:   异步key过期;lazyfree-<span class="hljs-built_in">lazy</span>-server-del: 异步内部删除key；生效于<span class="hljs-built_in">rename</span>命令## <span class="hljs-built_in">rename</span>命令: RENAME mykey new_name ## 如果new_name已经存在，会先删除new_name，此时触发上述<span class="hljs-built_in">lazy</span>机制</code></pre><p><strong>1.单个简单key的存储的value过大的解决方案：</strong></p><p><strong>将大key拆分成多个key-value，使用multiGet方法获得值，这样的拆分主要是为了减少单台操作的压力，而是将压力平摊到集群各个实例中，降低单台机器的IO操作。</strong></p><p><strong>2.hash、set、zset、list中存储过多的元素的解决方案：</strong></p><p><strong>1).类似于第一种场景，使用第一种方案拆分;</strong></p><p><strong>2).以hash为例，将原先的hget、hset方法改成（加入固定一个hash桶的数量为10000），先计算field的hash值模取10000，确定该field在哪一个key上。</strong></p><p>将大key进行分割，为了均匀分割，可以对field进行hash并通过质数N取余，将余数加到key上面，我们取质数N为997。</p><p>那么新的key则可以设置为：</p><p>newKey &#x3D; order_20200102_String.valueOf( Math.abs(order_id.hashcode() % 997) )</p><p>field &#x3D; order_id</p><p>value &#x3D; 10</p><p>hset (newKey, field, value) ;  </p><p>hget(newKey, field)</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 持久化</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%20%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%20%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="redis-持久化"><a href="#redis-持久化" class="headerlink" title="redis 持久化"></a>redis 持久化</h2><h3 id="redis持久化的概念："><a href="#redis持久化的概念：" class="headerlink" title="redis持久化的概念："></a>redis持久化的概念：</h3><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制叫做持久化。<br>持久化是为了保障数据安全的。</p><h3 id="持久化保存的是什么？"><a href="#持久化保存的是什么？" class="headerlink" title="持久化保存的是什么？"></a>持久化保存的是什么？</h3><p>那么持久化保存的是什么？<br>Redis持久化有两种形式：<br>1.快照<br>2.记录过程</p><p>快照方式就是我们所说的RDB,记录过程的方式就是AOF。</p><p>RDB(Redis DataBase):<br>RDB是将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</p><p>AOF（append only file):<br>AOF是将执行过的指令记录下来，数据恢复时按照从前到后的顺序再将指令执行一遍，实现数据恢复。</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="RDB的启动方式："><a href="#RDB的启动方式：" class="headerlink" title="RDB的启动方式："></a>RDB的启动方式：</h3><p>save指令。作用就是执行一次保存操作。</p><p><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_0.jpg" alt="在这里插入图片描述"><br>通过使用save命令。我们就可以看到生成了一个rdb文件：<br><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_5.jpg" alt="在这里插入图片描述"><br>rdb中的文件是二进制文件。我们是无法打开的。</p><p><strong>当然我们也可以进行默认触发，就是将此命令写入到conf中。</strong></p><h4 id="save指令相关配置："><a href="#save指令相关配置：" class="headerlink" title="save指令相关配置："></a>save指令相关配置：</h4><p>我们使用了RDB生成了文件。接下来我们看看save指令的相关配置：</p><ul><li>dbfilename dump.rdb:<br>设置本地数据库文件名，默认值为dump.rdb，通常设置为dump-端口号.rdb</li><li>dir：<br>设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称为data</li><li>rdbcompression yes:<br>设置存储至本地数据库时是否压缩数据<br>默认为yes，采用LZF压缩。通常设置为开启状态，如果设置为no，可以节省cpu运行时间，但是会使存储的文件变大（巨大）</li><li>rdbchecksum yes<br>设置是否进行RDB文件格式校验，改校验过程在写文件和读文件过程均进行<br>通常默认设置为开启状态，如果设置为no，可以节约读写行过程约10%时间消耗，但是存储一定的数据损坏风险。</li></ul><p><strong>这些命令在conf文件中添加即可生效。</strong></p><h4 id="save指令的工作原理"><a href="#save指令的工作原理" class="headerlink" title="save指令的工作原理"></a>save指令的工作原理</h4><p>save指令是单线程任务执行序列 ，进行一个一个执行的。当我们执行save指令过长的时候，save指令的执行会阻塞当前的Redis服务器。<strong>线上的环境不建议使用</strong>。</p><h4 id="bgsave指令："><a href="#bgsave指令：" class="headerlink" title="bgsave指令："></a>bgsave指令：</h4><p>那么如何处理数据量过大，单线程执行方式造成效率过得问题？<br>我们可以通过后台指令执行。通过bgsave指令来执行。</p><p>当我们执行bgsave指令的时候，它会给redis发送一个消息。之后进行返回消息.他不会立即执行，而是通过fork生成子进程来进行创建rdb文件。做完之后会返回一个消息。</p><p><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_1.jpg" alt="在这里插入图片描述"><br>我们在log中也可以看到这句话：<br><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_3.jpg" alt="在这里插入图片描述"></p><p>bgsave命令式针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都<strong>建议采用bgsave的方式</strong>，<strong>save命令放弃使用</strong>。</p><h3 id="save配置方式"><a href="#save配置方式" class="headerlink" title="save配置方式"></a>save配置方式</h3><p>RDB的启动方式有两种，一种是通过命令的方式。还有一种就是通过写入到conf配置文件中。<br>命令如下：</p><pre><code class="hljs java">save second changes</code></pre><p>second:监控时间范围。<br>changes:监控key的变化量<br>这个的作用就是限定时间范围内key的变化数量达到指定数量及进行持久化操作。</p><p>例如：</p><pre><code class="hljs java">save <span class="hljs-number">200</span> <span class="hljs-number">10</span>：表示<span class="hljs-number">200</span> 秒内如果至少有 <span class="hljs-number">10</span> 个 key 的值变化，则保存</code></pre><p>注意：默认save配置使用的是bgsave操作。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>启动方式<br><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_2.jpg" alt="在这里插入图片描述"><br>还有一些其他的特殊形式来进行启动save：</p><ul><li>全量复制</li><li>debug reload 重启过程中</li><li>shutdown save 关闭服务器</li></ul><p>RDB优点：</p><ul><li>压缩的二进制文件，存储效率高</li><li>内部存储的是redis在某个时间点的快照，非常适合用于数据备份，全量复制场景。</li><li>RDB恢复数据的速度比AOF块</li><li>应用：服务器每隔x小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</li></ul><p>RDB缺点：</p><ul><li>RDB 无法做到实时持久化</li><li>bgsave指令每次运行执行fork操作，牺牲性能</li><li>Redis多版本RDB文件格式版本未统一，有可能版本无法兼容。</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF对RDB的一些弊端进行了解决。</p><ul><li>快照思想是读写全部数据，而AOF仅仅记录操作过程</li><li>对所有操作进行记录，排除丢失数据的风险</li><li><strong>解决了数据持久化的实时性</strong></li></ul><p>由于上面的许多优点，AOF已经成为了主流的持久化方式，因此，<strong>我们在使用持久化的时候，最好选择AOF.</strong></p><p>我们看一下AOF写入的过程：<br><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_4.jpg" alt="在这里插入图片描述"><br>写数据的三种策略：</p><ul><li>always:每次写入操作珺同步到AOF文件中，性能差</li><li>everysec：每秒将缓冲区中的指令同步到AOF文件中，数据准确性高。系统宕机丢失一秒的数据。</li><li>no：由操作系统控制每次同步到AOF文件的生命周期，整体过程无法控制。</li></ul><p>从上面三种来看，丢失一秒的数据是我们可容忍的，性能还可以。所以<strong>建议选择everysec</strong>。</p><h4 id="AOF开启"><a href="#AOF开启" class="headerlink" title="AOF开启"></a>AOF开启</h4><p>将 redis.conf 的 appendonly 配置改为 yes 即可</p><pre><code class="hljs java">appendonly yes|noappendfsync always|everysec| no</code></pre><h4 id="AOF改名"><a href="#AOF改名" class="headerlink" title="AOF改名"></a>AOF改名</h4><p>appendfilename ：aof文件名，默认是”appendonly.aof”</p><h4 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h4><p>随着命令不断写入AOF,文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新的AOF文件的过程。<br>简单来说就是将对同一个数据的若干跳命令执行结果转化成最终结果数据对应的指令进行记录。</p><p>我们将AOF重写之后主要有三点作用：</p><ul><li>降低磁盘占用量，提高效率</li><li>提高IO</li><li>降低数据恢复效率</li></ul><p>AOF重写规则：</p><ul><li>进程内一超市的数据不再写入文件</li><li>忽略无效指令，例如：del key1 hdel key2,srem key3 set key4 111 set key4 222.</li><li>对同一个数据的多条命令合并为一条命令<br>如：</li></ul><pre><code class="hljs java">lpush list1 alpush list1 blpush list1 c</code></pre><p>可以合并为一条</p><pre><code class="hljs java">lpush list1 a b c</code></pre><h4 id="AOF重写方式"><a href="#AOF重写方式" class="headerlink" title="AOF重写方式"></a>AOF重写方式</h4><p>手动重写：bgrewriteof<br><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_6.jpg" alt="在这里插入图片描述"></p><p>自动重写：</p><p>auto-aof-rewrite-percentage :默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。<br>auto-aof-rewrite-min-size：64mb:设置允许重写的最小aof文件大小</p><p>自动重写触发对比参数：（运行指令info persistence获取信息）</p><pre><code class="hljs java">aof_current_sizeaof_base_size</code></pre><p>自动重写触发条件：</p><pre><code class="hljs java">aof_current_size &gt;auto-aof-rewrite-min-sizeaof_current_size-aof_base_size/aof_base_size &gt;= auto-aof-rewrite-percentage</code></pre><h2 id="RDB与AOF区别"><a href="#RDB与AOF区别" class="headerlink" title="RDB与AOF区别"></a>RDB与AOF区别</h2><p><img src="https://img.inotgo.com/imagesLocal/202203/05/202203050529489737_8.jpg" alt="在这里插入图片描述"></p><p>如何选择：</p><ul><li>对数据非常敏感，建议使用AOF<br>-AOF持久化策略使用everysecond,每秒钟fsync一次.该策略redis仍可以保持很好的处理性能。出现问题的时候，最多丢失0-1秒内的数据。<br>-aof文件存储体积较大，恢复速度较慢</li><li>数据呈现阶段有效性，建议使用RDB持久化 ,比如游戏宕机了，数据恢复到昨天。数据可以良好的做到阶段内无丢失，恢复速度较快。但是rdb持久化使redis性能降低</li></ul><p>数据敏感：AOF<br>追求大数据的恢复速度rdb<br>灾难恢复rdb<br>双保险RDB AOF同时。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql redo undo bin log</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%20redo%20undo%20bin%20log/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%20redo%20undo%20bin%20log/</url>
    
    <content type="html"><![CDATA[<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>重做日志</p><p>　　作用：确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，（刷脏页是个随机IO），在重启 mysql 服务的时候，根据 redo log 进行重做，从而达到事务的持久性这一特性。</p><h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><p>归档日志（二进制日志）</p><p>　　作用：用于复制，在主从复制中，从库利用主库上的 binlog 进行重播，实现主从同步。 用于数据库的基于时间点的还原。</p><p>　　内容：逻辑格式的日志，可以简单认为就是执行过的事务中的 sql 语句。但又不完全是 sql 语句这么简单，而是包括了执行的 sql 语句（增删改）反向的信息，也就意味着 delete 对应着 delete 本身和其反向的 insert；update 对应着 update 执行前后的版本的信息；insert 对应着 delete 和 insert 本身的信息。</p><p>　　binlog 有三种模式：Statement（基于 SQL 语句的复制）、Row（基于行的复制） 以及 Mixed（混合模式）</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>回滚日志</p><p>　　作用：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p><p>　　内容：逻辑格式的日志，在执行 undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于 redo log 的。</p><h3 id="redo-log-和-undo-log-的区别"><a href="#redo-log-和-undo-log-的区别" class="headerlink" title="redo log 和 undo log 的区别"></a>redo log 和 undo log 的区别</h3><p>undo 日志用于记录事务开始前的状态，用于事务失败时的回滚操作；redo 日志记录事务执行后的状态，用来恢复未写入 data file 的已成功事务更新的数据。例如某一事务的事务序号为 T1，其对数据 X 进行修改，设 X 的原值是 0，修改后的值为 1，那么 Undo 日志为 &lt;T1, X, 0&gt;，Redo 日志为 &lt; T1, X, 1&gt;。</p><h3 id="redo-log与binlog的区别"><a href="#redo-log与binlog的区别" class="headerlink" title="redo log与binlog的区别"></a><strong>redo log与binlog的区别</strong></h3><p>我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：</p><p>（1）作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。</p><p>（2）层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他存储引擎。</p><p>（3）内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。</p><p>（4）写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：</p><p><img src="https://img-blog.csdnimg.cn/20200509170444156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4MTIzNjk4,size_16,color_FFFFFF,t_70"></p><p>前面曾提到：当事务提交时会调用fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。<br>除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis命令</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="Hash类型的操作命令"><a href="#Hash类型的操作命令" class="headerlink" title="Hash类型的操作命令"></a>Hash类型的操作命令</h3><p>1、hget</p><p>2、hset</p><pre><code class="hljs apache"><span class="hljs-attribute">hset</span> myhash id <span class="hljs-number">1</span></code></pre><p>3、hmeset </p><p>同时设置多对值</p><p>4、hgetall</p><p>获取key下所有值</p><pre><code class="hljs ebnf"><span class="hljs-attribute">hgetall myhash</span></code></pre><p>5、hlen</p><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="language-javascript">hlen mash</span>1</code></pre><p>6、hkeys，hvals</p><pre><code class="hljs ebnf"><span class="hljs-attribute">hkeys myhash</span></code></pre><p>获取所有key或者val</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关系型数据库和非关系型数据库的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p><strong>概念：</strong>关系型数据库是指采用了关系模型来组织数据的数据库。简单来说，关系模式就是二维表格模型。</p><p>主要代表：SQL Server，Oracle,Mysql,PostgreSQL。</p><p><strong>优点</strong></p><p>（1）容易理解，二维表的结构非常贴近现实世界，二维表格，容易理解。</p><p>（2）使用方便，通用的sql语句使得操作关系型数据库非常方便。</p><p>（3）易于维护，数据库的ACID属性，大大降低了数据冗余和数据不一致的概率。</p><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><p><strong>概念：</strong>NoSQL非关系型数据库，主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统，主要代表MongoDB，Redis、CouchDB。</p><p>NoSQL提出了另一种理念，以键值来存储，且结构不稳定，每一个元组都可以有不一样的字段，这种就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，为了获取用户的不同信息，不需要像关系型数据库中，需要进行多表查询。仅仅需要根据key来取出对应的value值即可。</p><p><strong>缺点：</strong>但是由于Nosql约束少，所以也不能够像sql那样提供where字段属性的查询。因此适合存储较为简单的数据。有一些不能够持久化数据，所以需要和关系型数据库结合。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>关系型数据库适合存储结构化数据，比如：用户的账号、地址：</p><p>（1）这些数据通常需要做结构化查询，比如说Join，这个时候，关系型数据库就要胜出一筹。</p><p>（2）这些数据的规模、增长的速度通常是可以预期的。</p><p>（3）事务性、一致性,适合存储比较复杂的数据。</p><p>NoSql适合存储非结构化数据，比如：文章、评论：</p><p>（1）这些数据通常用于模糊处理，例如全文搜索、机器学习，适合存储较为简单的数据。</p><p>（2）这些数据是海量的，并且增长的速度是难以预期的。</p><p>（3）按照key获取数据效率很高，但是对于join或其他结构化查询的支持就比较差。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis和数据库操作顺序</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="更新数据时redis和mysql的操作顺序"><a href="#更新数据时redis和mysql的操作顺序" class="headerlink" title="更新数据时redis和mysql的操作顺序"></a>更新数据时redis和mysql的操作顺序</h2><h4 id="1、先删缓存再更新mysql"><a href="#1、先删缓存再更新mysql" class="headerlink" title="1、先删缓存再更新mysql"></a>1、先删缓存再更新mysql</h4><p>结论：产生脏数据的概率较大（若出现脏数据，则意味着再不更新的情况下，查询得到的数据均为旧的数据），多一次 cache miss</p><p>比如：两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。</p><h4 id="2、先更新mysql再删缓存"><a href="#2、先更新mysql再删缓存" class="headerlink" title="2、先更新mysql再删缓存"></a>2、先更新mysql再删缓存</h4><p>假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p><p>（1）缓存刚好失效</p><p>（2）请求A查询数据库，得一个旧值</p><p>（3）请求B将新值写入数据库</p><p>（4）请求B删除缓存</p><p>（5）请求A将查到的旧值写入缓存</p><p>ok，如果发生上述情况，确实是会发生脏数据。</p><p>然而，发生这种情况的概率又有多少呢？</p><p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，<strong>数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</strong></p><p>副作用：多一次 cache miss</p><h4 id="3、先更新数据库再更新缓存"><a href="#3、先更新数据库再更新缓存" class="headerlink" title="3、先更新数据库再更新缓存"></a>3、先更新数据库再更新缓存</h4><p><strong>原因一：线程安全角度</strong></p><p>同时有请求A和请求B进行更新操作，那么会出现</p><p>（1）线程A更新了数据库</p><p>（2）线程B更新了数据库</p><p>（3）线程B更新了缓存</p><p>（4）线程A更新了缓存</p><p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p><p><strong>原因二：业务场景角度</strong></p><p>有如下两点：</p><p>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</p><p>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p><h4 id="4、先更新缓存再更新数据库"><a href="#4、先更新缓存再更新数据库" class="headerlink" title="4、先更新缓存再更新数据库"></a>4、先更新缓存再更新数据库</h4><p>A和B线程并发时无法保证操作的先后顺序，数据和缓存无法保证一致性，而且大概率会产生不一致。<br>同样，在没有任何分布式保证的前提下，绝对不可以使用“先更新缓存，再更新数据库”的操作顺序 。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多版本并发控制</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库MVCC"><a href="#数据库MVCC" class="headerlink" title="数据库MVCC"></a>数据库MVCC</h2><p>MVCC（multiVersion Concurrency Control）多版本并发控制协议</p><p>​    在实际环境中数据库的事务大都是只读的，读请求是写请求的很多倍，如果写请求和读请求之前没有并发控制机制，那么最坏的情况也是读请求读到了已经写入的数据，这对很多应用完全是可以接受的。</p><p><img src="https://img.draveness.me/2017-10-02-multiversion-scheme.png" alt="multiversion-scheme"></p><p>在这种大前提下，数据库系统引入了另一种并发控制机制 - <em>多版本并发控制</em>（Multiversion Concurrency Control），每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回；在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。</p><h3 id="Mysql中MVCC"><a href="#Mysql中MVCC" class="headerlink" title="Mysql中MVCC"></a>Mysql中MVCC</h3><p>MySQL 中实现的多版本两阶段锁协议（Multiversion 2PL）将 MVCC 和 2PL 的优点结合了起来，每一个版本的数据行都具有一个唯一的时间戳，当有读事务请求时，数据库程序会直接从多个版本的数据项中具有最大时间戳的返回。</p><p><img src="https://img.draveness.me/2017-10-02-multiversion-2pl-read.png" alt="multiversion-2pl-read"></p><p>更新操作就稍微有些复杂了，事务会先读取最新版本的数据计算出数据更新后的结果，然后创建一个新版本的数据，新数据的时间戳是目前数据行的最大版本 <code>＋1</code>：</p><p><img src="https://img.draveness.me/2017-10-02-multiversion-2pl-write.png" alt="multiversion-2pl-write"></p><p>数据版本的删除也是根据时间戳来选择的，MySQL 会将版本最低的数据定时从数据库中清除以保证不会出现大量的遗留内容。</p><h3 id="PostgreSQL-与-MVCC"><a href="#PostgreSQL-与-MVCC" class="headerlink" title="PostgreSQL 与 MVCC"></a>PostgreSQL 与 MVCC</h3><p>与 MySQL 中使用悲观并发控制不同，PostgreSQL 中都是使用乐观并发控制的，这也就导致了 MVCC 在于乐观锁结合时的实现上有一些不同，最终实现的叫做多版本时间戳排序协议（Multiversion Timestamp Ordering），在这个协议中，所有的事务在执行之前都会被分配一个唯一的时间戳，每一个数据项都有读写两个时间戳：</p><p><img src="https://img.draveness.me/2017-10-02-dataitem-with-timestamps.png" alt="dataitem-with-timestamps"></p><p>当 PostgreSQL 的事务发出了一个读请求，数据库直接将最新版本的数据返回，不会被任何操作阻塞，而写操作在执行时，事务的时间戳一定要大或者等于数据行的读时间戳，否则就会被回滚。</p><p>这种 MVCC 的实现保证了读事务永远都不会失败并且不需要等待锁的释放，对于读请求远远多于写请求的应用程序，乐观锁加 MVCC 对数据库的性能有着非常大的提升；虽然这种协议能够针对一些实际情况做出一些明显的性能提升，但是也会导致两个问题，一个是每一次读操作都会更新读时间戳造成两次的磁盘写入，第二是事务之间的冲突是通过回滚解决的，所以如果冲突的可能性非常高或者回滚代价巨大，数据库的读写性能还不如使用传统的锁等待方式。</p><p>参考资料：<a href="https://draveness.me/database-concurrency-control/">https://draveness.me/database-concurrency-control/</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跃表</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>为了解决一个有序表查询的问题，发明的跳跃表，为了插入方便选择用链表，但是链表怎么解决查找的问题呢？这就引出我们要介绍的跳跃表</p><p>​    从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数</p><p>为 2 + 4 + 6 &#x3D; 12 次。有没有优化的算法吗?  链表是有序的，但不能使用二分查找。类似二叉</p><p>搜索树，我们把一些节点提取出来，作为索引。得到如下结构：</p><p><img src="https://images0.cnblogs.com/blog2015/408418/201505/151151540794271.jpg" alt="img"></p><p> 这里我们把 &lt; 14, 34, 50, 72 &gt; 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。</p><p>可以再把部分一级索引的数字提取出来成为二级索引</p><h2 id="跳跃表的插入"><a href="#跳跃表的插入" class="headerlink" title="跳跃表的插入"></a>跳跃表的插入</h2><p>先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）</p><p>然后在 Level 1 … Level K 各个层的链表都插入元素。</p><p>例子：插入 119， K &#x3D; 2</p><h2 id="丢硬币决定-K"><a href="#丢硬币决定-K" class="headerlink" title="丢硬币决定 K"></a>丢硬币决定 K</h2><p>插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：</p><h2 id="跳表的高度。"><a href="#跳表的高度。" class="headerlink" title="跳表的高度。"></a>跳表的高度。</h2><p>n 个元素的跳表，每个元素插入的时候都要做一次实验，用来决定元素占据的层数 K，</p><p>跳表的高度等于这 n 次实验中产生的最大 K</p><h2 id="跳表的空间复杂度分析"><a href="#跳表的空间复杂度分析" class="headerlink" title="跳表的空间复杂度分析"></a>跳表的空间复杂度分析</h2><p>根据上面的分析，每个元素的期望高度为 2， 一个大小为 n 的跳表，其节点数目的</p><p>期望值是 2n。本质是以空间换时间</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ARP协议</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/ARP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/ARP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP解决了同一个局域网上的主机和路由器IP和MAC地址的解析。</p><ul><li>每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。 </li><li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。 </li><li>网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。 </li><li>源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。 </li><li>如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引explain的使用</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95explain/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95explain/</url>
    
    <content type="html"><![CDATA[<p>有两个重要的属性，type和extre，type是类型，越左边越好。</p><p><strong>type：</strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</p><p>system是查已经放入内存的系统表</p><p>const命中主键索引并且返回常数值</p><p>eq_ref是命中主键索引或者唯一索引</p><p>ref是命中普通索引</p><p>range是索引上面的范围查询</p><p>index是使用索引的全表查询，和all速度差不多，官网说比all快是因为查出来的数据是有序的吧。</p><p><strong>extra：</strong></p><p><strong>Using where】</strong></p><p><a href="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729090932514-1337263507.png"><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729090932514-1337263507.png" alt="img"></a></p><p><strong>实验语句</strong>：</p><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-symbol">``</span><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>* <span class="hljs-symbol">``</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">user</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">where</span><span class="hljs-symbol">` `</span>sex=<span class="hljs-symbol">``</span><span class="hljs-string">&#x27;no&#x27;</span><span class="hljs-symbol">``</span>;</code></pre><p><strong>结果说明</strong>：</p><p>　　Extra为Using where说明，SQL使用了where条件过滤数据。</p><p>需要注意的是：</p><p>（1）返回所有记录的SQL，不使用where条件过滤数据，大概率不符合预期，对于这类SQL往往需要进行优化；</p><p>（2）使用了where条件的SQL，并不代表不需要优化，往往需要配合explain结果中的type（连接类型）来综合判断；</p><p>　　本例虽然Extra字段说明使用了where条件过滤，但type属性是ALL，表示需要扫描全部数据，仍有优化空间。</p><p>　　常见的优化方法为，在where过滤属性上添加索引。</p><p>画外音：本例中，sex字段区分度不高，添加索引对性能提升有限。*</p><p><strong>二、【Using index】</strong>　　</p><p><a href="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091039527-949770879.png"><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091039527-949770879.png" alt="img"></a></p><p><strong>实验语句</strong>：</p><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-symbol">``</span><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>id,<span class="hljs-symbol">``</span>name<span class="hljs-symbol">` `</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">user</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">where</span><span class="hljs-symbol">` `</span>name<span class="hljs-symbol">``</span>=<span class="hljs-symbol">``</span><span class="hljs-string">&#x27;shenjian&#x27;</span><span class="hljs-symbol">``</span>;</code></pre><p><strong>结果说明</strong>：</p><p>　　Extra为Using index说明，SQL所需要返回的所有列数据均在一棵索引树上，而无需访问实际的行记录。</p><p>　　这类SQL语句往往性能较好。</p><p><strong>问题来了，什么样的列数据，会包含在索引树上呢？</strong></p><p><strong>三、【Using index condition】</strong></p><p><strong>结果说明：</strong></p><p>Extra为Using index condition说明，确实命中了索引，但不是所有的列数据都在索引树上，还需要访问实际的行记录。</p><p><em>画外音：*<em>聚集索引，普通索引的底层实现差异，详见《</em></em><a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961494&idx=1&sn=34f1874c1e36c2bc8ab9f74af6546ec5&chksm=bd2d0d4a8a5a845c566006efce0831e610604a43279aab03e0a6dde9422b63944e908fcc6c05&scene=21#wechat_redirect">1分钟了解MyISAM与InnoDB的索引差异</a>》。*</p><p>这类SQL语句性能也较高，但不如Using index。</p><p><strong>问题来了，如何优化为Using index呢？</strong></p><p>添加聚簇索引，使所有列在索引中。</p><p><strong>四、【Using filesort】</strong></p><p><a href="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091428454-1485068081.png"><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091428454-1485068081.png" alt="img"></a></p><p><strong>实验语句：</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-symbol">``</span><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>* <span class="hljs-symbol">``</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">user</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">order</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">by</span><span class="hljs-symbol">` `</span>sex;</code></pre><p><strong>结果说明：</strong></p><p>　　Extra为Using filesort说明，得到所需结果集，需要对所有记录进行文件排序。</p><p>　　这类SQL语句性能极差，需要进行优化。</p><p>　　典型的，在一个没有建立索引的列上进行了order by，就会触发filesort，常见的优化方案是，在order by的列上添加索引，避免每次查询都全量排序。</p><p><strong>五、【Using temporary】</strong></p><p><a href="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091518732-1550780386.png"><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091518732-1550780386.png" alt="img"></a></p><p><strong>实验语句：</strong></p><pre><code class="hljs autohotkey">explain ``select` `* ``from` `user` `group` `by` `name` `order` `by` `sex<span class="hljs-comment">;</span></code></pre><p><strong>结果说明：</strong></p><p>　　Extra为Using temporary说明，需要建立临时表(temporary table)来暂存中间结果。 </p><p>　　这类SQL语句性能较低，往往也需要进行优化。</p><p>　　典型的，group by和order by同时存在，且作用于不同的字段时，就会建立临时表，以便计算出最终的结果集。</p><p><strong>六、【Using join buffer (Block Nested Loop)】</strong></p><p><a href="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091608174-768087803.png"><img src="https://img2018.cnblogs.com/blog/885859/201907/885859-20190729091608174-768087803.png" alt="img"></a></p><p><strong>实验语句：</strong></p><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-symbol">``</span><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>* <span class="hljs-symbol">``</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">user</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">where</span><span class="hljs-symbol">` `</span>id <span class="hljs-symbol">``</span><span class="hljs-keyword">in</span><span class="hljs-symbol">``</span>(<span class="hljs-symbol">``</span><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>id <span class="hljs-symbol">``</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">user</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">where</span><span class="hljs-symbol">` `</span>sex=<span class="hljs-symbol">``</span><span class="hljs-string">&#x27;no&#x27;</span><span class="hljs-symbol">``</span>);</code></pre><p><strong>结果说明：</strong></p><p>　　Extra为Using join buffer (Block Nested Loop)说明，需要进行嵌套循环计算。</p><p>　　<em>画外音：**内层和外层的type均为ALL，rows均为4，需要循环进行4*4次计算。</em></p><p>　　这类SQL语句性能往往也较低，需要进行优化。</p><p>　　典型的，两个关联表join，关联字段均未建立索引，就会出现这种情况。常见的优化方案是，在关联字段上添加索引，避免每次嵌套循环计算。</p><p><strong>七、使用字符串查找数字索引的列会命中吗</strong></p><p>1、在一次MySQL查询中，某字段为 varchar 字符串类型，传入参数值为 int 数字类型，发现查询的结果和预期的不一致。 如： 某两列 name&#x3D;’11’ , name &#x3D; ‘11aa’ 。 where name &#x3D; 11 ， 可以查到 ‘11’ 和 ‘11aa’ 两个结果，这里是错误的；而 where name &#x3D;’11’ ，能得到预期结果。</p><p>2、反之，字段为 int 数字类型，传入参数值为 varchar 字符串类型，也能查到数据，同样查询的结果和预期的不一致。如：age&#x3D;2的数据有2条。where age &#x3D; 2 ， 可以正常查到数据 ； 而 where age &#x3D; ‘2aabbcc’，查到的数据结果和 where age &#x3D; 2 是一样的，这里是错误的，应该查不到数据。</p><p>结论：</p><p>1、原因： 当MySQL字段类型和传入条件数据类型不一致时，会进行隐形的数据类型转换（MySQL Implicit conversion）</p><p>2、若字符串是以数字开头，且全部都是数字，则转换为数字结果是整个字符串；部分是数字，则转换为数字结果是截止到第一个不是数字的字符为止。 理解： varchar str &#x3D; “123dafa”，转换为数字是123 。 SELECT ‘123dafa’+1 ; — 124 。</p><p>3、若字符串不是以数字开头，则转换为数字结果是 0 。 varchar str &#x3D; “aabb33” ; 转换为数字是 0 。 SELECT ‘aabb33’+100 ; — 100 。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP1.0和2.0的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP1.0%E5%92%8C2.0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP1.0%E5%92%8C2.0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>虽然 HTTP&#x2F;1.1 已经做了大量的优化，但是依然存在很多性能瓶颈，依然不能满足我们日益变化的新需求，所以就有了我们今天要聊的 HTTP&#x2F;2。</p><p>本文我们依然从需求的层面来谈，先分析 HTTP&#x2F;1.1 存在哪些问题，然后再来分析 HTTP&#x2F;2 是如何解决这些问题的。</p><p>我们知道 HTTP&#x2F;1.1 为网络效率做了大量的优化，最核心的有如下三种方式：</p><ul><li>增加了持久连接；</li><li>浏览器为每个域名最多同时维护 6 个 TCP 持久连接；</li><li>使用 CDN 的实现域名分片机制。</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gse5yu77j20vo0u0dha.jpg"></p><p>在该图中，引入了 CDN，并同时为每个域名维护 6 个连接，这样就大大减轻了整个资源的下载时间。这里我们可以简单计算下：如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 100 * n * RTT；若通过上面的技术，就可以把整个时间缩短为 100 * n * RTT&#x2F;(6 * CDN 个数)。从这个计算结果来看，我们的页面加载速度变快了不少。</p><h3 id="HTTP1-1主要问题"><a href="#HTTP1-1主要问题" class="headerlink" title="HTTP1.1主要问题"></a>HTTP1.1主要问题</h3><p>主要问题是Http1.1对带宽的利用率不高</p><h5 id="1、TCP的慢启动"><a href="#1、TCP的慢启动" class="headerlink" title="1、TCP的慢启动"></a>1、TCP的慢启动</h5><p>因为有一些关键数据他本来就不大，慢启动了之后更加显得慢了，推迟了首次渲染的速度。</p><h5 id="2、同时开启了多条-TCP-连接，那么这些连接会竞争固定的带宽。"><a href="#2、同时开启了多条-TCP-连接，那么这些连接会竞争固定的带宽。" class="headerlink" title="2、同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。"></a>2、<strong>同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。</strong></h5><p>你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p><p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p><h5 id="3、队头阻塞问题"><a href="#3、队头阻塞问题" class="headerlink" title="3、队头阻塞问题"></a>3、队头阻塞问题</h5><p>我们知道在 HTTP&#x2F;1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p><p>这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。</p><p>在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。</p><p>但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。</p><h2 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h2><p><strong>HTTP2.0使用多路复用来解决这个问题</strong></p><p>基于此，HTTP&#x2F;2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p><p>另外，就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP&#x2F;2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</p><p>所以，HTTP&#x2F;2 的解决方案可以总结为：一个域名只使用一个 TCP 长连接和消除队头阻塞问题。可以参考下图</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gt484gycj214o0j8acm.jpg"></p><h3 id="多路复用的实现"><a href="#多路复用的实现" class="headerlink" title="多路复用的实现"></a>多路复用的实现</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gt6kaqb9j20u00udjts.jpg"></p><p>从图中可以看出，HTTP&#x2F;2 添加了一个二进制分帧层，那我们就结合图来分析下 HTTP&#x2F;2 的请求和接收过程。</p><ul><li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li><li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li><li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li><li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li><li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li><li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求</li></ul><p>从上面的流程可以看出，通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。</p><p>上一篇文章我们介绍过，HTTP 是浏览器和服务器通信的语言，在这里虽然 HTTP&#x2F;2 引入了二进制分帧层，不过 HTTP&#x2F;2 的语义和 HTTP&#x2F;1.1 依然是一样的，也就是说它们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收到什么类型的文件，依然可以使用 Cookie 来保持登录状态，依然可以使用 Cache 来缓存本地文件，这些都没有变，发生改变的只是传输方式。这一点对开发者来说尤为重要，这意味着我们不需要为 HTTP&#x2F;2 去重建生态，并且 HTTP&#x2F;2 推广起来会也相对更轻松了</p><h2 id="HTTP-x2F-2其他特性"><a href="#HTTP-x2F-2其他特性" class="headerlink" title="HTTP&#x2F;2其他特性"></a>HTTP&#x2F;2其他特性</h2><p>通过上面的分析，我们知道了多路复用是 HTTP&#x2F;2 的最核心功能，它能实现资源的并行传输。多路复用技术是建立在二进制分帧层的基础之上。其实基于二进制分帧层，HTTP&#x2F;2 还附带实现了很多其他功能，下面我们就来简要了解下。</p><h4 id="1-可以设置请求的优先级"><a href="#1-可以设置请求的优先级" class="headerlink" title="1. 可以设置请求的优先级"></a>1. 可以设置请求的优先级</h4><p>我们知道浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。</p><p>为了解决这个问题，HTTP&#x2F;2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p><h4 id="2-服务器推送"><a href="#2-服务器推送" class="headerlink" title="2. 服务器推送"></a>2. 服务器推送</h4><p>除了设置请求的优先级外，HTTP&#x2F;2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p><h4 id="3-头部压缩"><a href="#3-头部压缩" class="headerlink" title="3. 头部压缩"></a>3. 头部压缩</h4><p>无论是 HTTP&#x2F;1.1 还是 HTTP&#x2F;2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP&#x2F;2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。</p><p>参考资料：<a href="https://blog.poetries.top/browser-working-principle/guide/part6/lesson30.html#_2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81">https://blog.poetries.top/browser-working-principle/guide/part6/lesson30.html#_2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC和HTTP接口的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/RPC%E5%92%8CHTTP%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/RPC%E5%92%8CHTTP%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是RPC协议？"><a href="#什么是RPC协议？" class="headerlink" title="什么是RPC协议？"></a>什么是RPC协议？</h2><p>RPC是一种远程过程调用的协议，使用这种协议向另一台计算机上的程序请求服务，不需要了解底层网络技术的协议。<br>在 RPC 中，发出请求的程序是客户程序，而提供服务的程序是服务器。<br>HTTP是一种超文本传输协议。是WWW浏览器和WWW服务器之间的应用层通讯协议。</p><h2 id="RPC协议与HTTP协议的区别"><a href="#RPC协议与HTTP协议的区别" class="headerlink" title="RPC协议与HTTP协议的区别"></a>RPC协议与HTTP协议的区别</h2><p>RPC是一种API，HTTP是一种无状态的网络协议。RPC可以基于HTTP协议实现，也可以直接在TCP协议上实现。<br>RPC主要是用在大型网站里面，因为大型网站里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。<br>HTTP主要是用在中小型企业里面，业务线没那么繁多的情况下。 3、HTTP开发方便简单、直接。开发一个完善的RPC框架难度比较大。<br>HTTP发明的初衷是为了传送超文本的资源，协议设计的比较复杂，参数传递的方式效率也不高。开源的RPC框架针对远程调用协议上的效率会比HTTP快很多。<br>HTTP需要事先通知，修改Nginx&#x2F;HAProxy配置。RPC能做到自动通知，不影响上游。<br>HTTP大部分是通过Json来实现的，字节大小和序列化耗时都比Thrift要更消耗性能。RPC，可以基于Thrift实现高效的二进制传输。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>粘包与拆包</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E7%B2%98%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E7%B2%98%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="粘包与拆包"><a href="#粘包与拆包" class="headerlink" title="粘包与拆包"></a>粘包与拆包</h2><h3 id="粘包发生场景"><a href="#粘包发生场景" class="headerlink" title="粘包发生场景"></a>粘包发生场景</h3><p>因为TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。</p><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nb933r31j213t0u0ac6.jpg"></p><p>上图中演示了以下几种情况：</p><ul><li>正常的理想情况，两个包恰好满足TCP缓冲区的大小或达到TCP等待时长，分别发送两个包；</li><li>粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送；</li><li>拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送；</li><li>拆包和粘包：Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理。</li></ul><h3 id="粘包拆包解决办法"><a href="#粘包拆包解决办法" class="headerlink" title="粘包拆包解决办法"></a>粘包拆包解决办法</h3><p>1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p><p>2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p><p>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。（FTP协议）</p><h4 id="为什么UDP没有粘包"><a href="#为什么UDP没有粘包" class="headerlink" title="为什么UDP没有粘包"></a>为什么UDP没有粘包</h4><p>​    由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http3</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/http3/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/http3/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h1><p>网络迁移需要重新连接<br>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WIFI。</p><p>这些问题都是 TCP 协议固有的问题，无论应用层的 HTTP&#x2F;2 在怎么设计都无法逃脱。要解决这个问题，就必须把传输层协议替换成 UDP，这个大胆的决定，HTTP&#x2F;3 做了！</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h36nocclm9j21bw0u077j.jpg"></p><h4 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3j4fhk5v3j20jg0e0gn5.jpg"></p><p>QUIC引入了连接上的多路流复用的概念。QUIC通过设计实现了单独的、针对每个流的流控，解决了整个连接的行头阻塞问题。</p><p>QUIC使用增强的丢失恢复机制和转发纠错功能，以更好地处理错误数据包。该功能对于那些只能通过缓慢的无线网络访问互联网的用户来说是一个福音，因为这些网络用户在传输过程中经常出现高错误率。</p><p>更快的握手。QUIC使用相同的TLS模块进行安全连接。然而，与TCP不同的是，QUIC的握手机制经过优化，避免了每次两个已知的对等者之间建立通信时的冗余协议交换</p><h3 id="更快的连接建立"><a href="#更快的连接建立" class="headerlink" title="更快的连接建立"></a>更快的连接建立</h3><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p><p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p><p>如下图右边部分，HTTP&#x2F;3 当会话恢复时，有效负载数据与第一个数据包一起发送，可以做到 0-RTT：</p><h3 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h3><p>在前面我们提到，基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接，而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。</p><p><img src="https://pic1.zhimg.com/v2-c13b3c2513e7b9edc98c28f5232ccb88_b.webp"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/bf399e5cb48cadacb7008d47f7dc39c5.gif"></p><p>TCP从来就不适合处理有损无线环境中的数据传输。在互联网的早期，有线网络将网络中的每一台计算机连接起来。</p><p>现在，随着智能手机和便携式设备的数量超过台式机和笔记本电脑的数量，超过50%的互联网流量已经通过无线传输。这种趋势给整体的网络浏览体验带来了问题，其中最重要的是在无线覆盖率不足的情况下，TCP中的行头阻塞。</p><p>QUIC 协议的特点：</p><p>无队头阻塞，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，也不会有底层协议限制，某个流发生丢包了，只会影响该流，其他流不受影响；<br>建立连接速度快，因为 QUIC 内部包含 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。<br>连接迁移，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；</p><h3 id="HTTP-x2F-3-协议"><a href="#HTTP-x2F-3-协议" class="headerlink" title="HTTP&#x2F;3 协议"></a>HTTP&#x2F;3 协议</h3><p>了解完 QUIC 协议的特点后，我们再来看看 HTTP&#x2F;3 协议在 HTTP 这一层做了什么变化。</p><p>HTTP&#x2F;3 同 HTTP&#x2F;2 一样采用二进制帧的结构，不同的地方在于 HTTP&#x2F;2 的二进制帧里需要定义 Stream，而 HTTP&#x2F;3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream，于是 HTTP&#x2F;3 的帧的结构也变简单了。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h3j4x5m374j21bz0geju3.jpg"></p><p>从上图可以看到，HTTP&#x2F;3 帧头只有两个字段：类型和长度。</p><p>根据帧类型的不同，大体上分为数据帧和控制帧两大类，HEADERS 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。</p><p>HTTP&#x2F;3 在头部压缩算法这一方便也做了升级，升级成了 QPACK。与 HTTP&#x2F;2 中的 HPACK 编码方式相似，HTTP&#x2F;3 中的 QPACK 也采用了静态表、动态表及 Huffman 编码。</p><p>对于静态表的变化，HTTP&#x2F;2 中的 HPACK 的静态表只有 61 项，而 HTTP&#x2F;3 中的 QPACK 的静态表扩大到 91 项。</p><p>HTTP&#x2F;2 和 HTTP&#x2F;3 的 Huffman 编码并没有多大不同，但是动态表编解码方式不同。</p><p>所谓的动态表，在首次请求-响应后，双方会将未包含在静态表中的 Header 项更新各自的动态表，接着后续传输时仅用 1 个数字表示，然后对方可以根据这 1 个数字从动态表查到对应的数据，就不必每次都传输长长的数据，大大提升了编码效率。</p><p>可以看到，动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来。</p><p>HTTP&#x2F;3 的 QPACK 解决了这一问题，那它是如何解决的呢？</p><p>QUIC 会有两个特殊的单向流，所谓的单项流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，这两个单向流的用法：</p><p>一个叫 QPACK Encoder Stream， 用于将一个字典（key-value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；<br>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。<br>这两个特殊的单向流是用来同步双方的动态表，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>​    举个例子，一个被装饰与多种装饰物，多个装饰物层层嵌套的，举个例子，一个人是被装饰物，衣服，裤子，鞋子，是装饰物，先给人装饰衣服，可以自己选白色衣服，然后用白色裤子装饰穿着白色衣服的人，再用黑色鞋子装饰穿着白色衣服白色鞋子的人，这个装饰关系的嵌套关系。</p><p>​    使用场景是需要添加新功能，但是旧功能全部保留，就可以用装饰模式来设计。好处是把类的核心模块和装饰模块分开了，去除相关类中重复的部分。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的六个原则</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E4%B8%AA%E5%8E%9F%E5%88%99/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E4%B8%AA%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><p>一个类或者接口只负责唯一职责，尽量设计出单一功能的接口</p><p>给一个类加上各种各样的功能，这就意味着无论任何需求来，都要更改这个类，这很糟糕，维护麻烦，复用更加不可能，也缺乏灵活性。</p><h3 id="2、依赖倒转原则"><a href="#2、依赖倒转原则" class="headerlink" title="2、依赖倒转原则"></a>2、依赖倒转原则</h3><p>高层模块不应该依赖低层模块具体实现，解耦高层和低层，既面向接口编程，当发送变化时，只需要提供新的实现类，不需要修改高层代码</p><p><strong>（1）高层模块不应该依赖于低层模块，两个都应该依赖于抽象</strong></p><p><strong>（2）抽象不应该依赖细节，细节应该依赖于抽象</strong></p><h3 id="3、开放封闭原则"><a href="#3、开放封闭原则" class="headerlink" title="3、开放封闭原则"></a>3、开放封闭原则</h3><p>程序对外扩展开放，对修改关闭，当需求发生变化时，我们可以通过添加新模块来满足新需求，而不是通过修改原来的实现代码来满足新的需求。</p><h3 id="4、迪米特法则（最小知识原则）"><a href="#4、迪米特法则（最小知识原则）" class="headerlink" title="4、迪米特法则（最小知识原则）"></a>4、迪米特法则（最小知识原则）</h3><p>一个软件实体应当尽可能的少与其他实体发生相互作用，每一个软件单位对其他软件单位都只有最少知识</p><h3 id="5、接口隔离原则"><a href="#5、接口隔离原则" class="headerlink" title="5、接口隔离原则"></a>5、接口隔离原则</h3><p>客户端不应该依赖他不需要的接口，类间的依赖关系应建立在最小的接口上。</p><h4 id="接口隔离原则的优点"><a href="#接口隔离原则的优点" class="headerlink" title="接口隔离原则的优点"></a>接口隔离原则的优点</h4><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p><ol><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ol><h3 id="6、里式替换原则"><a href="#6、里式替换原则" class="headerlink" title="6、里式替换原则"></a>6、里式替换原则</h3><p>任何基类可以出现的地方，子类一定可以出现，里式代换原则是继承复用的基石。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>channel</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/channal/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/channal/</url>
    
    <content type="html"><![CDATA[<h4 id="往一个关闭的channal里面接收数据能够接收到吗"><a href="#往一个关闭的channal里面接收数据能够接收到吗" class="headerlink" title="往一个关闭的channal里面接收数据能够接收到吗"></a>往一个关闭的channal里面接收数据能够接收到吗</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)ch &lt;- <span class="hljs-number">1</span><span class="hljs-built_in">close</span>(ch)fmt.Println(&lt;-ch)fmt.Println(&lt;-ch)ch &lt;- <span class="hljs-number">1</span>&#125;</code></pre><p>可以，但是从channal里面拿就会panic</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1、能使用无缓存的channal做mutex吗"><a href="#1、能使用无缓存的channal做mutex吗" class="headerlink" title="1、能使用无缓存的channal做mutex吗"></a>1、能使用无缓存的channal做mutex吗</h3><p>虽然没有缓存，但是可以有一个放入，多个放出，放出可以抽象成争抢锁</p><p>1、设置一个goroutine，专门来放入，因为没有拿就阻塞了，如果有人拿就退出</p><p>2、有人拿了，没有被阻塞，说明拿到锁了，开始执行任务，然后执行完的时候重新启动一个goroutine来放入锁，等待下一个拿到锁的人。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Context</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/context/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/context/</url>
    
    <content type="html"><![CDATA[<h4 id="Context有什么作用"><a href="#Context有什么作用" class="headerlink" title="Context有什么作用"></a>Context有什么作用</h4><p>其主要的作用是在 goroutine 中进行上下文的传递，而在传递信息中又包含了 goroutine 的运行控制、上下文信息传递等功能。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h57e9igvnkj21lc0cqwga.jpg"></p><p>例如在业务的高峰期，某个下游服务的响应变慢，而当前系统的请求又没有超时控制，或者超时时间设置地过大，那么等待下游服务返回数据的协程就会越来越多。而我们知道，协程是要消耗系统资源的，后果就是协程数激增，内存占用飙涨，甚至导致服务不可用。更严重的会导致雪崩效应，整个服务对外表现为不可用，这肯定是 P0 级别的事故。</p><p>但是在某些场景下，例如处理一个请求衍生了很多协程，这些协程之间是相互关联的：需要共享一些全局变量、有共同的 deadline 等，而且可以同时被关闭。再用 <code>channel+select</code> 就会比较麻烦，这时就可以通过 context 来实现。</p><p>一句话：context 用来解决 goroutine 之间<code>退出通知</code>、<code>元数据传递</code>的功能。</p><h3 id="context获取key的方式"><a href="#context获取key的方式" class="headerlink" title="context获取key的方式"></a>context获取key的方式</h3><ul><li>上面的例子我们获取<code>trace_id</code>是直接从当前<code>ctx</code>获取的，实际我们也可以获取父<code>context</code>中的<code>value</code>，在获取键值对是，我们先从当前<code>context</code>中查找，没有找到会在从父<code>context</code>中查找该键对应的值直到在某个父<code>context</code>中返回 <code>nil</code> 或者查找到对应的值。</li><li><code>context</code>传递的数据中<code>key</code>、<code>value</code>都是<code>interface</code>类型，这种类型编译期无法确定类型，所以不是很安全，所以在类型断言时别忘了保证程序的健壮性。</li></ul><h3 id="使用Context来控制协程"><a href="#使用Context来控制协程" class="headerlink" title="使用Context来控制协程"></a>使用Context来控制协程</h3><p>1、控制单个协程，context.WithCancel</p><pre><code class="hljs sqf">func reqTask(ctx context.Context, <span class="hljs-built_in">name</span> string) &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-built_in">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ctx.Done():fmt.Println(<span class="hljs-string">&quot;stop&quot;</span>, <span class="hljs-built_in">name</span>)return<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-built_in">name</span>, <span class="hljs-string">&quot;send request&quot;</span>)<span class="hljs-built_in">time</span>.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1</span> * <span class="hljs-built_in">time</span>.Second)&#125;&#125;&#125;func main() &#123;ctx, cancel := context.WithCancel(context.Background())go reqTask(ctx, <span class="hljs-string">&quot;worker1&quot;</span>)<span class="hljs-built_in">time</span>.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * <span class="hljs-built_in">time</span>.Second)cancel()<span class="hljs-built_in">time</span>.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * <span class="hljs-built_in">time</span>.Second)&#125;</code></pre><p>2、控制多个协程（多个协程间的同步）</p><pre><code class="hljs css">func <span class="hljs-selector-tag">main</span>() &#123;ctx, cancel := context.<span class="hljs-built_in">WithCancel</span>(context.<span class="hljs-built_in">Background</span>())go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker1&quot;</span>)go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker2&quot;</span>)time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)<span class="hljs-built_in">cancel</span>()time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)&#125;</code></pre><p>3、ctx 传递值，context.WithValue</p><pre><code class="hljs maxima">type Options struct&#123; Interval <span class="hljs-built_in">time</span>.Duration &#125;func reqTask(ctx <span class="hljs-built_in">context</span>.Context, name <span class="hljs-built_in">string</span>) &#123;<span class="hljs-keyword">for</span> &#123;select &#123;case &lt;-ctx.Done():fmt.Println(<span class="hljs-string">&quot;stop&quot;</span>, name)<span class="hljs-built_in">return</span>default:fmt.Println(name, <span class="hljs-string">&quot;send request&quot;</span>)<span class="hljs-built_in">op</span> := ctx.Value(<span class="hljs-string">&quot;options&quot;</span>).(*Options)<span class="hljs-built_in">time</span>.Sleep(<span class="hljs-built_in">op</span>.Interval * <span class="hljs-built_in">time</span>.Second)&#125;&#125;&#125;func main() &#123;ctx, cancel := <span class="hljs-built_in">context</span>.WithCancel(<span class="hljs-built_in">context</span>.Background())vCtx := <span class="hljs-built_in">context</span>.WithValue(ctx, <span class="hljs-string">&quot;options&quot;</span>, &amp;Options&#123;<span class="hljs-number">1</span>&#125;)<span class="hljs-built_in">go</span> reqTask(vCtx, <span class="hljs-string">&quot;worker1&quot;</span>)<span class="hljs-built_in">go</span> reqTask(vCtx, <span class="hljs-string">&quot;worker2&quot;</span>)<span class="hljs-built_in">time</span>.Sleep(<span class="hljs-number">3</span> * <span class="hljs-built_in">time</span>.Second)cancel()<span class="hljs-built_in">time</span>.Sleep(<span class="hljs-number">3</span> * <span class="hljs-built_in">time</span>.Second)&#125;</code></pre><p>4、控制执行时间，context.WithTimeout</p><pre><code class="hljs css">func <span class="hljs-selector-tag">main</span>() &#123;ctx, cancel := context.<span class="hljs-built_in">WithTimeout</span>(context.<span class="hljs-built_in">Background</span>(), <span class="hljs-number">2</span>*time.Second)go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker1&quot;</span>)go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker2&quot;</span>)time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)fmt.<span class="hljs-built_in">Println</span>(<span class="hljs-string">&quot;before cancel&quot;</span>)<span class="hljs-built_in">cancel</span>()time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)&#125;</code></pre><p>5、根据时间点来决定退出，context.WithDeadline</p><pre><code class="hljs css">func reqTask(ctx context<span class="hljs-selector-class">.Context</span>, name string) &#123;for &#123;select &#123;case &lt;-ctx<span class="hljs-selector-class">.Done</span>():fmt.<span class="hljs-built_in">Println</span>(<span class="hljs-string">&quot;stop&quot;</span>, name, ctx.<span class="hljs-built_in">Err</span>())returndefault:fmt.<span class="hljs-built_in">Println</span>(name, <span class="hljs-string">&quot;send request&quot;</span>)time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1</span> * time.Second)&#125;&#125;&#125;func <span class="hljs-selector-tag">main</span>() &#123;ctx, cancel := context.<span class="hljs-built_in">WithDeadline</span>(context.<span class="hljs-built_in">Background</span>(), time.<span class="hljs-built_in">Now</span>().<span class="hljs-built_in">Add</span>(<span class="hljs-number">1</span>*time.Second))go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker1&quot;</span>)go <span class="hljs-built_in">reqTask</span>(ctx, <span class="hljs-string">&quot;worker2&quot;</span>)time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)fmt.<span class="hljs-built_in">Println</span>(<span class="hljs-string">&quot;before cancel&quot;</span>)<span class="hljs-built_in">cancel</span>()time.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">3</span> * time.Second)&#125;</code></pre><p><code>WithTimeout</code>，带有超时时间的cancelCtx的Context，它是WithDeadline的封装，只不过WithTimeout为时间间隔，Deadline为时间点。</p><p>参考文章：<a href="https://geektutu.com/post/quick-go-context.html">https://geektutu.com/post/quick-go-context.html</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang GC</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%20GC/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%20GC/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-的垃圾回收"><a href="#Golang-的垃圾回收" class="headerlink" title="Golang 的垃圾回收"></a>Golang 的垃圾回收</h1><h2 id="Golang1-0-标记清除算法"><a href="#Golang1-0-标记清除算法" class="headerlink" title="Golang1.0 标记清除算法"></a>Golang1.0 标记清除算法</h2><p>串行的标记清除算法，会导致长时间stw（stop the world）时间，造成资源浪费。</p><h2 id="Golang-1-5三色标记法"><a href="#Golang-1-5三色标记法" class="headerlink" title="Golang 1.5三色标记法"></a>Golang 1.5三色标记法</h2><p>Go的垃圾收集的整个过程可以分成标记准备、标记、标记终止和清除四个不同阶段</p><p>​    Golang 使用三色标记法，开始每个事件都是白色，扫描到一个进程，标记为灰色，就把他丢入队列，每次从队列取出来一个，从这个事件的开始遍历这个事件引出的其他事件，然后把这个事件标记成黑色，有bfs那味，不会重新遍历黑色的事件，直到灰色事件队列没事件了，清除白色事件。</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>因为程序与标记是并发运行的，可能这个事件已经是黑色的还会引出事件，这个时候新事件还是白色，会被清除，这个时候加入写屏障，约定在清扫开始前黑色事件不引出其他事件</p><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：</p><ul><li>强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li><li>弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径</li></ul><h4 id="插入写屏障"><a href="#插入写屏障" class="headerlink" title="插入写屏障"></a>插入写屏障</h4><p>Dijkstra 在 1978 年提出了插入写屏障，通过如下所示的写屏障，用户程序和垃圾收集器可以在交替工作的情况下保证程序执行的正确性：</p><pre><code class="hljs go">writePointer(slot, ptr):    shade(ptr)    *slot = ptr</code></pre><p>上述插入写屏障的伪代码非常好理解，每当执行类似 <code>*slot = ptr</code> 的表达式时，我们会执行上述写屏障通过 <code>shade</code> 函数尝试改变指针的颜色。如果 <code>ptr</code> 指针是白色的，那么该函数会将该对象设置成灰色，其他情况则保持不变。</p><p><img src="https://img.draveness.me/2020-03-16-15843705141840-dijkstra-insert-write-barrier.png" alt="dijkstra-insert-write-barrier"></p><p><strong>图 7-29 Dijkstra 插入写屏障</strong></p><p>假设我们在应用程序中使用 Dijkstra 提出的插入写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p><ol><li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</li><li>用户程序修改 A 对象的指针，将原本指向 B 对象的指针指向 C 对象，这时触发写屏障将 C 对象标记成灰色；</li><li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；</li></ol><p>Dijkstra 的插入写屏障是一种相对保守的屏障技术，它会将<strong>有存活可能的对象都标记成灰色</strong>以满足强三色不变性。在如上所示的垃圾收集过程中，实际上不再存活的 B 对象最后没有被回收；而如果我们在第二和第三步之间将指向 C 对象的指针改回指向 B，垃圾收集器仍然认为 C 对象是存活的，这些被错误标记的垃圾对象只有在下一个循环才会被回收。</p><p>插入式的 Dijkstra 写屏障虽然实现非常简单并且也能保证强三色不变性，但是它也有明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之间做出权衡。</p><h4 id="删除写屏障"><a href="#删除写屏障" class="headerlink" title="删除写屏障"></a>删除写屏障</h4><p>Yuasa 在 1990 年的论文 Real-time garbage collection on general-purpose machines 中提出了删除写屏障，因为一旦该写屏障开始工作，它会保证开启写屏障时堆上所有对象的可达，所以也被称作快照垃圾收集（Snapshot GC）<a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:10">10</a>：</p><blockquote><p>This guarantees that no objects will become unreachable to the garbage collector traversal all objects which are live at the beginning of garbage collection will be reached even if the pointers to them are overwritten.</p></blockquote><p>该算法会使用如下所示的写屏障保证增量或者并发执行垃圾收集时程序的正确性：</p><pre><code class="hljs go">writePointer(slot, ptr)    shade(*slot)    *slot = ptr</code></pre><p>上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。</p><p><img src="https://img.draveness.me/2021-01-02-16095599123266-yuasa-delete-write-barrier.png" alt="yuasa-delete-write-barrier"></p><p><strong>图 7-29 Yuasa 删除写屏障</strong></p><p>假设我们在应用程序中使用 Yuasa 提出的删除写屏障，在一个垃圾收集器和用户程序交替运行的场景中会出现如上图所示的标记过程：</p><ol><li>垃圾收集器将根对象指向 A 对象标记成黑色并将 A 对象指向的对象 B 标记成灰色；</li><li>用户程序将 A 对象原本指向 B 的指针指向 C，触发删除写屏障，但是因为 B 对象已经是灰色的，所以不做改变；</li><li><strong>用户程序将 B 对象原本指向 C 的指针删除，触发删除写屏障，白色的 C 对象被涂成灰色</strong>；</li><li>垃圾收集器依次遍历程序中的其他灰色对象，将它们分别标记成黑色；</li></ol><p>GC触发条件：</p><p>1、长时间（2分钟）没GC，就GC一次</p><p>2、内存分配到一定比例，或者堆内存占用比上次增加了100%</p><p>3、手动</p><h4 id="标记好之后是怎么回收内存的"><a href="#标记好之后是怎么回收内存的" class="headerlink" title="标记好之后是怎么回收内存的"></a>标记好之后是怎么回收内存的</h4><p>​    标记完之后会扫描堆栈中每一个对象，如果不是黑色就把对象清空，并且用链表把每一个空闲空间链接起来。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go为什么不支持可重入锁</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="可重入锁是什么"><a href="#可重入锁是什么" class="headerlink" title="可重入锁是什么"></a>可重入锁是什么</h2><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&#123;     Lock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> Lock();     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span>()</span>&#123;         <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();         ...........;         methodB();         ...........;         <span class="hljs-keyword">lock</span>.unlock();     &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span>()</span>&#123;         <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();         ...........;         <span class="hljs-keyword">lock</span>.unlock();     &#125;&#125;</code></pre><p>当A方法获取lock锁去锁住一段需要做原子性操作的B方法时，如果这段B方法又需要锁去做原子性操作，那么A方法就必定要与B方法出现死锁。这种会出现问题的重入一把锁的情况，叫不可重入锁。</p><p>A方法需要等B方法执行完才能解锁，但是B方法想执行完代码又必须要lock锁来加锁。A的锁未解锁前，其他代码块无法使用此锁来加锁。这是由这个不可重入锁决定的。</p><h2 id="为什么Go没有可重入锁"><a href="#为什么Go没有可重入锁" class="headerlink" title="为什么Go没有可重入锁"></a>为什么Go没有可重入锁</h2><p>如果当你的代码需要重入锁时，那就说明你的代码有问题了，我们正常写代码时，从入口函数开始，执行的层次都是一层层往下的，如果有一个锁需要共享给几个函数，那么就在调用这几个函数的上面，直接加上互斥锁就好了，不需要在每一个函数里面都添加锁，再去释放锁。</p><pre><code class="hljs scss">func <span class="hljs-built_in">call</span>()&#123;  <span class="hljs-built_in">F</span>()  <span class="hljs-built_in">G</span>()&#125;func <span class="hljs-built_in">F</span>() &#123;      mu<span class="hljs-selector-class">.Lock</span>()      ... do some stuff      mu<span class="hljs-selector-class">.Unlock</span>()&#125;func <span class="hljs-built_in">g</span>() &#123;     ... do some stuff ...&#125;func <span class="hljs-built_in">G</span>() &#123;     mu<span class="hljs-selector-class">.Lock</span>()     <span class="hljs-built_in">g</span>()     mu<span class="hljs-selector-class">.Unlock</span>()&#125;</code></pre><p>这样不仅避免了死锁，而且还对代码进行了解耦。这样的代码按照作用范围进行了分层，就像金字塔一样，上层调用下层的函数，越往上作用范围越大；各层有自己的锁。</p><p>总结：<code>Go</code>语言中完全没有必要使用可重入锁，如果我们发现我们的代码要使用到可重入锁了，那一定是我们写的代码有问题了，请检查代码结构，修改他！！！</p><p>在单线程的测试中，无法发现bug。可重入锁无法保护invariant，是可能导致大问题的。</p><p><strong>使用可重入锁是一种彻彻底底的错误，它是bug的温床</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要使用通信的方式来实现共享内存</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用通信的方式来实现共享内存"><a href="#为什么要使用通信的方式来实现共享内存" class="headerlink" title="为什么要使用通信的方式来实现共享内存"></a>为什么要使用通信的方式来实现共享内存</h2><p>GO 的 channal 底层还是使用共享内存的方式进行通信，抽象层面上在共享内存上面一层，在内部处理了线程竞争（CAS指令）、内存管理等内容，适用于更多场景。</p><p><strong>总结：</strong></p><ol><li>首先，使用发送消息来同步信息相比于直接使用共享内存和互斥锁是一种更高级的抽象，使用更高级的抽象能够为我们在程序设计上提供更好的封装，让程序的逻辑更加清晰；</li><li>其次，消息发送在解耦方面与共享内存相比也有一定优势，我们可以将线程的职责分成生产者和消费者，并通过消息传递的方式将它们解耦，不需要再依赖共享内存；</li><li>最后，Go 语言选择消息发送的方式，通过保证同一时间只有一个活跃的线程能够访问数据，能够从设计上天然地避免线程竞争和数据冲突的问题；</li></ol><p>说明在chanel维护所有被该chanel阻塞的协程（读，写各一双向链表）来保证有资源的时候只唤醒一个协程来避免竞争之类的</p><p>从架构上来讲，降低共享内存的使用，本来就是解耦和的重要手段之一，举几个例子</p><p>golang建议使用channel来共享信息而不是使用共享内存，这是一种优雅的方式，避免了数据同步带来的繁琐和低效。</p><p>往大了说，本质上还是让资源去调度请求，而不是让请求去调度资源。</p><p>资源就那么多，所有请求有序使用资源的方式就是通信的方式，反过来，为每个请求虚拟出它独占资源的假象，那就是共享的方式。两种截然不同的方式，差异体现在仲裁成本，这个成本决定了它们承载并发的能力。</p><p>参考文章：<a href="https://draveness.me/whys-the-design-communication-shared-memory/">https://draveness.me/whys-the-design-communication-shared-memory/</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang Mutex</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E9%94%81/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p><strong>我们先来看怎么实现一个最简单的互斥锁，在开始之前可以先想一想，如果是你，你会怎么设计呢？</strong></p><p><strong>你可能会想到，可以通过一个 flag 变量，标记当前的锁是否被某个 goroutine 持有。如果这个 flag 的值是 1，就代表锁已经被持有，那么其它竞争的 goroutine 只能等待；如果这个 flag 的值是 0，就可以通过 CAS（compare-and-swap，或者 compare-and-set）将这个 flag 设置为 1，标识锁被当前的这个 goroutine 持有了。</strong></p><p><strong>整个逻辑很简单，但事实上早期的 Mutex 就是这么设计的，不过在看源码之前我们需要先了解一下什么是 CAS，它非常重要。</strong></p><h4 id="CAS-是什么"><a href="#CAS-是什么" class="headerlink" title="CAS 是什么"></a>CAS 是什么</h4><p><strong>假设有一个块内存，里面存储的值是 a，但是现在想将其变成 a + b，这个时候需要经历哪几步呢？</strong></p><ul><li><code>将存储的值读取出来，得到 a</code></li><li><code>将 a 和 b 进行加法运算，得到 a + b</code></li><li><code>再将计算后的新值 a + b 写回到原来的内存中，也就是将原来的值 a 给更新掉</code></li></ul><p><strong>单线程的话是没有任何问题的，但如果是多个线程同时操作这块内存呢？显然可能会出问题。因此需要通过 CAS 解决这一点，首先它会将内存中原本的值备份一份，运算之后会比较此时内存的值和备份的值，如果一致才进行更新，如果不一致则什么也不做。比如一开始内存的值是 a，备份一份，然后计算完毕之后发现内存的值变成了 a1，前后不一致，说明其它线程已经将这块内存的值给修改了，那么此时就不会再更新了；如果一致，说明没有别的线程修改这个内存的数据，那么此时才会更新。</strong></p><blockquote><p><strong>所以 CAS 的名字很直观，就是先比较、然后再决定是否更新（设置），并且整体是原子性的。</strong></p></blockquote><p><strong>CAS 是实现互斥锁和并发原语的基础，我们有必要掌握它。</strong></p><h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p>这是sync包的互斥锁，加了之后不需要其他goroutine读取，只允许这个读取</p><p>加锁是原语操作</p><p>当goutine超过1ms因为锁请求不到资源的时候，会变成饥饿模式，下次允许优先获得锁。</p><h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><p>这个sync包的读写锁，加了之后运行其他goroutine读，不允许其他进程写</p><p>参考文档：<a href="https://www.cnblogs.com/traditional/p/11894550.html">https://www.cnblogs.com/traditional/p/11894550.html</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oauth2</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/oauth/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/oauth/</url>
    
    <content type="html"><![CDATA[<h2 id="Oauth2是什么？"><a href="#Oauth2是什么？" class="headerlink" title="Oauth2是什么？"></a>Oauth2是什么？</h2><p>概念：oauth2是一个开放标准的授权协议</p><h3 id="OAuth中的角色"><a href="#OAuth中的角色" class="headerlink" title="OAuth中的角色"></a>OAuth中的角色</h3><p>OAuth 2 标准中定义了以下几种角色：</p><ul><li>资源所有者（Resource Owner）</li><li>资源服务器（Resource Server）</li><li>授权服务器（Authorization Server）</li><li>客户端（Client）</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gn2t38nqj219s0u0diw.jpg"></p><ol><li>Authrization Request<br>客户端向用户请求对资源服务器的<code>authorization grant</code>。</li><li>Authorization Grant（Get）<br>如果用户授权该次请求，客户端将收到一个<code>authorization grant</code>。</li><li>Authorization Grant（Post）<br>客户端向授权服务器发送它自己的客户端身份标识和上一步中的<code>authorization grant</code>，请求访问令牌。</li><li>Access Token（Get）<br>如果客户端身份被认证，并且<code>authorization grant</code>也被验证通过，授权服务器将为客户端派发<code>access token</code>。授权阶段至此全部结束。</li><li>Access Token（Post &amp;&amp; Validate）<br>客户端向资源服务器发送<code>access token</code>用于验证并请求资源信息。</li><li>Protected Resource（Get）<br>如果<code>access token</code>验证通过，资源服务器将向客户端返回资源信息。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么python慢</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%B8%BA%E4%BB%80%E4%B9%88python%E6%85%A2/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%B8%BA%E4%BB%80%E4%B9%88python%E6%85%A2/</url>
    
    <content type="html"><![CDATA[<p>​    </p><p>以下是最主要的原因：</p><ul><li>“它是GIL（Global Interpreter Lock全局解释器锁）”</li><li>“它是解释型语言而非编译语言”</li><li>“它是动态类型语言”</li></ul><p>那么以上哪种原因对性能影响最大呢？</p><p><strong>“它是全局解释器锁”</strong></p><h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p>当CPython创建变量时，它会预先分配存储空间，然后计算当前变量的引用数目。这个概念被称为引用计数。如果引用计数为零，那么它将从系统中释放对应存储区域。</p><p>这就是为什么在CPython中创造“临时”变量不会使应用占用大量的存储空间——尤其是当应用中使用了for循环这一类可能大量创建“临时”变量的结构时。</p><p>当存在多个线程调用变量时，CPython如何锁住引用计数成为了一个挑战。而“全局解释锁”应运而生，它能够谨慎控制线程的执行。无论有多少的线程，解释器每次只能执行一个操作。</p><p>这对Python的性能意味着什么呢？</p><p>如果你的应用基于单线程、单解释器，那么讨论速度这一点就毫无意义，因为去掉GIL并不会影响代码性能。</p><p>如果你想使用线程在单解释器（Python 进程）中实现并发，并且你的线程为IO密集型（例如网络IO或磁盘IO），你就会看到GIL争用的结果。</p><h3 id="是解释语言"><a href="#是解释语言" class="headerlink" title="是解释语言"></a>是解释语言</h3><p>文章没看懂</p><h3 id="是动态语言"><a href="#是动态语言" class="headerlink" title="是动态语言"></a>是动态语言</h3><p>​    需要在运行的时候判断类型，加快了开发效率，但是增加了编译解释的时间，提高了灵活性，牺牲了效率。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go和java和c++接口的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/go%E5%92%8Cjava%E5%92%8Cc++%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/go%E5%92%8Cjava%E5%92%8Cc++%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>依赖倒转原则：高层模块不应该依赖于低层模块，二者都应该依赖于抽象，接口就是高层模块和底层模块的中间层，用于降低耦合性。</p><p>接口的作用：    </p><p>1、降低类间的耦合性</p><p>2、提高并行开发的风险</p><p>java需要显示实现接口，就是需要写implement XXX，Golang是隐式实现，经典的鸭子理论，长的像鸭子，叫起来像鸭子，就是鸭子，举个例子是sort.Sort函数，只要是实现这个的interface里面的函数的类传进去就能调用他。</p><p>​    golang接口可以作为接近范型来使用，可以作为参数传入，java不行</p><p>C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的。例如：</p><p>class Shape</p><p>{</p><p>   public:</p><p>​      &#x2F;&#x2F; 纯虚函数</p><p>​      virtual double getArea() &#x3D; 0;</p><p>   private:</p><p>​      string name;      &#x2F;&#x2F; 名称</p><p>};</p><p>设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</p><p>派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。</p><p>C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。</p><p>C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 <code>itab</code>， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java三大特性</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类继承父类，获得父类的方法和属性</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>把同一类方法封装到同一个类中</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>（1）、重写：子类定义了一个方法，其方法名、返回值类型，参数列表与父类中某个方法一样，就说子类重写父类的同名方法。</p><p>（2）、重载：同一个类中存在多个方法的方法名相同，但是参数列表不同，体现了多态。</p><p>golang不支持重载。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基本数据类型</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>整数<strong>类型</strong>：byte，short，int，long.</li><li>浮点数<strong>类型</strong>：float，double.</li><li>字符<strong>类型</strong>：char.</li><li>布尔<strong>类型</strong>：boolean.</li></ul><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三次握手，四次挥手</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><strong>报文结构：</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gcwqp4x2j20on0ewwft.jpg"></p><h4 id="TCP有哪些特点"><a href="#TCP有哪些特点" class="headerlink" title="TCP有哪些特点"></a>TCP有哪些特点</h4><p>1、TCP是面向连接的</p><p>2、是点对点通信的</p><p>3、TCP提供可靠交付服务，无差错，不丢失，不重复按序到达</p><p>4、TCP是面向字节流的服务</p><p>5、TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>大致理解：tcp为了确认传输数据的安全，第一次发送特殊tcp报文段给客户，客户第二次回复特殊的tcp报文段给服务器，第三次服务器发送要发送的数据给客户。</p><p><img src="https://img2018.cnblogs.com/blog/1344250/201904/1344250-20190402114137828-2119548758.png"></p><ul><li>第一次客户端发送SYN&#x3D;1和初始化的序列号seq x给服务器请求连接连接（ SYN：同步标志）</li><li>第二次服务器回复ACK&#x3D;1，ack&#x3D;x+1,seq&#x3D;y是发送数据的第一个字符的数据编号，SYN为1 代表收到消息并且也请求连接</li><li>第三次用户回复ACK&#x3D;1，ack为y+1，sep为x+1的tcp报文，连接完毕可以传输数据</li></ul><p>ACK代表确认（acknowledge character）</p><p>序列号seq就是这个报文段中的第一个字节的数据编号</p><h4 id="2、四次挥手"><a href="#2、四次挥手" class="headerlink" title="2、四次挥手"></a>2、四次挥手</h4><p><img src="https://img2018.cnblogs.com/blog/1344250/201904/1344250-20190402114059390-716421818.png"></p><ul><li>用户和服务器其中两个都可以终止连接，假设用户想取消连接了，先给服务器发送一个FIN置为1,seq为u的报文。</li><li>服务器收到之后，会立马回复一个ACK为1，ack为u+1，seq为v的报文，ack会自动回复上一个报文加一的seq数据，表示收到。</li><li>隔了一个close_wait时间回复一个FIN置为1，ACK置为1的报文，seq为w，ack为u+1表示同意，为什么要等待一段时间，是因为要询问上层的软件是否同意关闭，服务器不发FIN代表自己可以收到消息但是客户不会发消息了</li><li>最后用户回复ACK为1，seq为u+1,ack为w+1的报文，结束连接。</li></ul><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a><a href="http://sjy.我爱你/2022/03/20/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E/">TCP拥塞控制</a></h3><h3 id="SYN洪范攻击"><a href="#SYN洪范攻击" class="headerlink" title="SYN洪范攻击"></a>SYN洪范攻击</h3><p>服务器为了响应一个收到的SYN，分配并初始化连接变量和缓存，如果攻击者发送大量的TCP SYN报文，服务器不断为这些半开连接分配资源，导致服务器的连接资源消耗殆尽。</p><p>解决办法：<strong>SYN cookie</strong></p><p>服务器接收到一个SYN包的时候并不生成一个半开连接，而是生成一个源ip+目的ip+秘密数的一个值，发送过去，但是并不保存，如果客户端发过来的值是确认值+1，那就说明是合法用户，生成一个套接字的全开连接。</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987546/image-20210921112213523.png" alt="img"></p><p>TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>1、 为什么三次握手？而不是两次握手</strong></p><p>三次握手是得把ACK和SYN都发送给对方，三次握手才能保证双方都接收到消息，第一次是喂，用户：我要连接，服务器：好，我收到了，用户：我收到你的收到了，如果是两次握手那服务器不知道客户收到没有。四次握手是没必要，已经有很大概率链接连接成功了，而且四次握手需要更多的网络资源。</p><p><strong>为什么第三次挥手要等一会再发送？</strong></p><p>原因就是可能上层应用还在发送数据，第一个FIN发过来就告诉上层应用连接要关闭啦，没穿完数据就快点传完，然后等一个close wait自动发送第二个fin包，这样防止数据丢失。</p><p><strong>2、为什么客户端最后还要等待2MSL？</strong></p><p>确实服务器收到了ACK&#x3D;1，如果没收到可以等计时器超时服务器再重发第三次挥手，客户端接受了再发送ACK。</p><p><strong>3、ISN代表什么？意义何在？</strong></p><p>发送方的字节数据编号的原点，isn代表双方连接的钥匙，钥匙要对上孔</p><p>4、<strong>ISN是固定不变的吗？</strong></p><p>动态随机</p><p>5、<strong>ISN为何要动态随机？</strong></p><p>防止被第三方猜到，从而被第三方仿造的RST报文的reset。</p><p><strong>6、三次握手的第一次可以携带数据吗？为何？</strong>对方难道不可以将数据缓存下来，等握手成功再提交给应用程序？</p><p><strong>不可以，三次握手还没有完成。</strong>，因为如果带大量1k字节数据的话服务器要开辟大量缓存来处理，容易使服务器拒绝访问，这是洪泛攻击</p><p><strong>7、第三次可以携带数据吗？为何？</strong></p><p>可以，能够发送第三次代表第二次报文已经接收到了，伪装的ip接收不到第二次报文，所以第三次发送的时候是安全的。</p><p><strong>8、如果输入的端口不存在会怎么办</strong></p><p>握手不能进行，会出现超时未响应的错误。</p><p><strong>9、为什么断开连接却需要四次呢？</strong></p><p>1、确保数据能够完整传输。<br>2、当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p><strong>10、TCP四次挥手出现大量time_wait是什么原因</strong></p><p>TIME_WAIT产生条件：TCP四次挥手中，第一个发送FIN&#x3D;1的TCP报文的人称为主动关闭者，主动关闭者在发送四次挥手最后一个ACK后会变成TIME_WAIT状态，持续时间为2MSL（linux一个MSL为30s，不可配置）</p><p>出现这么多短连接很可能是因为使用了http 1.0 ，使用非持久连接，因为http 1.0请求一次就建立一次tcp连接，请求完立马关闭连接。</p><p><strong>11、怎么复用TCP链接</strong></p><ul><li><p>使用http1.1中的持久连接，传输完一个数据后不关闭tcp连接，可以复用tcp链接。</p></li><li><p><a href="http://sjy.我爱你/2022/03/22/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP1.0%E5%92%8C2.0%E7%9A%84%E5%8C%BA%E5%88%AB/">使用http2.0中tcp多路复用技术</a></p></li></ul><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p>UDP报文：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ge8y7o54j22ab0t677i.jpg"></p><p>TCP的优点：提供可靠稳定安全的连接，无差错，不重复，不丢失，三次握手建立连接，数据传输时有确认、窗口、重传、拥塞控制，数据传完还有四次挥手断开连接。</p><p>TCP缺点：慢，效率低，开销较大，占用硬件资源多，传输效率较低，TCP有确认机制容易被人利用，实现DDOS等攻击</p><p>UDP的优点：无状态的传输协议，单位时间传输数据多。</p><p>UDP的缺点：不可靠，在网络不好的时候容易丢包。</p><p>TCP和UPD的区别</p><p>1、基于连接与无连接</p><p>2、对系统资源的要求不同</p><p>3、UDP程序结构比较简单</p><p>4、TCP要求数据正确，保证数据顺序；UDP可能丢包，不保证数据顺序。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络协议层详情</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82%E8%AF%A6%E6%83%85/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82%E8%AF%A6%E6%83%85/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>OSI七层模型</th><th>TCP四层协议</th><th>综合五层协议</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>应用层</td></tr><tr><td>表示层</td><td></td><td></td></tr><tr><td>会话层</td><td></td><td></td></tr><tr><td>运输层</td><td>运输层</td><td>运输层</td></tr><tr><td>网络层</td><td>网络层</td><td>网络层</td></tr><tr><td>数据链路层</td><td>网络接口层</td><td>数据链路层</td></tr><tr><td>物理层</td><td></td><td>物理层</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次完整的HTTP请求过程</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/http%E5%AE%8C%E6%95%B4%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/http%E5%AE%8C%E6%95%B4%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1、域名解析"><a href="#1、域名解析" class="headerlink" title="1、域名解析"></a>1、域名解析</h3><p>浏览器解析域名得到对应的IP地址</p><p><a href="http://sjy.我爱你/2022/03/20/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/DNS%E8%A7%A3%E6%9E%90/">DNS解析过程</a></p><h3 id="2、TCP三次握手"><a href="#2、TCP三次握手" class="headerlink" title="2、TCP三次握手"></a>2、TCP三次握手</h3><p><a href="http://sjy.我爱你/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">三次握手详解</a></p><h3 id="3、建立连接发起HTTP请求"><a href="#3、建立连接发起HTTP请求" class="headerlink" title="3、建立连接发起HTTP请求"></a>3、建立连接发起HTTP请求</h3><h3 id="4、服务器响应http请求，浏览器得到html代码"><a href="#4、服务器响应http请求，浏览器得到html代码" class="headerlink" title="4、服务器响应http请求，浏览器得到html代码"></a>4、服务器响应http请求，浏览器得到html代码</h3><h3 id="5、浏览器解析html码，并请求html代码中的资源"><a href="#5、浏览器解析html码，并请求html代码中的资源" class="headerlink" title="5、浏览器解析html码，并请求html代码中的资源"></a>5、浏览器解析html码，并请求html代码中的资源</h3><h3 id="6、浏览器对页面进行渲染给用户"><a href="#6、浏览器对页面进行渲染给用户" class="headerlink" title="6、浏览器对页面进行渲染给用户"></a>6、浏览器对页面进行渲染给用户</h3>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<ol><li><p>单例模式</p><p>该类负责创建自己的对象，同时确保只有单个对象被创建（构造器私有化）。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul></li></ol><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>优点：</strong></p><ul><li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>2、避免对资源的多重占用（比如写文件操作）。</li></ul><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p>饿汉式：</p><p>​    在类加载时就完成初始化并且返回，线程安全缺点是会产生垃圾对象</p><p>懒汉式：</p><p>​    每次使用判断类是否初始化，未初始化就初始化返回类，初始化了就直接返回，速度快但是无线程安全。</p><p>双次确认懒汉式：</p><p>​    在实例化的时候判断类是不是已经创建好了，如果没有再确认一次是否已经创建，速度快而且线程安全</p><p>第二种线程安全懒汉式,用synchronized来实现同步</p><pre><code class="hljs smali">public class Singleton &#123;      <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span> Singleton<span class="hljs-built_in"> instance </span>= null;      <span class="hljs-keyword"> private</span> Singleton() &#123;       &#125;;      <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> synchronized Singleton getInstance() &#123;             <span class="hljs-built_in"> if </span>(instance == null) &#123;                    <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>Singleton();              &#125;             <span class="hljs-built_in"> return </span>instance;       &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>选择一个模板，用clone方法克隆一个，clone有深克隆和浅克隆，浅克隆是直接加引用，深克隆是重新new一个对象实例出来，修改克隆父亲不会改变克隆儿子。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建造者模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>举个例子，需要造一个人，需要捏手脚头和身体，就创建一个接口类，来放入捏手脚头和身体的函数的原型，构建一个类来作为指挥者，指挥人的构建，指挥类是用来隔离用户和构造过程之间的联系，最后可以输入不同参数构建起一个不同尺寸的人。这就符合开放封闭原则，要一个胖子只需要增加一个胖子类输入参数就可以构建。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>外观模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>​    外观模式为子系统的一组接口提供一个一致的界面，封装了多个相似的类在一个外观类中，客户调用外观类中的方法来，完美体现依赖倒转原则和迪米特法则</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>定义：</strong>定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类。把创建工厂的行为抽象成interface，子类工厂去实现创建工厂的行为</p><p>举例：（我们依然举pizza工厂的例子，pizza工厂有两个：纽约工厂和伦敦工厂）。类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20190609001610898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><p>工厂的接口：</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbsFactory</span> </span>&#123;       Pizza CreatePizza(<span class="hljs-keyword">String</span> ordertype) ;&#125;</code></pre><p>工厂的实现：</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LDFactory</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">AbsFactory</span></span> </span>&#123;       @Override       <span class="hljs-keyword">public</span> Pizza CreatePizza(<span class="hljs-keyword">String</span> ordertype) &#123;              Pizza pizza = <span class="hljs-literal">null</span>;              <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;cheese&quot;</span>.equals(ordertype)) &#123;                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-type">LDCheesePizza</span>();              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;pepper&quot;</span>.equals(ordertype)) &#123;                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-type">LDPepperPizza</span>();              &#125;              <span class="hljs-keyword">return</span> pizza;       &#125;&#125;</code></pre><p>PizzaStroe的代码如下：</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PizzaStroe</span> &#123;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;              <span class="hljs-title class_">OrderPizza</span> mOrderPizza;              mOrderPizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderPizza</span>(<span class="hljs-string">&quot;London&quot;</span>);       &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板方法模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>提取相同的模板封装为一个类，举个例子就是一张试卷，卷子内容一样，不同同学答案不一样，就把相同的那张卷子封装为一个类，每个同学实例化一个卷子对象的时候可以填上自己的答案，这就防止冗余。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP拥塞处理</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E/</url>
    
    <content type="html"><![CDATA[<h5 id="为什么要TCP拥塞控制"><a href="#为什么要TCP拥塞控制" class="headerlink" title="为什么要TCP拥塞控制"></a>为什么要TCP拥塞控制</h5><h5 id="网络拥塞："><a href="#网络拥塞：" class="headerlink" title="网络拥塞："></a>网络拥塞：</h5><p>​    网络中对某一资源的需求量超过该资源所提供的可用部分，网络性能就会变坏，这种叫做网络拥塞，若出现拥塞不进行控制，随着网络请求的增加会导致吞吐量越来越小，最后会导致吞吐量为0，形成死锁，TCP拥塞控制就是要解决这个问题。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gigbu8loj21080kemz8.jpg"></p><h5 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h5><h6 id="1、慢开始，拥塞避免"><a href="#1、慢开始，拥塞避免" class="headerlink" title="1、慢开始，拥塞避免"></a>1、慢开始，拥塞避免</h6><p>​    发送方维持一个动态大小的拥塞窗口cwnd（congestion window），假设初始设置慢启动阈值为sstresh16，慢开始起始cwnd为1，服务端返回一个确认报文，每次乘以2，第二次发送2个报文，服务端返回两个确认报文，直到慢启动阈值16为止，开始拥塞避免，每次只加一，服务器返回相同数量的确认报文，直到网络拥塞</p><p>怎么确认网络已经拥塞了？</p><p>假设24个报文在传输过程中有4个报文丢失，有4个报文重传计时器超时，缺失四个数量的确认报文，表示了网络拥塞，然后把慢启动阈值设为网络拥塞时的cwnd的一半，再重置cwnd为一半执行拥塞避免。（之前的版本是觉察到网络拥塞就再执行慢启动，现在已经废除了）</p><h6 id="2、快重传，快恢复"><a href="#2、快重传，快恢复" class="headerlink" title="2、快重传，快恢复"></a>2、快重传，快恢复</h6><p>​    快重传就是让发送方尽快进行重传，在重传计时器超时之前完成重传，假设在发送M3报文后发生了数据报文丢失，没有立即发送确认报文，就发送M4,M5,M6报文，每接收方接收到一次报文，就发送一个确认M3报文，接收到连续三个的确认报文，发送方就知道现在网络是不拥塞的，立即重传M3，接收方回复收到M6，避免重复传，之后从M7开始重新传报文，服务端发送确认M7报文。</p><p>​    快恢复是发送方一但接收三次重复的确认报文，会开始快恢复</p><p>1、发送发会把sstresh慢开始门限值设为当前的cwnd拥塞窗口的一半，开始执行避免拥塞算法</p><p>2、也有把快速恢复开始时的拥塞窗口cwnd再增大一些</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单工厂模式</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>​    这种设计模式属于创建型模式，在创建对象时不会对客户端暴露创建逻辑，而是通过使用一个接口指向新创建的对象.</p><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</p><p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p><strong>关键代码：</strong>创建过程在其子类执行。</p><p><img src="https://img-blog.csdnimg.cn/20190609001610870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ExMzQyNzcy,size_16,color_FFFFFF,t_70"></p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimplePizzaFactory</span> </span>&#123;       <span class="hljs-keyword">public</span> Pizza CreatePizza(<span class="hljs-keyword">String</span> ordertype) &#123;              Pizza pizza = <span class="hljs-literal">null</span>;              <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;cheese&quot;</span>)) &#123;                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-type">CheesePizza</span>();              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;greek&quot;</span>)) &#123;                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-type">GreekPizza</span>();              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;pepper&quot;</span>)) &#123;                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-type">PepperPizza</span>();              &#125;              <span class="hljs-keyword">return</span> pizza;       &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux定时任务</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ArchLinux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ArchLinux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>sudo pacman -S cronie</code></p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><pre><code class="hljs nsis"><span class="hljs-comment">#设置开机启动</span>sudo <span class="hljs-params">system</span>ctl enable cronie.service<span class="hljs-comment">#立即启动</span>sudo <span class="hljs-params">system</span>ctl start cronie.service</code></pre><h4 id="crontab用法"><a href="#crontab用法" class="headerlink" title="crontab用法"></a>crontab用法</h4><p>crontab –e : 修改 crontab 文件，如果文件不存在会自动创建。<br>crontab –l : 显示 crontab 文件。<br>crontab -r : 删除 crontab 文件。<br>crontab -ir : 删除 crontab 文件前提醒用户。</p><pre><code class="hljs arcade"><span class="hljs-built_in">minute</span> <span class="hljs-built_in">hour</span> <span class="hljs-built_in">day</span>-of-<span class="hljs-built_in">month</span> <span class="hljs-built_in">month</span>-of-<span class="hljs-built_in">year</span> <span class="hljs-built_in">day</span>-of-<span class="hljs-built_in">week</span> commands</code></pre><p>除了数字还有几个特殊的符号：”*”、”&#x2F;“和”-“、”,”</p><ul><li>*代表所有的取值范围内的数字</li><li>“&#x2F;“代表每的意思,”&#x2F;5”表示每5个单位</li><li>“-“代表从某个数字到某个数字</li><li>“,”分开几个离散的数字</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="三月份-周一到周五-每1分钟执行一次-x2F-runonce-sh"><a href="#三月份-周一到周五-每1分钟执行一次-x2F-runonce-sh" class="headerlink" title="三月份 周一到周五 每1分钟执行一次.&#x2F;runonce.sh"></a>三月份 周一到周五 每1分钟执行一次.&#x2F;runonce.sh</h5><p>*&#x2F;1 * * mar mon-fri .&#x2F;runonce.sh</p><h4 id="每分钟执行一次-x2F-restartTomcat-sh"><a href="#每分钟执行一次-x2F-restartTomcat-sh" class="headerlink" title="每分钟执行一次~&#x2F;restartTomcat.sh"></a>每分钟执行一次~&#x2F;restartTomcat.sh</h4><p>*&#x2F;1 * * * * sh &#x2F;home&#x2F;itkey&#x2F;restartTomcat.sh</p><h5 id="凌晨1点10分执行一次操作"><a href="#凌晨1点10分执行一次操作" class="headerlink" title="凌晨1点10分执行一次操作"></a>凌晨1点10分执行一次操作</h5><p>10 1 * * * sh &#x2F;home&#x2F;apex&#x2F;restartTomcat.sh</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CPU时间片</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E6%97%B6%E9%97%B4%E7%89%87/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E6%97%B6%E9%97%B4%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h2><p>定义： 现在的操作系统是分时系统，会给每个进程分配相同时间CPU资源，如果这个进程在时间片结束前阻塞或者结束，可以进行CPU切换来提高CPU的利用率。这样就不会因为一个进程阻塞住导致电脑无响应，提高了电脑的交互性。</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="轮状调度算法"><a href="#轮状调度算法" class="headerlink" title="轮状调度算法"></a>轮状调度算法</h4><p>​    时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。</p><h4 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h4><h5 id="1、优先调度算法的类型"><a href="#1、优先调度算法的类型" class="headerlink" title="1、优先调度算法的类型"></a>1、优先调度算法的类型</h5><ul><li><p>非抢占式优先调度算法</p></li><li><p>抢占式优先调度算法</p></li></ul><h5 id="2、优先权的类型"><a href="#2、优先权的类型" class="headerlink" title="2、优先权的类型"></a>2、优先权的类型</h5><ul><li>静态优先权</li><li>动态优先权</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用命令</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>1、ls (list) 查看linux文件夹包含的文件</p><p>ls -a 列出所以文件，包含隐藏文件</p><p>ls -t 以文件修改时间排序</p><p>ls -S 以文件大小排序</p><p>ls -h 以易读大小显示</p><p>ls -l除了文件名之外，还有文件的权限、所有者、文件大小等信息</p><p>2、cd (chaneg directory) 进入目录</p><p>cd   &#x2F;     进入根目录</p><p>cd ~     进入home目录</p><p>cd -     进入上一次工作路径</p><p>cd     !$ 把上个命令的参数作为cd参数用</p><p>3、pwd     查看当前工作路径目录</p><p>pwd    -p    查看软连接的实际路径</p><p>4、rm    remove</p><p>rm    -rf    删除子目录及子目录中所以档案</p><p>5、mkdir    （make directory）创建文件夹</p><p>6、rmdir    (remove directory) 只能删除空目录，删除时必须具有对其父目录的写权限。</p><p>7、mv    （move）    移动文件</p><p>8、cp    （copy）  将原文件复制至目标文件</p><p>cp -i    提示</p><p>cd -r    复制目录及目录内所有项目</p><p>cp    -a    复制的文件与原文件时间一样</p><p>9、cat    </p><p>cat  filename    一次性显示整个文件</p><p>cat    &gt;    filename    从键盘创建一个文件</p><p>cat    file1    file2    &gt;    file    将几个文件合并为一个文件</p><p>cat    -n    输出所有行号</p><p>10、more    功能类似于cat但是可以一页一页方便逐页阅读，按space下一页，b就往回</p><p>more    +3    text.txt    显示文件从第三行起的内容</p><p>11、less    和more类型</p><p>12、head    用来显示档案的开头至标志输出</p><p>13、tail    用于显示指定文件末尾内容</p><p>14、which    </p><p>15、whereis</p><p>16、locate</p><p>17、find</p><p>18、chmod    用于改变linux系统文件或者目录的访问权限，</p><p>u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</p><p>常用参数：</p><p>​    -c 当发送改变时，报告处理信息</p><p>​    -R处理指定目录以及子目录下所有文件</p><p>权限范围：</p><p>​    u：目录或者文件的当前的用户</p><p>​    g：目录或者文件的当前的群组</p><p>​    a：所有 的用户及群组</p><p>实例：</p><p>chmod    a+x    t.log    增加文件t.log所有用户可执行权限</p><p>chmod 777 +文件 就是给这个文件所以人的读、写、执行权限</p><pre><code class="hljs lua">读权限（<span class="hljs-built_in">read</span>，r）的值是<span class="hljs-number">4</span>，写权限（<span class="hljs-built_in">write</span>，w）的值是<span class="hljs-number">2</span>，执行权限（<span class="hljs-built_in">execute</span>，x）的值是<span class="hljs-number">1</span></code></pre><p>19、tar    用于压缩和解压文件，本身只有打包功能，打包是将一大堆文件或者目录变成一个总的文件</p><p>常用参数：</p><p>​    -c    （creat）建立新的压缩文件</p><p>​    -f    (file)指定压缩文件</p><p>​    -u 添加改了和现有的文件到压缩包中</p><p>​    -x    从压缩包中抽取文件</p><p>​    -t    显示压缩文件的内容</p><p>​    -z    支持gzip压缩</p><p>​    -j    支持bzip2压缩</p><p>​    -Z    支持compress解压文件</p><p>​    -v    显示操作过程</p><p>20、chown</p><p>21、df    显示磁盘空间使用情况,磁盘空间以1KB显示</p><p>-a    全部文件系统列表</p><p>-h    方便阅读方式显示信息</p><p>-i    显示inode信息</p><p>-l    只显示本地磁盘</p><p>22、du命令</p><p>23、ln    （link）为文件在另外一个位置建立一个同步的链接，默认为硬链接</p><p><a href="http://sjy.我爱你/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/">硬链接和软链接</a></p><p>24、netstat</p><p>-t：显示TCP端口</p><p>-u：显示udp端口</p><p>-n:  不进行DNS轮询，显示IP加快速度</p><p>-a： 显示所有socket</p><p>-p：显示标识符和程序名称</p><p>dmesg</p><p>isomod</p><p>rmmod</p><p>make</p><p>dhcpcd</p><p>ipconfig</p><p>ifconfig</p><p>xrandr</p><p>pacman</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LINUX和Windows的区别（从底层来说）</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LINUX%E5%92%8CWindows%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BB%8E%E5%BA%95%E5%B1%82%E6%9D%A5%E8%AF%B4%EF%BC%89/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LINUX%E5%92%8CWindows%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BB%8E%E5%BA%95%E5%B1%82%E6%9D%A5%E8%AF%B4%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>先说一下现象，Linux是服务器和嵌入式的主流操作系统,Windows是个人pc领域的绝对王者</p><p>再来说一下为什么</p><p><strong>Linux的优点：</strong>Linux是开源的，并且有完善的权限管理机制，是适合多用户的操作系统，在广大贡献者的作用下，Linux安全性和稳定性好，能运行一年很少宕机，并且要常年处于开机状态要最好避免内存碎片问题，使用伙伴系统进行内存管理。</p><p>**Windows的优点:**是闭源的，有高度完善好用的图形化界面，吸引广大用户使用，使用傻瓜式的安装软件使用体验，安装包是二进制，防止泄露源代码。</p><p> <strong>Linux和Windows的最大区别在于Linux是高度模块化的</strong></p><p>​    Linux是由数百个小型的独立程序一起运行组成，Linux可以去除不需要的模块从而创造一个迎合特定需要的强健而简洁的操作系统。并且可以模块化编译，修改内核十分方便，修改了一个小东西不用编译整个操作系统。Linux内核分为进程调度，内存管理，进程通信，虚拟文件系统和网络接口。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux硬连接和软连接</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ff2yhqszj20ng0irgn5.jpg"></p><h4 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h4><p>Linux 下的文件是通过索引节点（inode）识别文件，硬链接可以认为为一个指针指向文件索引节点，系统并不分配inode，文件链接数加一。</p><ul><li>删除硬链接文件或者删除源文件任意之一，文件实体并未被删除；</li><li>只有删除了源文件和所有对应的硬链接文件，文件实体才会被删除；</li><li>硬链接文件是文件的另一个入口；</li><li>可以通过给文件设置硬链接文件来防止重要文件被误删；</li></ul><p><strong>不足：</strong></p><p>1、不可以在不同文件系统的文件间建立链接</p><p>2、只有超级用户才可以为目录创建硬链接</p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>没有任何文件系统的限制，任何用户可以创建指向目录的符号链接，有更大灵活性，可以跨越不同机器</p><ul><li>软链接里面存放的是源文件的路径，指向源文件；</li><li>删除源文件，软链接依然存在，但无法访问源文件内容；</li><li>软链接失效时一般是白字红底闪烁；</li><li>创建软链接命令 ln -s 源文件 软链接文件；</li><li>软链接和源文件是不同的文件，文件类型也不同，inode号也不同</li></ul><p>缺点：</p><p>1、链接文件包含有源文件的路径信息，需要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</p><h4 id="硬链接和软链接的区别"><a href="#硬链接和软链接的区别" class="headerlink" title="硬链接和软链接的区别"></a>硬链接和软链接的区别</h4><p>​    原理上，硬链接和源文件的inode节点号相同，两者互为硬链接。软连接和源文件的inode节点号不同，进而指向的block也不同，软连接block中存放了源文件的路径名。 实际上，硬链接和源文件是同一份文件，而软连接是独立的文件，类似于快捷方式，存储着源文件的位置信息便于指向。 使用限制上，不能对目录创建硬链接，不能对不同文件系统创建硬链接，不能对不存在的文件创建硬链接；可以对目录创建软连接，可以跨文件系统创建软连接，可以对不存在的文件创建软连接。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程线程和协程的特性和区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程是操作系统分配资源的最小单位</strong></p><p>​    一个进程中有多个线程，一个线程里面可以有多个协程，因为进程是最大的了，进程切换需要的开销很大，但是进程挂了，其他进程因为保护机制会不受影响，但是这个进程里面的线程协程也都会挂掉。</p><h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><p>1）管道(pipe)及有名管道(named pipe)：</p><p>　　管道可用于具有亲缘关系的父子进程间的通信；有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。</p><p>　　2）信号(signal)：</p><p>　　信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</p><p>　　3）消息队列(message queue)：</p><p>　　消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。</p><p>　　4）共享内存(shared memory)：</p><p>　　可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p><p>　　5）信号量(semaphore)：</p><p>　　主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。</p><p>　　6）套接字(socket)；</p><p>　　这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程是操作系统所能调度执行的最小单位</strong></p><p>计算机的cpu物理核数是同时可以并行的线程数量(cpu只能看到线程，线程是cpu调度分配的最小单位</p><h3 id="线程间的通信方式"><a href="#线程间的通信方式" class="headerlink" title="线程间的通信方式"></a>线程间的通信方式</h3><p>1）<strong>锁机制：</strong>包括互斥锁、条件变量、读写锁</p><p>　　　　a. 互斥锁提供了以排他方式防止数据结构被并发修改的方法。</p><p>　　　　b. 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</p><p>　　　　c. 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p><p>　　2）<strong>信号量机制</strong>(Semaphore)：包括无名线程信号量和命名线程信号量</p><p>　　3）<strong>信号机制</strong>(Signal)：类似进程间的信号处理</p><h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><p>**1、新建状态(New)**：新创建了一个线程对象。</p><p>**2、就绪状态(Runnable)**：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权，</p><p>  即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。</p><p>**3、运行状态(Running)**：就绪状态的线程获取了CPU，执行程序代码。</p><p>**4、阻塞状态(Blocked)**：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。</p><p>  阻塞的情况分三种：</p><p>①.等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，</p><p>  必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，</p><p>②.同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。</p><p>③.其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时，</p><p>  或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</p><p>**5、死亡状态(Dead)**：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p><h3 id="什么是线程死锁？"><a href="#什么是线程死锁？" class="headerlink" title="什么是线程死锁？"></a>什么是线程死锁？</h3><p><strong>概念：</strong>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行</p><h4 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h4><ul><li>系统资源不足</li><li>进程推进的顺序不合适</li><li>资源分配不当</li></ul><h4 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h4><ul><li><strong>互斥条件：</strong>进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放</li><li><strong>请求和保持条件：</strong>一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件：</strong>任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用</li><li><strong>循环等待条件：</strong>当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。</li></ul><h4 id="避免死锁的办法：银行家算法"><a href="#避免死锁的办法：银行家算法" class="headerlink" title="避免死锁的办法：银行家算法"></a>避免死锁的办法：银行家算法</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0oe3hnzgkj20rk0fbjt4.jpg"></p><p>假设资源P1申请资源，银行家算法先试探的分配给它（当然先要看看当前资源池中的资源数量够不够），若申请的资源数量小于等于Available，然后接着判断分配给P1后剩余的资源，能不能使进程队列的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态（即此时没有一个进程能够完成并释放资源，随时间推移，系统终将处于死锁状态）。</p><p>若有进程可执行完毕，则假设回收已分配给它的资源（剩余资源数量增加），把这个进程标记为可完成，并继续判断队列中的其它进程，若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列（如{P0，P3，P2，P1}表示将申请后的剩余资源Work先分配给P0–&gt;回收（Work+已分配给P0的A0&#x3D;Work）–&gt;分配给P3–&gt;回收（Work+A3&#x3D;Work）–&gt;分配给P2–&gt;······满足所有进程）。</p><h4 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h4><p>破坏产生死锁的必要条件，增加系统资源，改变合理的进程推进顺序，改善资源分配方式</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>协程是用户态的轻量级线程，操作系统所不能开辟的，但是可以由程序控制</strong></p><p>协程主要是为了提高并发，而且主要是IO并发。协程并不适合并行计算或者并行处理任务，因为同一时刻运行的协程数不可能大于操作系统线程。</p><h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><p>1、极高的执行效率，因为子程序切换不是线程切换，而是程序自身切换，没有线程切换开销效率高。</p><p>2、不需要多线程的锁机制，因为只有一个线程不存在同时写变量冲突。</p><h3 id="为什么协程切换代价比线程低"><a href="#为什么协程切换代价比线程低" class="headerlink" title="为什么协程切换代价比线程低"></a>为什么协程切换代价比线程低</h3><p>协程切换流程：</p><p>1、保存当前寄存器信息</p><p>2、选择下一个要执行的协程</p><p>3、恢复寄存器上下文</p><p>线程切换流程：</p><p>1、软中断</p><p>2、保存寄存器信息到内核堆栈、</p><p>3、选择下一个要执行的线程</p><p>4、恢复上下文</p><p>5、返回用户堆栈</p><ul><li><p>需要保存的寄存器信息大小不同，线程需要把寄存器保存到内核堆栈，并且 返回用户堆栈</p></li><li><p>协程无多线程锁机制，因为一个协程运行就一个线程。</p></li><li><p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p></li></ul><p><strong>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行</strong>。</p><p>协程的特点在于是一个线程执行</p><p>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p><p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p><h3 id="问题：为什么要把线程的上下文信息保存到内核态中"><a href="#问题：为什么要把线程的上下文信息保存到内核态中" class="headerlink" title="问题：为什么要把线程的上下文信息保存到内核态中"></a>问题：为什么要把线程的上下文信息保存到内核态中</h3><p>因为用户态的权限比较低，不能直接访问硬盘内存等资源，只能通过系统调用来做。</p><h4 id="go语言内的协程"><a href="#go语言内的协程" class="headerlink" title="go语言内的协程"></a>go语言内的协程</h4><p>goroutine 非常的<strong>轻量</strong>，初始分配只有 2KB，当栈空间不够用时，会自动扩容。同时，自身存储了执行 stack 信息，用于在调度时能恢复上下文信息。</p><p>而线程比较重，一般初始大小有几 MB(不同系统分配不同)，线程是由操作系统调度，是操作系统的调度基本单位。而 golang 实现了自己的调度机制，goroutine 是它的调度基本单位。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B树、B+树、红黑树、AVL树</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h5 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h5><p>是一个特殊的AVL（平衡二叉搜索树）,需要遵守几个条件</p><p>1、根节点得是黑色的</p><p>2、连续两个红色节点不能连续</p><p>3、根节点到每个子节点遇到的黑色节点数量相同</p><h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><p>1、根节点是黑色的</p><p>2、最大长度为2*（log（n+1））</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>2-3树是B树的一种特例，二叉搜索树搜索效率高，但是为了保持平衡需要的代价太大，所以人想出了一个结点允许多个值的数据结构-B树</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0e0zmzuq0j20k408daa9.jpg" alt="B树"></p><h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><p>1、所有叶子子结点在同一层上面，和平衡二叉树比层数低，磁盘io少，加快了查询插入速度</p><p>2、每个节点的元素从小到大排列</p><p>操作系统索引表也用了b+树</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0e10thk89j20mx094weu.jpg" alt="b+树png"></p><h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><p>1、所有叶子节点都在同一层，并且中间结点是他的子结点的最大或者最小值，最大值在根节点中</p><p>2、所有数据都在子结点上面，子结点包括了所有信息，每个元素不保存数据只用来索引，查询稳定，所有子结点都链接起来，导出全部数据方便</p><p>3、非叶子节点只有key，没有value，叶子节点有key，value</p><h4 id="B树和B-树的区别，为什么mysql会选b-树"><a href="#B树和B-树的区别，为什么mysql会选b-树" class="headerlink" title="B树和B+树的区别，为什么mysql会选b+树"></a>B树和B+树的区别，为什么mysql会选b+树</h4><p><strong>卫星数据：</strong>指索引元素所指向的数据记录，比如数据库中的某一行。</p><p>1、B+树的中间节点没有卫星数据，同样大小的磁盘页可以容纳更多的节点元素。意味着，数据量相同的情况下，B+树的结构比B树更加矮胖，因此查询时IO次数更少，B+树更加的矮胖一点，磁盘IO操作少，查询速度比B快</p><p>2、数据库扫库更加方便，范围查询更加方便，查询一段区别的数据比B树方便</p><p>3、查询性能更加稳定，B+树得每次查到叶子结点，B树可能查到中间结点查到数据就终止</p><h4 id="hash比B-树快-为什么还选B-树"><a href="#hash比B-树快-为什么还选B-树" class="headerlink" title="hash比B+树快,为什么还选B+树"></a>hash比B+树快,为什么还选B+树</h4><p>因为只选一个数据是hash块，但是范数据量大无法一次装入内存，范围查询的话是B+树快</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyISAM与InnoDB的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/MyISAM%E4%B8%8EInnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/MyISAM%E4%B8%8EInnoDB-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</strong> </p><p>2、 <strong>InnoDB是聚集索引</strong>，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p><p>   <strong>MyISAM是非聚集索引</strong>，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p><p>3、 <strong>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</strong> </p><p>4、 <strong>系统奔溃后，MyISAM恢复起来更困难</strong>，Innodb奔溃了能自动恢复</p><p>5、InnoDB默认是行级锁，MYISAM默认是表级锁</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>对于各种树的介绍和异同可以看这篇文章<a href="http://www.mystorys.xyz/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB/">B树、B+树、红黑树、AVL树</a></p><p>索引底层数据结构是B+树，B+树最大的优点在于它将索引存放在<strong>磁盘</strong>，让检索技术摆脱了内存限制。</p><p><strong>单例索引：</strong>一个索引只能包含一个列，一个表可以有多个单例索引</p><p><strong>组合索引：</strong>一个组合索引包含两个或以上的列，原理简单，在a，b，c字段上创建索引，索引记录会首先安装A排序，A一样照B排序，B一样照C排序。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0e0abqd14j203205xq30.jpg"></p><p><strong>聚簇索引：</strong>数据存储和索引放一块，b+树叶子节点存放的是数据表的行记录，可以理解成将数据存储和索引放到了一块,这是主键索引，因为InnoDB数据文件本身要按主键聚集，所以InnoDB要求必须有主键，如果没有就自动生成一个隐含的字段作为主键</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0e0bs4mxzj20dw060aaa.jpg"></p><p>为什么mysql表要有一个自增的id主键，因为mysql索引用b+数，得是一个递增的，因为如果不递增增加数据的话得裂表影响效率，而且不建议使用太长的字段作为主键。</p><p><strong>非聚簇索引：</strong>数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。</p><p>聚簇索引优点：</p><ul><li>数据访问更快，因为聚簇索引将数据放在同一个B+树中，所以比非聚簇索引快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul><p>缺点：</p><ul><li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将出现页分裂，严重影响性能，我们一般会定义一个自增的ID作为主键</li><li>更新主键的代价很高</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><h4 id="1、一级索引"><a href="#1、一级索引" class="headerlink" title="1、一级索引"></a>1、一级索引</h4><p>索引和数据存储在一起，都存储在同一个B+tree中的叶子节点。一般主键索引都是一级索引。</p><h4 id="2、二级索引"><a href="#2、二级索引" class="headerlink" title="2、二级索引"></a>2、二级索引</h4><p>二级索引树的叶子节点存储的是主键而不是数据。也就是说，在找到索引后，得到对应的主键，再回到一级索引中找主键对应的数据记录。</p><h4 id="3、一级索引和二级索引的关系：回表"><a href="#3、一级索引和二级索引的关系：回表" class="headerlink" title="3、一级索引和二级索引的关系：回表"></a>3、一级索引和二级索引的关系：回表</h4><p>一级索引可以单独存在，二级索引不能单独存在，必须依附于一级索引，这叫做“回表”。</p><p>select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表</p><h4 id="4、索引建立原则"><a href="#4、索引建立原则" class="headerlink" title="4、索引建立原则"></a>4、索引建立原则</h4><p>（1）最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的。<br>如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>（2）&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，<br>mysql的查询优化器会帮你优化成索引可以识别的形式</p><p>（3）尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)&#x2F;count(*)，表示字段不重复的比例，<br>比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，<br>那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，<br>一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</p><p>（4）索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，<br>原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，<br>显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’);</p><p>（5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p><h4 id="5、可能索引失效的原因"><a href="#5、可能索引失效的原因" class="headerlink" title="5、可能索引失效的原因"></a>5、可能索引失效的原因</h4><p>和索引建立原则类似</p><ul><li><p>范围查询，&gt;,&lt;,!&#x3D;,or会导致索引失效,like ‘%liu’ 百分号在前也会导致索引失效</p><ul><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，把c&gt;3放到最后。</li></ul></li><li><p>使用select * 类似的语句可能会导致不用索引，优化器可能会选择TABLE ACCESS FULL</p></li><li><p>单键值的b树索引列上存在null值，导致COUNT(*)不能走索引</p></li><li><p>索引列上有函数运算，导致不走索引</p></li><li><p>建立组合索引，但查询谓词并未使用组合索引的第一列，此处有一个INDEX SKIP SCAN概念</p></li></ul><h4 id="6、唯一索引和主键索引的区别"><a href="#6、唯一索引和主键索引的区别" class="headerlink" title="6、唯一索引和主键索引的区别"></a>6、唯一索引和主键索引的区别</h4><p>1、概念：主键是一种约束、是一种逻辑键实际上不存在；唯一索引是一个索引、是物理键，实际上存在。</p><p>2、主键索引不能有空值，唯一索引可以有空值（可以有多个空值）</p><p>3、主键可以建立外键， 唯一索引不能</p><p>4、一个表中只能有一个主键，但是可以有多个外键</p><p>5、主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等</p><h4 id="7、为什么唯一索引比普通索引快（查询会快一点点点点）"><a href="#7、为什么唯一索引比普通索引快（查询会快一点点点点）" class="headerlink" title="7、为什么唯一索引比普通索引快（查询会快一点点点点）"></a>7、为什么唯一索引比普通索引快（查询会快一点点点点）</h4><p><strong>查询效率：</strong>唯一索引查询时有很小概率会比普通索引快，有概率普通索引有一条数据在一个页表末尾，一条数据在页表前面，需要两次io，这时唯一索引会比普通索引快一点。</p><p><strong>更新效率：</strong>唯一索引更新的时候需要把索引页读到内存中，不然不能判断数据是否唯一，会比普通索引慢</p><p><strong>总结：</strong>少用唯一索引。</p><h4 id="8、为什么数据库联合索引不符合最左前缀就会失效"><a href="#8、为什么数据库联合索引不符合最左前缀就会失效" class="headerlink" title="8、为什么数据库联合索引不符合最左前缀就会失效"></a>8、为什么数据库联合索引不符合最左前缀就会失效</h4><p>这就得看看联合索引在底层是怎么放的</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0nqys5zfcj20hs0ewmyh.jpg"></p><p>单一索引是一个节点存一个键，联合索引是一个节点存多个键，每个键都是有顺序的，两个节点比较是第一个节点如果相同，就比较第二个节点，查找的时候也是这样，如果第一个节点找到了，就开始比较第二个节点是否相同。</p><h4 id="9、为什么b-树大层数总是2-4层"><a href="#9、为什么b-树大层数总是2-4层" class="headerlink" title="9、为什么b+树大层数总是2-4层"></a>9、为什么b+树大层数总是2-4层</h4><p>​    我们来计算一下3层b+树能放多少数据，mysql默认页是16KB，假设一条数据1KB，一页就能放16条记录，假设有三层数据，假如我们的主键id为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节。这样算下来就是 16384 &#x2F; 14 &#x3D; 1170，就是说一个页上可以存放1170个指针，两层是1170*16，三层是1170 * 16 * 1170，千万行足够大部分场景，再大也要分库分表了。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务和隔离级别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>数据库事务的定义：</strong>一个或多个数据库操作</p><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><p><strong>A atom 原子性</strong>  事务执行是原子，一个事务中所有操作，要么全部完成，要么全部不完成，不会结束在中间的环节。</p><p><strong>C Consistency 一致性</strong>    在事务开始和事务开始后，数据库的完整性约束没被破坏完整性约束：主键的约束没有变，数据库中不能输入不符合约束的值。</p><p><strong>I    isolation 隔离性</strong>    多个并发事务相互独立互不影响，多个用户的并发事务访问同一个数据库，一个用户的事务应该被隔离起来不被干扰。</p><p><strong>D durability 持久性</strong>    事务处理后对数据的修改是永久的</p><h3 id="Mysql-事务是如何实现的"><a href="#Mysql-事务是如何实现的" class="headerlink" title="Mysql 事务是如何实现的"></a>Mysql 事务是如何实现的</h3><p><strong>原子性：</strong>通过undo log实现的。每条数据变更都伴随一条undo log日志的生成，当系统发生错误或执行回滚根据undo log做逆向操作。<br><strong>持久性：</strong>通过redo log实现的。redo log记录了数据的修改日志。数据持久化到磁盘，先是储存到缓冲池里，然后缓冲池中的数据定期同步到磁盘中，如果系统宕机，可能会丢失数据，系统重启后会读取redo log恢复数据。<br><strong>隔离性：</strong>mysql数据库通过MVCC + next-key机制实现了隔离性<br><strong>一致性：</strong>以上3大特性，保障了事务的一致性</p><h4 id="mysql四种隔离级别"><a href="#mysql四种隔离级别" class="headerlink" title="mysql四种隔离级别"></a>mysql四种隔离级别</h4><p>1、读未提交</p><p>如果一个事物已经开始写数据，则另外一个事物则不允许同时进行写操作，但是允许读数据，会出现脏读。</p><p>2、读已提交</p><p>未提交的写事务禁止其他事物访问，可避免脏读</p><p>3、可重复读(数据库默认隔离级别)</p><p>sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。</p><p>​    可避免脏读，不可重复读</p><p>4、串行化</p><p>​    可避免脏读、不可重复读和幻读</p><table><thead><tr><th>隔离界别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED：读未提交</td><td>可能发生</td><td>可能发生</td><td>可能发生</td></tr><tr><td>READ COMMITTED：读已提交</td><td>解决</td><td>可能发生</td><td>可能发生</td></tr><tr><td>REPEATABLE READ：可重复读</td><td>解决</td><td>解决</td><td>可能发生</td></tr><tr><td>SERIALIZABLE：可串行化</td><td>解决</td><td>解决</td><td>解决</td></tr></tbody></table><h4 id="不考虑隔离级别会发生的事情"><a href="#不考虑隔离级别会发生的事情" class="headerlink" title="不考虑隔离级别会发生的事情"></a>不考虑隔离级别会发生的事情</h4><p>1、脏读</p><p>一个事务在处理数据时读到别的未提交事务的数据，然后这个数据回滚了</p><p>2、不可重复读</p><p>数据库中的某个数据，在一次事务中多次查询得到的数据不一致，因为另一个事务修改并且提交了</p><p>3、幻读</p><p>在一次事务里面，多次查询之后，查询的结果集的个数不一致的情况叫做幻读。而多出来或者少的哪一行被叫做 幻行但是不可重复读是一个数据，幻读是一批数据整体，解决不可重复读的办法<strong>是行锁</strong>，解决幻读的办法是<strong>锁表</strong>。</p><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><ul><li><p><strong>第一范式</strong></p><p>一列不能有多个值</p></li><li><p><strong>第二范式</strong>，属性完全依赖于主键 [ 消除部分子函数依赖 ]</p><p><strong>非主属性完全依赖于主关键字</strong></p><p>(学号, 课程名称) → (姓名, 年龄, 成绩, 学分)</p><p>这个数据库表不满足第二范式，因为存在如下决定关系： </p><p>(课程名称) → (学分)</p><p>(学号) → (姓名, 年龄)</p><p>即存在组合关键字中的字段决定非关键字的情况。</p></li><li><p><strong>第三范式</strong> 属性不依赖于其它非主属性 [ <strong>消除传递依赖</strong> ]</p></li></ul><p>​    (学号) → (所在学院) → (学院地点, 学院电话) 这样是不符合的，得分成两个表</p><p>​    <strong>学生：(学号, 姓名, 年龄, 所在学院)；</strong></p><p>​    <strong>学院：(学院, 地点, 电话)；</strong></p><p>Mysql的事务该怎么手写</p><pre><code class="hljs abnf">begin<span class="hljs-comment">;</span>xxxxcommit<span class="hljs-comment">;</span>orbegin<span class="hljs-comment">;</span>rollback<span class="hljs-comment">;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql锁</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%81/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>用处：保证数据安全，处理并发访问</p><p>首先对mysql锁进行划分：</p><ol><li>按照锁的粒度划分：行锁、表锁、页锁</li><li>按照锁的使用方式划分：共享锁、排它锁（悲观锁的一种实现）</li><li>还有两种思想上的锁：悲观锁、乐观锁。</li><li>InnoDB中有几种行级锁类型：Record Lock、Gap Lock、Next-key Lock</li><li>Record Lock：在索引记录上加锁</li><li>Gap Lock：间隙锁</li><li>Next-key Lock：Record Lock+Gap Lock</li></ol><p>InnoDB默认的是行级锁</p><p>乐观锁定义：（现实中用的较多）默认用户访问正在改变的数据的概率很小，直到修改完成准备提交所作的修改才会将数据锁住修改为再释放。</p><p>悲观锁定义：默认用户访问正在改变的数据的概率很大，会在数据修改时上锁，只有能数据修改后提交才能解锁让其他用户修改这个数据。使用悲观锁会让访问数据库的时间增加，并发性不好。</p><p>共享读锁（S锁）：</p><p>​    如果一个事务对这个对象加了锁，当前事务只能进行读操作，其他事务也可以对这个对象加共享锁。</p><p>排他写锁（X锁）：</p><p>​    加锁之后只能有一个事务对他做写操作和更新操作。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 和 HTTPS</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP%20%E5%92%8C%20HTTPS%20/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP%20%E5%92%8C%20HTTPS%20/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>http是超文本传输协议，最开始是为了方便传输html而创建的，传输的信息都是没经过加密的，并且是无状态的，连接通过TCP连接，端口为80，安全性很差，但是连接很简单，速度快减少界面加载延时</p><h2 id="HTTP协议的特点？"><a href="#HTTP协议的特点？" class="headerlink" title="HTTP协议的特点？"></a>HTTP协议的特点？</h2><ol><li>HTTP允许传输<strong>任意类型</strong>的数据。传输的类型由Content-Type加以标记。 </li><li><strong>无状态</strong>。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系。 </li><li>支持<strong>客户端&#x2F;服务器模式</strong>。</li></ol><h4 id="http缺点"><a href="#http缺点" class="headerlink" title="http缺点"></a>http缺点</h4><p>1、无法验证报文的完整性</p><p>2、无法验证发送人，所以可能被伪装</p><p>3、通信使用明文，可能信息被窃听</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gi9djnslj20g20btdg9.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0gi9j8u5uj20re0iejsd.jpg"></p><h4 id="http常见状态码"><a href="#http常见状态码" class="headerlink" title="http常见状态码"></a>http常见状态码</h4><table><thead><tr><th>http状态码</th><th>解释</th></tr></thead><tbody><tr><td>200 OK</td><td>请求成功完成</td></tr><tr><td>301 Moved Permanently</td><td>永久移动，永久重定向</td></tr><tr><td>302 Found</td><td>临时移动，临时重定向</td></tr><tr><td>400 Bad Request</td><td>客户端请求错误,服务器理解不了</td></tr><tr><td>403 Forbidden</td><td>服务器收到并且理解请求，但是拒绝提供服务</td></tr><tr><td>404 Not Found</td><td>客户端所要找的资源找不到</td></tr><tr><td>499 client has closed connection</td><td>nginx 自定义状态码，两次post提交过快或者服务器端处理的时间过长</td></tr><tr><td>500 Internal Server Error</td><td>服务器错误</td></tr><tr><td>503  Service Unavailable</td><td>服务器尚未处于可以请求状态，服务器停机或者已超载</td></tr></tbody></table><h3 id="介绍下http2-0"><a href="#介绍下http2-0" class="headerlink" title="介绍下http2.0"></a>介绍下http2.0</h3><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a><a href="http://sjy.我爱你/2022/03/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E7%BD%91%E7%BB%9C/HTTP1.0%E5%92%8C2.0%E7%9A%84%E5%8C%BA%E5%88%AB/">HTTP2.0</a></h3><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p>安全的基础是ssl协议，连接方式不同（待补充），https是http+ssl协议进行构建的加密传输、身份认证的网络协议，比http协议安全很多，连接方式通常也是tcp，也有可能是SCTP。</p><p>ssl由权威机构颁发，ssl是一个非对称加密，有一个公钥，和一个私钥，用公钥加密后的信息只能由私钥解密，用私钥加密的数据只能公钥解密,公钥放在服务器，私钥放在个人主机。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>https是经过ssl证书认证并且在传输过程加密的一种传输方式，端口为443安全性大大增加，https &#x3D; http+ssl加密</p><h2 id="什么是数字证书？"><a href="#什么是数字证书？" class="headerlink" title="什么是数字证书？"></a>什么是数字证书？</h2><p>服务端可以向证书颁发机构CA申请证书，以避免中间人攻击（防止证书被篡改）。证书包含三部分内容：<strong>证书内容、证书签名<a href="">算法</a>和签名</strong>，签名是为了验证身份。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987428/image-20211004111441594.png" alt="img"></p><p>服务端把证书传输给浏览器，浏览器从证书里取公钥。证书可以证明该公钥对应本网站。</p><p><strong>数字签名的制作过程</strong>：</p><ol><li>CA使用证书签名<a href="">算法</a>对证书内容进行<strong>hash运算</strong>。 </li><li>对hash后的值<strong>用CA的私钥加密</strong>，得到数字签名。</li></ol><p><strong>浏览器验证过程</strong>：</p><ol><li>获取证书，得到证书内容、证书签名算法和数字签名。 </li><li>用CA机构的公钥<strong>对数字签名解密</strong>（由于是浏览器信任的机构，所以浏览器会保存它的公钥）。 </li><li>用证书里的签名<a href="">算法</a><strong>对证书内容进行hash运算</strong>。 </li><li>比较解密后的数字签名和对证书内容做hash运算后得到的哈希值，相等则表明证书可信。</li></ol><p>首先是TCP三次握手，然后客户端发起一个HTTPS连接建立请求，客户端先发一个<code>Client Hello</code>的包，然后服务端响应<code>Server Hello</code>，接着再给客户端发送它的证书，然后双方经过密钥交换，最后使用交换的密钥加解密数据。</p><ol><li><p><strong>协商加密算法</strong> 。在<code>Client Hello</code>里面客户端会告知服务端自己当前的一些信息，包括客户端要使用的TLS版本，支持的加密算法，要访问的域名，给服务端生成的一个随机数（Nonce）等。需要提前告知服务器想要访问的域名以便服务器发送相应的域名的证书过来。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987415/image-20210921104210833.png" alt="img"></p></li><li><p>服务端响应<code>Server Hello</code>，告诉客户端服务端<strong>选中的加密算法</strong>。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987405/image-20210921105450791.png" alt="img"></p></li><li><p>接着服务端给客户端发来了2个证书。第二个证书是第一个证书的签发机构（CA）的证书。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987405/image-20211004172007102.png" alt="img"></p></li><li><p>客户端使用证书的认证机构CA公开发布的RSA公钥<strong>对该证书进行验证</strong>，下图表明证书认证成功。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987746/image-20210921105929268.png" alt="img"></p></li><li><p>验证通过之后，浏览器和服务器通过<strong>密钥交换算法</strong>产生共享的<strong>对称密钥</strong>。</p><p>RSA密钥交换算法：</p><p>（1）任意客户端对服务器发起请求，服务器首先发回复自己的公钥到客户端（公钥明文传输）。</p><p>（2）客户端使用随机数算法，生成一个密钥S，使用收到的公钥进行加密，生成C，把C发送到服务器。</p><p>（3）服务器收到C，使用公钥对应的私钥进行解密，得到S。</p><p>（4）上述交换步骤后，客户端和服务器都得到了S，S为密钥（预主密钥）。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987406/image-20210921110025197.png" alt="img"></p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987428/image-20210921110155075.png" alt="img"></p></li><li><p>开始传输数据，使用同一个对称密钥来加解密。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211017/530285728_1634456987387/image-20210921110315068.png" alt="img"></p></li></ol><h3 id="https被中间人攻击了怎么办"><a href="#https被中间人攻击了怎么办" class="headerlink" title="https被中间人攻击了怎么办"></a>https被中间人攻击了怎么办</h3><p>攻击人先使用DNS劫持把请求都到他的服务器，再用伪造的证书与客户端进行交互</p><p><strong>解决办法：</strong></p><p>第一步需要验证CA证书的时候去验证他是不是权威机构，使用权威机构的CA证书的公钥解密验证和原来的证书是否一致，如果不是就不信任他不与他进行https连接。</p><h4 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h4><p>1、get请求表示的意思是要得到信息，并且get请求参数都放header或者url上面，安全性较差放url上面有长度限制，最多1024个字符，不适合传大长度信息。</p><p>2、post请求表示添加信息 ，请求参数作为键值对放在http请求中，不会出现在url中，安全性较get较好</p><p>3、get请求在url不可加入中文字符，会乱码，post可以</p><h4 id="Restful风格的接口"><a href="#Restful风格的接口" class="headerlink" title="Restful风格的接口"></a>Restful风格的接口</h4><p>1、请求头</p><p>get  表示请求数据 ，一般数据放header里面</p><p>post 表示增加数据 ，一般数据放body里面</p><p>put 表示修改数据，一般数据放body里面</p><p>delete  表示删除数据，一般数据放body里面</p><p>2、url的复用，比如work这块，写一个group里面，然后get “&#x2F;”表示获取工作信息，post“&#x2F;”增加工作信息</p><p>3、状态码，详情看上面</p><p>4、制作一个统一的返回信息的格式，写一个可以多处用的success return和error return，返回结果统一json</p><p>参考资料：<a href="https://www.nowcoder.com/discuss/833962">https://www.nowcoder.com/discuss/833962</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目遇到的问题</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%81%9A%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98_%E8%80%81%E7%89%88/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E5%81%9A%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98_%E8%80%81%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>1、url最后加了一个&#x2F;</p><p>不加”&#x2F;“,系统会自动进行301的重定向，把url变成末尾加”&#x2F;“的地址。而request.getParameter(“”)仅有一次生命周期，经过两次跳转后，前系统传的值失效了。此外，如直接发送 URL：<a href="http://msdn.microsoft.com/ie/">http://msdn.microsoft.com/ie/</a> 比发送<a href="http://msdn.microsoft.com/ie%E9%80%9F%E5%BA%A6%E5%B0%86%E4%BC%9A%E6%9B%B4%E5%BF%AB%EF%BC%8C%E5%BD%93%E7%84%B6%E8%BF%99%E7%A7%8D%E9%80%9F%E5%BA%A6%E6%98%AF%E6%84%9F%E8%A7%89%E4%B8%8D%E5%88%B0%E7%9A%84%EF%BC%8C%E4%BD%86%E4%BC%98%E5%8C%96%E5%BA%94%E8%AF%A5%E2%80%9C%E5%B0%BD%E5%8F%AF%E8%83%BD%E2%80%9D%EF%BC%8C%E5%87%8F%E5%B0%91%E6%B5%AA%E8%B4%B9%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%82">http://msdn.microsoft.com/ie速度将会更快，当然这种速度是感觉不到的，但优化应该“尽可能”，减少浪费的时间。</a></p><p><strong>2、开发app遇到过什么问题</strong></p><p>有一个第一次登陆时会黑屏的bug，因为黑屏的时候是后台使用webview登陆上课啦界面隐藏的原因，原因是路由转跳时间太短啦，原来是100ms，改成6s就不会导致黑屏，为什么要后台登陆是因为上课啦得学校的统一登陆平台的token，但是那个token是一小时后失效，所以每次登陆后台请求才能实现免登。</p><p>都是一些小显示错误bug修复，比如空安全导致加载失败之类的，加一个判断数据是否为空就行。</p><p><strong>3、各个界面是怎么实现免登的</strong></p><p>通过<a href="">oauth2协议</a>获得学校cas登陆的token，然后登陆成功之后再用oauth服务以第三方的形式请求助手服务的token，然后实现统一免登的是发现页很多app，先请求接口获得所有app的实现免登的方式，然后要登陆的时候代码判断用</p><ul><li>我们这边有自己官网的界面，是在url后面加上？auth+token的形式实现免登</li><li>老版本的lemon是从接口获得workflow参数然后重定向到一个地址，再请求这个地址加上token才可以实现免登。</li><li>都是有免登协议的，访问的接口帮我们中间封装了一层就会很方便</li></ul><p><strong>4、数据库是怎么设计的，索引怎么加，怎么排查哪边慢</strong></p><p>数据库开启慢查询日志，可以看到哪句数据库执行慢，使用explain来看这句查询语句是否使用了索引,看type和extra里面的数据</p><p><a href="http://sjy.我爱你/2022/03/20/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95explain/">using explain</a></p><p><strong>5、数据库是怎么benchmark的</strong></p><p>​    业务是告诉你学号然后查一个excel表告诉你这个学号的姓名，从老的数据库取6w条数据来，老数据库很慢是因为完全不加索引，查一个数据是2&#x2F;n的时间复杂度，然后用写好的程序把这6w条数据重新转化成二维string然后再插入到新数据库，然后随机查询100条数据看是否会查询失败和查询到时间。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA的垃圾回收</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/JAVA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/JAVA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p>1、怎么样进行垃圾回收</p><p>它自动地释放不再被程序引用的对象，java会在所有活的进程中判断如果没有进程引用它就把它放入删除缓冲区之后隔段时间删除</p><p>2、哪时候运行GC</p><p>在内存快满时或手动执行</p><p>3、可以程序员手动操控吗？</p><p>不可以，是jvm按照程序来回收内存，该对象符合删除条件，就将其加入回收队列，但不是立即销毁对象，何时销毁并释放内存是无法预知的。。</p><p>4、什么内存GC不回收</p><p>静态变量</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON和XML的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/JSON%E5%92%8CXML%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/JSON%E5%92%8CXML%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>(1)XML定义</strong><br>扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML使用DTD(document type definition)文档类型定义来组织数据;格式统一，跨平台和语言，早已成为业界公认的标准。<br>XML是标准通用标记语言 (SGML) 的子集，非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。</p><p><strong>(2)JSON定义</strong><br>JSON(JavaScript Object Notation)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。JSON采用兼容性很高的、完全独立于语言文本格式，同时也具备类似于C语言的习惯(包括C, C++, C#, Java, JavaScript, Perl, Python等)体系的行为。这些特性使JSON成为理想的数据交换语言。<br>JSON基于JavaScript Programming Language , Standard ECMA-262 3rd Edition - December 1999 的一个子集。</p><h4 id="XML的优缺点"><a href="#XML的优缺点" class="headerlink" title="XML的优缺点"></a>XML的优缺点</h4><p>​    <strong>优点：</strong>1、格式统一，符合标准</p><p>​                2、容易和其他系统进行远程交互</p><p>​                3、SAX解析方式XML提供了对大规模数据的逐步解析方案，这种方案很适合于对大量数据的处理。</p><p>​    <strong>缺点：</strong>1、服务端和客户端解析需要花费大量时间和资源，代码效率过低</p><p>​                2、XML文件庞大，格式复杂，不易压缩，传输占带宽</p><p>​                3、不同浏览器解析XML格式不一样，不兼容</p><h4 id="JSON的优缺点"><a href="#JSON的优缺点" class="headerlink" title="JSON的优缺点"></a>JSON的优缺点</h4><p>​    优点：1、文件简单，格式简单，易压缩，占用带宽小，传输速度更快</p><p>​                2、解析简单，简单的对JSON数据进行读取，占很少服务器时间</p><p>​                3、JSON格式能直接为服务器端代码使用，大大简化服务器端和客户端的代码开发量</p><p>​    缺点：1、没有XML推广的那么深入人心，没有XML那么通用性</p><p>​                2、JSON只提供整体解析方案，而这种方法只在解析较少的数据时才能起到良好的效果</p><p>​                </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>json</category>
      
    </categories>
    
    
    <tags>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java网易后端一面面试问题</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E7%BD%91%E6%98%93%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/java%E7%BD%91%E6%98%93%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1、有没有了解过spring</p><p>没有了解过</p><p>2、java的继承封装多态概念</p><p>封装:隐藏对象的属性和细节，对外提供公共访问方式，让使用者只能通过程序员规定的方法来访问数据</p><p>继承：子类继承父类的方法，具有父类非private 的方法</p><p>多态：重写和重载是实现多态的两种主要方式</p><p>（1）、重写：子类定义了一个方法，其方法名、返回值类型，参数列表与父类中某个方法一样，就说子类重写父类的同名方法。</p><p>（2）、重载：同一个类中存在多个方法的方法名相同，但是参数列表不同，体现了多态。</p><p>3、gorm框架中怎么把go语句转化成mysql语句</p><p>​    对象关系映射（Object Relational Mapping，简称ORM），在业务逻辑层和数据库之间充当桥梁，能够把struct类映射成表，将sql查询全部封装成编程语言的函数，通过函数的链式组合生成最终的sql代码</p><p>4、协程的调度</p><p>每个协程有独立的栈，而栈既保留了变量的值，也保留了函数的调用关系、参数和返回值，CPU中的栈寄存器SP指向了当前协程的栈，而指令寄存器IP保存着下一条要执行的指令地址。因此，从协程1切换到协程2时，首先要把SP、IP寄存器的值为线程1保存下来，再从内存中找出协程2上一次切换前保存好的寄存器值，写入CPU的寄存器，这样就完成了协程切换。（Swoole4实现原理相似。）</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>接口和抽象类的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/java/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ol><li>抽象类只能继承一次，但是可以实现多个接口</li><li>接口和抽象类必须实现其中所有的方法，抽象类中如果有未实现的抽象方法，那么子类也需要定义为抽象类。抽象类中可以有非抽象的方法，继承接口必须实现接口的全部方法</li><li>接口中的变量必须用 public static final 修饰，并且需要给出初始值。所以实现类不能重新定义，也不能改变其值。</li><li>接口中的方法默认是 public abstract，也只能是这个类型。不能是 static，接口中的方法也不允许子类覆写，抽象类中允许有static 的方法</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆和栈的区别</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h4><ul><li>申请方式不同：栈是由系统自动分配的，堆是程序员自己申请的（实例化一个对象）</li><li>申请大小不同：栈申请获得的空间较小，堆获得的空间较大</li><li>申请效率不同：栈由系统自动分配，速度较快，堆分配速度较慢</li><li>底层不同，栈是连续空间，堆是分散空间</li><li>存储内容不同：栈在函数调用时，在声明一个函数或者声明一个局部变量时会把这个函数放入栈中，函数的各种参数入栈，然后函数结束这个函数就从栈中pop掉，堆一般是头部用一个字节存放堆的大小,存放静态变量，堆中具体内容是人为安排，长时间不用会被gc掉。</li></ul><p>内存泄露：堆内存中内存申请了但是没有释放，每次执行就会申请内存以至于可用内存减少。</p><h4 id="函数调用时候栈是怎么push和pop的"><a href="#函数调用时候栈是怎么push和pop的" class="headerlink" title="函数调用时候栈是怎么push和pop的"></a>函数调用时候栈是怎么push和pop的</h4><p>先讲栈是怎么push的，在A函数调用B的时候，函数的栈会向高地址扩张，会把<strong>函数调用过程</strong>中的各种信息（参数，返回地址，本地变量等）放入栈中，并且会有栈顶指针和栈底指针分别指向B的栈顶和B的栈底，然后在运行完pop的时候会根据返回地址把原来指向B栈底的指针指向返回地址（A的栈底），栈顶B指向新的A的栈顶（就是运行完的函数的B的栈底）。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GMP</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/GMP/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/GMP/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是GMP？"><a href="#1、什么是GMP？" class="headerlink" title="1、什么是GMP？"></a>1、什么是GMP？</h3><p><strong>GMP是golang 1.1出现的特性，由1.0版本的GM模型演化而来</strong></p><p>G是goroutine,M全称是Machine内核级线程，P是逻辑处理器（Processor），提供执行一个 go 语言代码片段所需要的资源，内存分配状态，任务队列（G），存储了所有需要它来调度的G，可以用户使用gomaxprocs来设置。就是讲golang怎么从cup到实现goroutine</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0h97o56kkj20pb0nnq48.jpg"></p><h3 id="2、如果某个M陷入阻塞如何处理？"><a href="#2、如果某个M陷入阻塞如何处理？" class="headerlink" title="2、如果某个M陷入阻塞如何处理？"></a>2、如果某个M陷入阻塞如何处理？</h3><p>当一个os线程由于io操作而陷入阻塞，P会带其中的G链接到其他M中去，如果M恢复了，会从别的M上拿过来一个P，把原先跑在上面的G0放到p的队列里面，如果找不到P，就把运行在其上面的G0放到全局global runqueue里面。</p><h3 id="3、如果有的M较忙，有的M较闲？"><a href="#3、如果有的M较忙，有的M较闲？" class="headerlink" title="3、如果有的M较忙，有的M较闲？"></a>3、如果有的M较忙，有的M较闲？</h3><p>链接M的P中gorouitne做完了，会去global runqueue中要G，如果没有会从别的M里面要G，一般是一个进程的一半Goroutine。</p><h3 id="4、如果一个G的运行时间过长，导致队列中后续G无法运行？"><a href="#4、如果一个G的运行时间过长，导致队列中后续G无法运行？" class="headerlink" title="4、如果一个G的运行时间过长，导致队列中后续G无法运行？"></a>4、如果一个G的运行时间过长，导致队列中后续G无法运行？</h3><p>会专门创建一个线程sysmon，用于监控和管理，在内部是一个循环，记录所有P的G任务计数schedtick，如果一个P的schedtick一直不增加说明一个G一直在运行，如果运行时间太长（&gt;10ms）就给这个goroutine打标记，下一次遇到这个就直接放到总队列的最后</p><h3 id="5、一个G由于调用被中断，此后如何恢复？"><a href="#5、一个G由于调用被中断，此后如何恢复？" class="headerlink" title="5、一个G由于调用被中断，此后如何恢复？"></a>5、一个G由于调用被中断，此后如何恢复？</h3><p>终端你的时候把在寄存器中的栈信息重新赋值给G，等下一次运行把保存的信息复制到栈里面就可。</p><h3 id="GMP调度流程"><a href="#GMP调度流程" class="headerlink" title="GMP调度流程"></a>GMP调度流程</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0ha3u9e5fj20u00gwdha.jpg"></p><ul><li><ul><li><ol><li>调用 go func()创建一个goroutine；</li></ol></li><li><ol start="2"><li>新创建的G优先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</li></ol></li><li><ol start="3"><li>M需要在P的本地队列弹出一个可执行的G，如果P的本地队列为空，则先会去全局队列中获取G，如果全局队列也为空则去其他P中偷取G放到自己的P中</li></ol></li><li><ol start="4"><li>G将相关参数传输给M，为M执行G做准备</li></ol></li><li><ol start="5"><li>当M执行某一个G时候如果发生了系统调用产生导致M会阻塞，如果当前P队列中有一些G，runtime会将线程M和P分离，然后再获取空闲的线程或创建一个新的内核级的线程来服务于这个P，阻塞调用完成后G被销毁将值返回；</li></ol></li><li><ol start="6"><li>销毁G，将执行结果返回</li></ol></li><li><ol start="7"><li>当M系统调用结束时候，这个M会尝试获取一个空闲的P执行，如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中。</li></ol></li></ul></li></ul><h2 id="GM与GMP"><a href="#GM与GMP" class="headerlink" title="GM与GMP"></a>GM与GMP</h2><h4 id="GMP相对于GM做了哪些优化"><a href="#GMP相对于GM做了哪些优化" class="headerlink" title="GMP相对于GM做了哪些优化"></a>GMP相对于GM做了哪些优化</h4><p>优化点有三个</p><p>1、每个 P 有自己的本地队列，而不是所有的G操作都要经过全局的G队列，这样锁的竞争会少的多的多。而 GM 模型的性能开销大头就是锁竞争。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hal3f11xj20sw0dpmxt.jpg"></p><p>2、P的本地队列平衡上，在 GMP 模型中也实现了 Work Stealing 算法，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行（通常是偷一半），减少空转，提高了资源利用率。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0hakw745aj20gp0ja74v.jpg"></p><p>3、hand off机制当M0线程因为G1进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程M1执行，同样也是提高了资源利用率。</p><h4 id="队列和线程的优化可以做在G层和M层，为什么要加一个P层呢？"><a href="#队列和线程的优化可以做在G层和M层，为什么要加一个P层呢？" class="headerlink" title="队列和线程的优化可以做在G层和M层，为什么要加一个P层呢？"></a>队列和线程的优化可以做在G层和M层，为什么要加一个P层呢？</h4><p>因为M层是放在内核的，我们无权修改，内核级也是用户级线程发展成熟才加入内核中。所以在M无法修改的情况下，所有的修改只能放在用户层。将队列和M绑定，由于hand off机制M会一直扩增，因此队列也需要一直扩增，那么为了使Work Stealing 能够正常进行，队列管理将会变的复杂。因此设定了P层作为中间层，进行队列管理，控制GMP数量（最大个数为P的数量）。</p><p>参考网站：（讲的特别好）<a href="http://www.9ong.com/072021/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85go%E8%AF%AD%E8%A8%80gmp%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B.html">http://www.9ong.com/072021/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85go%E8%AF%AD%E8%A8%80gmp%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B.html</a> </p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>defer函数</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/defer%E5%87%BD%E6%95%B0/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/defer%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="1、defer函数参数即时求值"><a href="#1、defer函数参数即时求值" class="headerlink" title="1、defer函数参数即时求值"></a>1、<strong>defer函数参数即时求值</strong></h4><pre><code class="hljs stylus">func <span class="hljs-built_in">g</span>(<span class="hljs-selector-tag">i</span> int) &#123;   fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;g i:&quot;</span>, i)&#125;func <span class="hljs-built_in">f</span>() &#123;   <span class="hljs-selector-tag">i</span> := <span class="hljs-number">100</span>   defer <span class="hljs-built_in">g</span>(i)  <span class="hljs-comment">//1</span>   fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;begin i:&quot;</span>, i)   <span class="hljs-selector-tag">i</span> = <span class="hljs-number">200</span>   fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;end i:&quot;</span>, i)   return&#125;</code></pre><p>会输出begin i :100,end i: 200,最后输出g i:100</p><p><strong>g（）函数延迟执行，参数不会</strong></p><h4 id="2、反序调用"><a href="#2、反序调用" class="headerlink" title="2、反序调用"></a>2、反序调用</h4><pre><code class="hljs gradle">func f() &#123;   defer fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;defer01&quot;</span>)   fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;begin&quot;</span>)   defer fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;defer02&quot;</span>)   fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;----&quot;</span>)   defer fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;defer03&quot;</span>)   fmt.<span class="hljs-keyword">Println</span>(<span class="hljs-string">&quot;end&quot;</span>)   <span class="hljs-keyword">return</span>&#125;</code></pre><pre><code class="hljs asciidoc"><span class="hljs-section">begin</span><span class="hljs-section">----</span>enddefer03defer02defer01</code></pre><h4 id="3、defer与return"><a href="#3、defer与return" class="headerlink" title="3、defer与return"></a>3、defer与return</h4><p><strong>defer 函数的执行既不是在 return 之后也不是在 return 之前，而是一条go语言的 return 语句包含了对 defer 函数的调用</strong>,给你举个例子：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-keyword">var</span> g = <span class="hljs-number">100</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        g = <span class="hljs-number">200</span>    &#125;()     fmt.Printf(<span class="hljs-string">&quot;f: g = %d\n&quot;</span>, g)     <span class="hljs-keyword">return</span> g&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    i := f()    fmt.Printf(<span class="hljs-string">&quot;main: i = %d, g = %d\n&quot;</span>, i, g)&#125;</code></pre><p>输出g &#x3D;100，i &#x3D;100, g &#x3D;200</p><p>这个简单理解，看看下一个例子</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-keyword">var</span> g = <span class="hljs-number">100</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (r <span class="hljs-type">int</span>) &#123;    r = g    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        r = <span class="hljs-number">200</span>    &#125;()     fmt.Printf(<span class="hljs-string">&quot;f: r = %d\n&quot;</span>, r)     r = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> r&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    i := f()    fmt.Printf(<span class="hljs-string">&quot;main: i = %d, g = %d\n&quot;</span>, i, g)&#125;</code></pre><p>输出：</p><p>r &#x3D;100</p><p>i &#x3D;200, g &#x3D;100</p><p>看起来很冲突的结果，到汇编层面来看，用gdb层面来看，我看不懂，直接说结论</p><p>defer 函数的执行既不是在 return 之后也不是在 return 之前，而是一条go语言的 return 语句包含了对 defer 函数的调用，即 return 会被翻译成如下几条伪指令</p><pre><code class="hljs go">保存返回值到栈上调用<span class="hljs-keyword">defer</span>函数调整函数栈retq指令返回</code></pre><h4 id="自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return-g是先g把值赋值给r-然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r-的值改变了，所以最后return的时候r-x3D-200。"><a href="#自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return-g是先g把值赋值给r-然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r-的值改变了，所以最后return的时候r-x3D-200。" class="headerlink" title="自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return g是先g把值赋值给r,然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r 的值改变了，所以最后return的时候r&#x3D;200。"></a>自己的理解：return有两个步骤，把值放到栈里面，然后在return退出函数栈第一个例子return g是先g把值赋值给r,然后r的值放栈里面，g值的改变无关了，第二个例子是因为r的值放到栈里面，但是后来defer的时候r 的值改变了，所以最后return的时候r&#x3D;200。</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang是怎么实现函数返回多个值的</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%20%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC%E7%9A%84/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%20%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E5%80%BC%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>Go语言是支持多值返回的。怎么实现的呢？让我们先看一看C语言是如果返回多个值的。在C中如果想返回多个值，通常会在调用函数中分配返回值的空间，并将返回值的指针传给被调函数。</p><pre><code class="hljs c"><span class="hljs-type">int</span> ret1, ret2;f(a, b, &amp;ret1, &amp;ret2)</code></pre><p>被调函数被定义为下面形式，在函数中会修改ret1和ret2。对指针参数所指向的内容的修改会被返回到调用函数，用这种方式实现多值返回。</p><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> arg1, <span class="hljs-type">int</span> arg2, <span class="hljs-type">int</span> *ret1, <span class="hljs-type">int</span> *ret2)</span>;</code></pre><p>所以，从表面上看Go的多值返回只不过像是这种实现方式的一个语法糖衣。其实简单的这么理解也没什么影响，但实际上Go不是这么干的，Go和我们常用的C编译器的函数调用协议是不同的。</p><p>假设我们定义一个Go函数如下：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(arg1, arg2 <span class="hljs-type">int</span>)</span></span> (ret1, ret2 <span class="hljs-type">int</span>)</code></pre><p>Go的做法是在传入的参数之上留了两个空位，被调者直接将返回值放在这两空位，函数f调用前其内存布局是这样的：</p><pre><code class="hljs llvm">为<span class="hljs-keyword">ret</span><span class="hljs-number">2</span>保留空位为<span class="hljs-keyword">ret</span><span class="hljs-number">1</span>保留空位参数<span class="hljs-number">3</span>参数<span class="hljs-number">2</span>参数<span class="hljs-number">1</span>  &lt;-SP</code></pre><p>调用之后变为：</p><pre><code class="hljs armasm">为ret2保留空位为ret1保留空位参数<span class="hljs-number">2</span>参数<span class="hljs-number">1</span>  &lt;-<span class="hljs-built_in">FP</span>保存<span class="hljs-built_in">PC</span> &lt;-<span class="hljs-built_in">SP</span>f的栈<span class="hljs-symbol">...</span></code></pre><p><img src="https://tiancaiamao.gitbooks.io/go-internals/content/zh/images/3.2.funcall.jpg?raw=true" alt="img"></p><p>Go的C编译器按是plan9的C编译器实现的，在被调函数中对参数值的修改是会返回到调用函数中的。在函数体中设置ret1和ret2的值，实际上会被编译成这样：</p><pre><code class="hljs x86asm"><span class="hljs-keyword">MOVQ</span>    <span class="hljs-built_in">BX</span>,ret1+<span class="hljs-number">16</span>(FP)...<span class="hljs-keyword">MOVQ</span>    <span class="hljs-built_in">BX</span>,ret2+<span class="hljs-number">24</span>(FP)</code></pre><p>对ret1+16(FP)的赋值其实是修改的调用函数的栈中的内容，这样就会将结果返回给调用函数了。这就是Go和C函数调用协议中很重要的一个区别：为了实现多值返回，Go是使用栈空间来返回值的。而常见的C语言是通过寄存器来返回值的。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang后台面试题目</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1、go struct 能不能比较</p><p>struct是强类型语言，不同类型不能比较，同类型才能比较，实例也不能比较，因为实例是指针类型</p><p>2、写出下面代码输出内容</p><pre><code class="hljs autoit">package mainimport (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">func</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;defer_call()&#125;<span class="hljs-keyword">func</span> <span class="hljs-title function_">defer_call</span><span class="hljs-params">()</span> &#123;defer <span class="hljs-keyword">func</span><span class="hljs-params">()</span> &#123; <span class="hljs-title function_">fmt</span>.<span class="hljs-title function_">Println</span><span class="hljs-params">(<span class="hljs-string">&quot;打印前&quot;</span>)</span> &#125;<span class="hljs-params">()</span>defer <span class="hljs-keyword">func</span><span class="hljs-params">()</span> &#123; <span class="hljs-title function_">fmt</span>.<span class="hljs-title function_">Println</span><span class="hljs-params">(<span class="hljs-string">&quot;打印中&quot;</span>)</span> &#125;<span class="hljs-params">()</span>defer <span class="hljs-keyword">func</span><span class="hljs-params">()</span> &#123; <span class="hljs-title function_">fmt</span>.<span class="hljs-title function_">Println</span><span class="hljs-params">(<span class="hljs-string">&quot;打印后&quot;</span>)</span> &#125;<span class="hljs-params">()</span>panic(<span class="hljs-string">&quot;触发异常&quot;</span>)&#125;</code></pre><p>打印后<br>打印中<br>打印前<br>panic: 触发异常</p><h4 id="3、range陷阱"><a href="#3、range陷阱" class="headerlink" title="3、range陷阱"></a>3、range陷阱</h4><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span>import <span class="hljs-string">&quot;fmt&quot;</span>type AStruct struct &#123;    bar string&#125;func <span class="hljs-selector-tag">main</span>() &#123;    list := <span class="hljs-selector-attr">[]</span>AStruct&#123;        &#123;<span class="hljs-string">&quot;1&quot;</span>&#125;,        &#123;<span class="hljs-string">&quot;2&quot;</span>&#125;,        &#123;<span class="hljs-string">&quot;3&quot;</span>&#125;,    &#125;    copyedList := <span class="hljs-built_in">make</span>(<span class="hljs-selector-attr">[]</span>*AStruct, <span class="hljs-built_in">len</span>(list))    <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span>,v:= range list &#123;        copyedList<span class="hljs-selector-attr">[i]</span> = &amp;v    &#125;    fmt<span class="hljs-selector-class">.Println</span>(list<span class="hljs-selector-attr">[0]</span>, list<span class="hljs-selector-attr">[1]</span>, list<span class="hljs-selector-attr">[2]</span>)    fmt<span class="hljs-selector-class">.Println</span>(copyedList<span class="hljs-selector-attr">[0]</span>, copyedList<span class="hljs-selector-attr">[1]</span>, copyedList<span class="hljs-selector-attr">[2]</span>)&#125;</code></pre><p>运行这段代码，你就会发现</p><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;2&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml"></span><span class="language-xml">&amp;</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml"> &amp;</span><span class="hljs-template-variable">&#123;3&#125;</span><span class="language-xml"> &amp;</span><span class="hljs-template-variable">&#123;3&#125;</span></code></pre><p>怎么都是同一个地址，因为range赋值用的是用的是一个循环变量的地址，Go每次循环都会复用这一”循环变量”，所以一直会输出最后一个数的地址</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> list &#123;  copyedList[i] = &amp;list[i]&#125;</code></pre><h4 id="4、变量的作用域陷阱"><a href="#4、变量的作用域陷阱" class="headerlink" title="4、变量的作用域陷阱"></a>4、变量的作用域陷阱</h4><p>下面这段程序会有什么输出结果？</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;runtime&quot;</span>    <span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)    wg := sync.WaitGroup&#123;&#125;    wg.Add(<span class="hljs-number">20</span>)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;            fmt.Println(<span class="hljs-string">&quot;A: &quot;</span>, i)            wg.Done()        &#125;()    &#125;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;            fmt.Println(<span class="hljs-string">&quot;B: &quot;</span>, i)            wg.Done()        &#125;(i)    &#125;    wg.Wait()&#125;</code></pre><p>A都输出10，B先输出9，然后按顺序输出</p><pre><code class="hljs apache"><span class="hljs-attribute">B</span>:  <span class="hljs-number">9</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">0</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">1</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">2</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">4</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">5</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">6</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">7</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">8</span></code></pre><p>如果不用runtime.GOMAXPROCS(1)约束，就会随机输出A和B，A和B中数字也随机输出,但是A是10</p><pre><code class="hljs apache"><span class="hljs-attribute">A</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">5</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">9</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">1</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">0</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">2</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">4</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">3</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">6</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">7</span><span class="hljs-attribute">B</span>:  <span class="hljs-number">8</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span><span class="hljs-attribute">A</span>:  <span class="hljs-number">10</span></code></pre><p>为什么A一直会是10，这是一个变量作用域不同引起的</p><h4 id="5、继承和组合的区别和优势劣势（还不懂）"><a href="#5、继承和组合的区别和优势劣势（还不懂）" class="headerlink" title="5、继承和组合的区别和优势劣势（还不懂）"></a>5、继承和组合的区别和优势劣势（还不懂）</h4><p><strong>继承</strong>是一个白盒模型，父类的内部细节对子类是透明的，</p><p><strong>组合</strong>是黑盒模型，父类的内部细节对子类不透明，对现有的对象进行拼装组合产生更复杂的功能</p><h5 id="继承的优点："><a href="#继承的优点：" class="headerlink" title="继承的优点："></a>继承的优点：</h5><p>易于操作，易于修改和拓展父类</p><h5 id="继承的缺点："><a href="#继承的缺点：" class="headerlink" title="继承的缺点："></a>继承的缺点：</h5><p>1、子类和父类缺乏独立性，父类改变子类不得不改变</p><p>2、破坏了封装性</p><h5 id="组合的优点"><a href="#组合的优点" class="headerlink" title="组合的优点"></a>组合的优点</h5><p>1、降低各个模块之间的耦合性</p><p>2、不会破坏封装性，只用一个接口用来连接对象内部的函数</p><p>3、减少依存关系</p><h5 id="组合的缺点"><a href="#组合的缺点" class="headerlink" title="组合的缺点"></a>组合的缺点</h5><p>1、操作困难，对不熟悉的人难以操作</p><p>2、比继承要写更多的代码</p><h4 id="6、go的组合和继承"><a href="#6、go的组合和继承" class="headerlink" title="6、go的组合和继承"></a>6、go的组合和继承</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowA() &#123;    fmt.Println(<span class="hljs-string">&quot;showA&quot;</span>)    p.ShowB()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *People)</span></span> ShowB() &#123;    fmt.Println(<span class="hljs-string">&quot;showB&quot;</span>)&#125;<span class="hljs-keyword">type</span> Teacher <span class="hljs-keyword">struct</span> &#123;    People&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Teacher)</span></span> ShowB() &#123;    fmt.Println(<span class="hljs-string">&quot;teacher showB&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    t := Teacher&#123;&#125;    t.ShowA()&#125;</code></pre><p>输出</p><pre><code class="hljs ebnf"><span class="hljs-attribute">showA</span><span class="hljs-attribute">showB</span></code></pre><p>解答：被组合的类型People虽然被包装成Teacher，执行t.ShowA()但是people并不自己会被什么类型组合，所以t.showB()不会执行</p><h4 id="7、select的随机性"><a href="#7、select的随机性" class="headerlink" title="7、select的随机性"></a>7、select的随机性</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    runtime.GOMAXPROCS(<span class="hljs-number">1</span>)    int_chan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)    string_chan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">1</span>)    int_chan &lt;- <span class="hljs-number">1</span>    string_chan &lt;- <span class="hljs-string">&quot;hello&quot;</span>    <span class="hljs-keyword">select</span> &#123;    <span class="hljs-keyword">case</span> value := &lt;-int_chan:        fmt.Println(value)    <span class="hljs-keyword">case</span> value := &lt;-string_chan:        <span class="hljs-built_in">panic</span>(value)    &#125;&#125;</code></pre><p>答案：select随机执行一个case，有一定概率出现panic（“hello”），一定概率输出1</p><h4 id="8、defer执行顺序"><a href="#8、defer执行顺序" class="headerlink" title="8、defer执行顺序"></a>8、defer执行顺序</h4><pre><code class="hljs stylus">func <span class="hljs-built_in">calc</span>(index string, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> int) int &#123;ret := <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>fmt<span class="hljs-selector-class">.Println</span>(index, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, ret)return ret&#125;func <span class="hljs-selector-tag">main</span>() &#123;<span class="hljs-selector-tag">a</span> := <span class="hljs-number">1</span><span class="hljs-selector-tag">b</span> := <span class="hljs-number">2</span>defer <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-selector-tag">a</span>, <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-selector-tag">a</span>, b))<span class="hljs-selector-tag">a</span> = <span class="hljs-number">0</span>defer <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-selector-tag">a</span>, <span class="hljs-built_in">calc</span>(<span class="hljs-string">&quot;20&quot;</span>, <span class="hljs-selector-tag">a</span>, b))<span class="hljs-selector-tag">b</span> = <span class="hljs-number">1</span>&#125;</code></pre><p>结果</p><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-symbol">20 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre><p>解析;calc(“1”, a, calc(“10”, a, b))会先对这句话里面的a，b赋值，赋值过程中先执行10，同理下一句话先执行20，再是2，最后1，因为defer是像栈一样，最后的先执行</p><h4 id="9、看看下面会有什么问题"><a href="#9、看看下面会有什么问题" class="headerlink" title="9、看看下面会有什么问题"></a>9、看看下面会有什么问题</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> UserAges <span class="hljs-keyword">struct</span> &#123;ages <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>sync.Mutex&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ua *UserAges)</span></span> Add(name <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>) &#123;ua.Lock()<span class="hljs-keyword">defer</span> ua.Unlock()ua.ages[name] = age&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ua *UserAges)</span></span> Get(name <span class="hljs-type">string</span>) <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> age, ok := ua.ages[name]; ok &#123;<span class="hljs-keyword">return</span> age&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><p>解答：在并发处理的时候可能会出现<code>fatal error: concurrent map read and map write</code>.，因为get没上锁，在同一时间读写一个东西会出现竞争</p><h4 id="10、printf和Sprintf的区别"><a href="#10、printf和Sprintf的区别" class="headerlink" title="10、printf和Sprintf的区别"></a>10、printf和Sprintf的区别</h4><p>printf</p><ol><li>用传入的格式化规则符将传入的变量写入到标准输出里面(即在终端中有显示)，</li><li>返回值为 写入标准输出的字节数和写入过程中遇到的问题。</li></ol><p>sprintf</p><ol><li>用传入的格式化规则符将传入的变量格式化，(终端中不会有显示)</li><li>返回为 格式化后的字符串。</li></ol><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span>import (    <span class="hljs-string">&quot;fmt&quot;</span>)func <span class="hljs-selector-tag">main</span>()  &#123;    testStr := <span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(<span class="hljs-string">&quot;test str&quot;</span>)    fmt<span class="hljs-selector-class">.Println</span>(testStr, <span class="hljs-string">&quot;hello world&quot;</span>)    <span class="hljs-comment">//[116 101 115 116 32 115 116 114] hello world</span>    fmt<span class="hljs-selector-class">.Printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, testStr) <span class="hljs-comment">//test str</span>    fmt<span class="hljs-selector-class">.Println</span>()    fmt<span class="hljs-selector-class">.Sprintf</span>(<span class="hljs-string">&quot;%s&quot;</span>, testStr) <span class="hljs-comment">//空，无IO输出</span>    fmt<span class="hljs-selector-class">.Println</span>()    printStr := fmt<span class="hljs-selector-class">.Sprintf</span>(<span class="hljs-string">&quot;%s&quot;</span>, testStr)    fmt<span class="hljs-selector-class">.Println</span>(printStr)    <span class="hljs-comment">//test str</span>&#125;</code></pre><p>sprintf就是把一个[]byte类型的东西格式化成string</p><h4 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h4><p>​    二者都是内存的分配（堆上），但是make只用于slice、map以及channel的初始化（非零值）；而new用于类型的内存分配，并且内存置为零。所以在我们编写程序的时候，就可以根据自己的需要很好的选择了。</p><p>make返回的还是这三个引用类型本身；而new返回的是指向类型的指针。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang内存分配</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>go语言启动时会分配一块内存，然后切成小块进行管理，分成span，bitmap，arena，</p><p>arena：将内存分成8kb的页（page），一起组成起来称mspan，成为go内存管理的基本单元。</p><p>bitmap：标记堆区使用的映射表，记录哪些区保存对象，哪些区包含指针</p><p>spans:存放mspan指针，根据spans信息很容易找到mspan，可以在GC时更快速找到大块内存mspan。</p><h3 id="goroutine的栈内存分配"><a href="#goroutine的栈内存分配" class="headerlink" title="goroutine的栈内存分配"></a>goroutine的栈内存分配</h3><p>在<code>Go</code>应用程序运行时，每个<code>goroutine</code>都维护着一个自己的栈区，这个栈区只能自己使用不能被其他<code>goroutine</code>使用。<strong>栈区的初始大小是2KB</strong>（比x86_64架构下线程的默认栈2M要小很多），在<code>goroutine</code>运行的时候栈区会按照需要增长和收缩，占用的内存最大限制的默认值在64位系统上是1GB。栈大小的初始值和上限这部分的设置都可以在<code>Go</code>的源码<code>runtime/stack.go</code>里找到：</p><pre><code class="hljs go"><span class="hljs-comment">// rumtime.stack.go</span><span class="hljs-comment">// The minimum size of stack used by Go code</span>_StackMin = <span class="hljs-number">2048</span><span class="hljs-keyword">var</span> maxstacksize <span class="hljs-type">uintptr</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span> <span class="hljs-comment">// enough until runtime.main sets it for real</span></code></pre><p>其实栈内存空间、结构和初始大小在最开始并不是2KB，也是经过了几个版本的更迭</p><ul><li>v1.0 ~ v1.1 — 最小栈内存空间为 4KB；</li><li>v1.2 — 将最小栈内存提升到了 8KB；</li><li>v1.3 — 使用<strong>连续栈</strong>替换之前版本的分段栈；</li><li>v1.4 — 将最小栈内存降低到了 2KB；</li></ul><h3 id="分段栈和连续栈"><a href="#分段栈和连续栈" class="headerlink" title="分段栈和连续栈"></a>分段栈和连续栈</h3><h4 id="分段栈"><a href="#分段栈" class="headerlink" title="分段栈"></a>分段栈</h4><p>Go 1.3 版本前使用的栈结构是分段栈，随着<code>goroutine</code> 调用的函数层级的深入或者局部变量需要的越来越多时，运行时会调用 <code>runtime.morestack</code> 和 <code>runtime.newstack</code>创建一个新的栈空间，这些栈空间是不连续的，但是当前 <code>goroutine</code> 的多个栈空间会以双向链表的形式串联起来，运行时会通过指针找到连续的栈片段：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98871ce62ad74f578ddcc1f879c49f07~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>分段栈虽然能够按需为当前 <code>goroutine</code> 分配内存并且及时减少内存的占用，但是它也存在一个比较大的问题：</p><ul><li>如果当前 <code>goroutine</code> 的栈几乎充满，那么任意的函数调用都会触发栈的扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）。</li></ul><p>为了解决这个问题，Go在1.2版本的时候不得不将栈的初始化内存从4KB增大到了8KB。后来把采用连续栈结构后，又把初始栈大小减小到了2KB。</p><h3 id="连续栈"><a href="#连续栈" class="headerlink" title="连续栈"></a>连续栈</h3><p>连续栈可以解决分段栈中存在的两个问题，其核心原理就是每当程序的栈空间不足时，初始化一片比旧栈大两倍的新栈并将原栈中的所有值都迁移到新的栈中，新的局部变量或者函数调用就有了充足的内存空间。使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：</p><ol><li>调用用<code>runtime.newstack</code>在内存空间中分配更大的栈内存空间；</li><li>使用<code>runtime.copystack</code>将旧栈中的所有内容复制到新的栈中；</li><li><strong>将指向旧栈对应变量的指针重新指向新栈</strong>；</li><li>调用<code>runtime.stackfree</code>销毁并回收旧栈的内存空间；</li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/498c581f48894526850a3f05708b38c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><h4 id="栈区的内存管理"><a href="#栈区的内存管理" class="headerlink" title="栈区的内存管理"></a>栈区的内存管理</h4><p>前面说了每个<code>goroutine</code>都维护着自己的栈区，栈结构是连续栈，是一块连续的内存，在<code>goroutine</code>的类型定义的源码里我们可以找到标记着栈区边界的<code>stack</code>信息，<code>stack</code>里记录着栈区边界的高位内存地址和低位内存地址：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;stack       stack  ...&#125;<span class="hljs-keyword">type</span> stack <span class="hljs-keyword">struct</span> &#123;lo <span class="hljs-type">uintptr</span>hi <span class="hljs-type">uintptr</span>&#125;</code></pre><h3 id="栈扩容"><a href="#栈扩容" class="headerlink" title="栈扩容"></a>栈扩容</h3><p>编译器会为函数调用插入运行时检查<code>runtime.morestack</code>，它会在几乎所有的函数调用之前检查当前<code>goroutine</code> 的栈内存是否充足，如果当前栈需要扩容，会调用<code>runtime.newstack</code> 创建新的栈：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newstack</span><span class="hljs-params">()</span></span> &#123;   ......   <span class="hljs-comment">// Allocate a bigger segment and move the stack.</span>   oldsize := gp.stack.hi - gp.stack.lo   newsize := oldsize * <span class="hljs-number">2</span>   <span class="hljs-keyword">if</span> newsize &gt; maxstacksize &#123;       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;runtime: goroutine stack exceeds &quot;</span>, maxstacksize, <span class="hljs-string">&quot;-byte limit\n&quot;</span>)      throw(<span class="hljs-string">&quot;stack overflow&quot;</span>)   &#125;   <span class="hljs-comment">// The goroutine must be executing in order to call newstack,</span>   <span class="hljs-comment">// so it must be Grunning (or Gscanrunning).</span>   casgstatus(gp, _Grunning, _Gcopystack)   <span class="hljs-comment">// The concurrent GC will not scan the stack while we are doing the copy since</span>   <span class="hljs-comment">// the gp is in a Gcopystack status.</span>   copystack(gp, newsize, <span class="hljs-literal">true</span>)   <span class="hljs-keyword">if</span> stackDebug &gt;= <span class="hljs-number">1</span> &#123;      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;stack grow done\n&quot;</span>)   &#125;   casgstatus(gp, _Gcopystack, _Grunning)&#125;复制代码</code></pre><p>旧栈的大小是通过我们上面说的保存在<code>goroutine</code>中的<code>stack</code>信息里记录的栈区内存边界计算出来的，然后用旧栈两倍的大小创建新栈，创建前会检查是新栈的大小是否超过了单个栈的内存上限。</p><pre><code class="hljs go">   oldsize := gp.stack.hi - gp.stack.lo   newsize := oldsize * <span class="hljs-number">2</span>   <span class="hljs-keyword">if</span> newsize &gt; maxstacksize &#123;       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;runtime: goroutine stack exceeds &quot;</span>, maxstacksize, <span class="hljs-string">&quot;-byte limit\n&quot;</span>)      throw(<span class="hljs-string">&quot;stack overflow&quot;</span>)   &#125;复制代码</code></pre><p>如果目标栈的大小没有超出程序的限制，会将 <code>goroutine</code> 切换至 <code>_Gcopystack</code> 状态并调用 <code>runtime.copystack</code> 开始栈的拷贝，在拷贝栈的内存之前，运行时会先通过<code>runtime.stackalloc</code> 函数分配新的栈空间：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copystack</span><span class="hljs-params">(gp *g, newsize <span class="hljs-type">uintptr</span>)</span></span> &#123;old := gp.stackused := old.hi - gp.sched.sp  <span class="hljs-comment">// 创建新栈</span><span class="hljs-built_in">new</span> := stackalloc(<span class="hljs-type">uint32</span>(newsize))...  <span class="hljs-comment">// 把旧栈的内容拷贝至新栈</span>memmove(unsafe.Pointer(<span class="hljs-built_in">new</span>.hi-ncopy), unsafe.Pointer(old.hi-ncopy), ncopy)  ...  <span class="hljs-comment">// 调整指针</span>  adjustctxt(gp, &amp;adjinfo)  <span class="hljs-comment">// groutine里记录新栈的边界</span>  gp.stack = <span class="hljs-built_in">new</span>  ...  <span class="hljs-comment">// 释放旧栈</span>  stackfree(old)&#125;复制代码</code></pre><p>新栈的初始化和数据的复制是一个比较简单的过程，整个过程中最复杂的地方是将指向源栈中内存的指针调整为指向新的栈，这一步完成后就会释放掉旧栈的内存空间了。</p><p>我们可以通过修改一下源码文件<code>runtime.stack.go</code>，把常量<code>stackDebug</code>的值修改为1，使用命令<strong>go build -gcflags -S main.go</strong> 运行文章最开始的那个例子，观察栈的初始化和扩容过程：</p><pre><code class="hljs shell">stackalloc 2048stackcacherefill order=0  allocated 0xc000030000...copystack gp=0xc000000180 [0xc000030000 0xc0000306e0 0xc000030800] -&gt; [0xc00005c000 0xc00005cee0 0xc00005d000]/4096stackfree 0xc000030000 2048stack grow done...copystack gp=0xc000000180 [0xc00005c000 0xc00005c890 0xc00005d000] -&gt; [0xc000064000 0xc000065890 0xc000066000]/8192stackfree 0xc00005c000 4096stack grow done...copystack gp=0xc000000180 [0xc000064000 0xc000065890 0xc000066000] -&gt; [0xc00006c000 0xc00006f890 0xc000070000]/16384stackfree 0xc000064000 8192stack grow done...copystack gp=0xc000000180 [0xc00006c000 0xc00006f890 0xc000070000] -&gt; [0xc000070000 0xc000077890 0xc000078000]/32768stackfree 0xc00006c000 16384stack grow done复制代码</code></pre><h3 id="栈缩容"><a href="#栈缩容" class="headerlink" title="栈缩容"></a>栈缩容</h3><p>在<code>goroutine</code>运行的过程中，如果栈区的空间使用率不超过1&#x2F;4，那么在垃圾回收的时候使用<code>runtime.shrinkstack</code>进行栈缩容，当然进行缩容前会执行一堆前置检查，都通过了才会进行缩容</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shrinkstack</span><span class="hljs-params">(gp *g)</span></span> &#123;...oldsize := gp.stack.hi - gp.stack.lonewsize := oldsize / <span class="hljs-number">2</span><span class="hljs-keyword">if</span> newsize &lt; _FixedStack &#123;<span class="hljs-keyword">return</span>&#125;avail := gp.stack.hi - gp.stack.lo<span class="hljs-keyword">if</span> used := gp.stack.hi - gp.sched.sp + _StackLimit; used &gt;= avail/<span class="hljs-number">4</span> &#123;<span class="hljs-keyword">return</span>&#125;copystack(gp, newsize)&#125;复制代码</code></pre><p>如果要触发栈的缩容，新栈的大小会是原始栈的一半，不过如果新栈的大小低于程序的最低限制 2KB，那么缩容的过程就会停止。缩容也会调用扩容时使用的 <code>runtime.copystack</code> 函数开辟新的栈空间，将旧栈的数据拷贝到新栈以及调整原来指针的指向。</p><p>在我们上面的那个例子里，当<code>main</code>函数里的其他函数执行完后，只有<code>main</code>函数还在栈区的空间里，如果这个时候系统进行垃圾回收就会对这个<code>goroutine</code>的栈区进行缩容。在这里我们可以在程序里通过调用<code>runtime.GC</code>，强制系统进行垃圾回收，来试验看一下栈缩容的过程和效果：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   <span class="hljs-keyword">var</span> x [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>   <span class="hljs-built_in">println</span>(&amp;x)   a(x)   runtime.GC()   <span class="hljs-built_in">println</span>(&amp;x)&#125;复制代码</code></pre><p>执行命令<strong>go build -gcflags -S main.go</strong>后会看到类似下面的输出。</p><pre><code class="hljs dns">...shrinking stack <span class="hljs-number">32768</span>-&gt;<span class="hljs-number">16384</span>stackalloc <span class="hljs-number">16384</span>  allocated <span class="hljs-number">0</span>xc<span class="hljs-number">000076000</span>copystack gp=<span class="hljs-number">0</span>xc<span class="hljs-number">000000180</span> [<span class="hljs-number">0</span>xc<span class="hljs-number">00007a000</span> <span class="hljs-number">0</span>xc<span class="hljs-number">000081e60</span> <span class="hljs-number">0</span>xc<span class="hljs-number">000082000</span>] -&gt; [<span class="hljs-number">0</span>xc<span class="hljs-number">000076000</span> <span class="hljs-number">0</span>xc<span class="hljs-number">000079e60</span> <span class="hljs-number">0</span>xc<span class="hljs-number">00007a000</span>]/<span class="hljs-number">16384</span>...复制代码</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>参考文章：</strong><a href="https://juejin.cn/post/6871550379432574990">https://juejin.cn/post/6871550379432574990</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言runtime</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80runtime/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80runtime/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/map/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/map/</url>
    
    <content type="html"><![CDATA[<h2 id="map是怎么实现的"><a href="#map是怎么实现的" class="headerlink" title="map是怎么实现的"></a>map是怎么实现的</h2><p>Go 语言采用的是哈希查找表，并且使用链表解决哈希冲突。</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span> A header <span class="hljs-keyword">for</span> a Go map.type hmap struct &#123;    <span class="hljs-regexp">//</span> 元素个数，调用 len(map) 时，直接返回此值    count     int    flags     uint8    <span class="hljs-regexp">//</span> buckets 的对数 log_2    B         uint8    <span class="hljs-regexp">//</span> overflow 的 bucket 近似数    noverflow uint16    <span class="hljs-regexp">//</span> 计算 key 的哈希的时候会传入哈希函数    hash0     uint32    <span class="hljs-regexp">//</span> 指向 buckets 数组，大小为 <span class="hljs-number">2</span>^B    <span class="hljs-regexp">//</span> 如果元素个数为<span class="hljs-number">0</span>，就为 nil    buckets    unsafe.Pointer    <span class="hljs-regexp">//</span> 扩容的时候，buckets 长度会是 oldbuckets 的两倍    oldbuckets unsafe.Pointer    <span class="hljs-regexp">//</span> 指示扩容进度，小于此地址的 buckets 迁移完成    nevacuate  uintptr    extra *mapextra <span class="hljs-regexp">//</span> optional fields&#125;</code></pre><p>map分为hmap和bmap，hmap是一个哈希表，bmap是一个数组，golang用链表法解决哈希冲突，如果溢出会弄一个溢出bucket放进去。</p><p>bmap 是存放 k-v 的地方，我们把视角拉近，仔细看 bmap 的内部组成。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;    topbits  [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span>    keys     [<span class="hljs-number">8</span>]keytype    values   [<span class="hljs-number">8</span>]valuetype    pad      <span class="hljs-type">uintptr</span>    overflow <span class="hljs-type">uintptr</span>&#125;</code></pre><p><img src="https://user-images.githubusercontent.com/7698088/57577391-f88f1d80-74a7-11e9-893c-4783dc4fb35e.png" alt="img"></p><h3 id="创建map"><a href="#创建map" class="headerlink" title="创建map"></a>创建map</h3><p>从语法层面上来说，创建 map 很简单：</p><pre><code class="hljs go">ageMp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<span class="hljs-comment">// 指定 map 长度</span>ageMp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">8</span>)<span class="hljs-comment">// ageMp 为 nil，不能向其添加元素，会直接panic</span><span class="hljs-keyword">var</span> ageMp <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span></code></pre><p>通过汇编语言可以看到，实际上底层调用的是 <code>makemap</code> 函数，主要做的工作就是初始化 <code>hmap</code> 结构体的各种字段，例如计算 B 的大小，设置哈希种子 hash0 等等。</p><pre><code>func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap &#123; // 省略各种条件检查...// 找到一个 B，使得 map 的装载因子在正常范围内B := uint8(0)for ; overLoadFactor(hint, B); B++ &#123;&#125;// 初始化 hash table// 如果 B 等于 0，那么 buckets 就会在赋值的时候再分配// 如果长度比较大，分配内存会花费长一点buckets := bucketvar extra *mapextraif B != 0 &#123;    var nextOverflow *bmap    buckets, nextOverflow = makeBucketArray(t, B)    if nextOverflow != nil &#123;        extra = new(mapextra)        extra.nextOverflow = nextOverflow    &#125;&#125;// 初始化 hampif h == nil &#123;    h = (*hmap)(newobject(t.hmap))&#125;h.count = 0h.B = Bh.extra = extrah.flags = 0h.hash0 = fastrand()h.buckets = bucketsh.oldbuckets = nilh.nevacuate = 0h.noverflow = 0return h&#125;</code></pre><h2 id="key-定位过程"><a href="#key-定位过程" class="headerlink" title="key 定位过程"></a>key 定位过程</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h58uhkib28j20u01270vw.jpg"></p><p>key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B &#x3D; 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 &#x3D; 32。</p><p>例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：</p><p> 10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</p><p>用最后的 5 个 bit 位，也就是 <code>01010</code>，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。</p><p>再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。</p><p>buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p><h3 id="map扩容过程是怎么样的"><a href="#map扩容过程是怎么样的" class="headerlink" title="map扩容过程是怎么样的"></a>map扩容过程是怎么样的</h3><p>需要一个指标来判断是否要扩容，这就是<code>装载因子</code>。Go 源码里这样定义 <code>装载因子</code>：</p><pre><code class="hljs apache"><span class="hljs-attribute">loadFactor</span> := count / (<span class="hljs-number">2</span>^B)</code></pre><p>count 就是 map 的元素个数，2^B 表示 bucket 数量。</p><p>再来说触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：</p><ol><li>装载因子超过阈值，源码里定义的阈值是 6.5。</li><li>overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &gt;&#x3D; 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。</li></ol><pre><code class="hljs reasonml"><span class="hljs-comment">// src/runtime/hashmap.go/mapassign</span><span class="hljs-comment">// 触发扩容时机</span><span class="hljs-keyword">if</span> !h.growing<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>(over<span class="hljs-constructor">LoadFactor(<span class="hljs-params">int64</span>(<span class="hljs-params">h</span>.<span class="hljs-params">count</span>)</span>, h.B)<span class="hljs-operator"> || </span>too<span class="hljs-constructor">ManyOverflowBuckets(<span class="hljs-params">h</span>.<span class="hljs-params">noverflow</span>, <span class="hljs-params">h</span>.B)</span>) &#123;        hash<span class="hljs-constructor">Grow(<span class="hljs-params">t</span>, <span class="hljs-params">h</span>)</span>    &#125;<span class="hljs-comment">// 装载因子超过 6.5</span>func over<span class="hljs-constructor">LoadFactor(<span class="hljs-params">count</span> <span class="hljs-params">int64</span>, B <span class="hljs-params">uint8</span>)</span> <span class="hljs-built_in">bool</span> &#123;    return count &gt;= bucketCnt<span class="hljs-operator"> &amp;&amp; </span>float32(count) &gt;= loadFactor*float32((uint64(<span class="hljs-number">1</span>)&lt;&lt;B))&#125;<span class="hljs-comment">// overflow buckets 太多</span>func too<span class="hljs-constructor">ManyOverflowBuckets(<span class="hljs-params">noverflow</span> <span class="hljs-params">uint16</span>, B <span class="hljs-params">uint8</span>)</span> <span class="hljs-built_in">bool</span> &#123;    <span class="hljs-keyword">if</span> B &lt; <span class="hljs-number">16</span> &#123;        return noverflow &gt;= uint16(<span class="hljs-number">1</span>)&lt;&lt;B    &#125;    return noverflow &gt;= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>&#125;</code></pre><p>再来看看真正执行搬迁工作的 growWork() 函数。</p><pre><code class="hljs reasonml">func grow<span class="hljs-constructor">Work(<span class="hljs-params">t</span> <span class="hljs-operator">*</span><span class="hljs-params">maptype</span>, <span class="hljs-params">h</span> <span class="hljs-operator">*</span><span class="hljs-params">hmap</span>, <span class="hljs-params">bucket</span> <span class="hljs-params">uintptr</span>)</span> &#123;    <span class="hljs-comment">// 确认搬迁老的 bucket 对应正在使用的 bucket</span>    evacuate(t, h, bucket&amp;h.oldbucketmask<span class="hljs-literal">()</span>)    <span class="hljs-comment">// 再搬迁一个 bucket，以加快搬迁进程</span>    <span class="hljs-keyword">if</span> h.growing<span class="hljs-literal">()</span> &#123;        evacuate(t, h, h.nevacuate)    &#125;&#125;</code></pre><p>h.growing() 函数非常简单：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hmap)</span></span> growing() <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">return</span> h.oldbuckets != <span class="hljs-literal">nil</span>&#125;</code></pre><p>如果 <code>oldbuckets</code> 不为空，说明还没有搬迁完毕，还得继续搬。</p><p>TODO:evacuate函数干了什么下次看懂源码再写，一个搬迁的细节是搬到大内存去的时候得重新hash计算放到哪个bucket中，因为比原来多了一位。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1、为什么map不可以寻址，map是怎么存储的"><a href="#1、为什么map不可以寻址，map是怎么存储的" class="headerlink" title="1、为什么map不可以寻址，map是怎么存储的"></a>1、为什么map不可以寻址，map是怎么存储的</h3><ol><li>如果字典的元素不存在，则返回零值，而零值是不可变对象，如果能寻址问题就大了。</li><li>而如果字典的元素存在，考虑到 Go 中 map 实现中元素的地址是变化的，这意味着寻址的结果也是无意义的。</li></ol><p>参考网站：<a href="https://qcrao91.gitbook.io/go/map/map-de-di-ceng-shi-xian-yuan-li-shi-shi-mo">https://qcrao91.gitbook.io/go/map/map-de-di-ceng-shi-xian-yuan-li-shi-shi-mo</a></p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go slice 扩容深度分析（1.18版本的golang已经改变之前的分配方式）</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E5%88%87%E7%89%87/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h4 id="1、切片扩容常规操作"><a href="#1、切片扩容常规操作" class="headerlink" title="1、切片扩容常规操作"></a>1、切片扩容常规操作</h4><p>如果超过容量，会重新扩一个内存，创建新的数组，并把指针指向这个数组，容量如果不超过1024会扩一倍，如果容量超过1024扩容量会每次增加25%。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    a := []<span class="hljs-type">int</span>&#123;&#125;    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">33</span>; i++ &#123;        a = <span class="hljs-built_in">append</span>(a, i)        fmt.Print(<span class="hljs-built_in">cap</span>(a), <span class="hljs-string">&quot; &quot;</span>)    &#125;&#125;</code></pre><p>结果：</p><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">32</span> <span class="hljs-number">64</span></code></pre><h4 id="2、切片扩容非常规操作（一次插入多个数字）"><a href="#2、切片扩容非常规操作（一次插入多个数字）" class="headerlink" title="2、切片扩容非常规操作（一次插入多个数字）"></a>2、切片扩容非常规操作（一次插入多个数字）</h4><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span>import <span class="hljs-string">&quot;fmt&quot;</span>func <span class="hljs-selector-tag">main</span>() &#123;    <span class="hljs-selector-tag">b</span> := <span class="hljs-selector-attr">[]</span>int&#123;<span class="hljs-number">23</span>, <span class="hljs-number">51</span>&#125;    <span class="hljs-selector-tag">b</span> = <span class="hljs-built_in">append</span>(<span class="hljs-selector-tag">b</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)    fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;cap of b is &quot;</span>,<span class="hljs-built_in">cap</span>(b))&#125;</code></pre><p>猜猜结果是多少？</p><pre><code class="hljs actionscript">cap of b <span class="hljs-keyword">is</span>  <span class="hljs-number">6</span></code></pre><p>想知道结果我们翻看golang 的源码，我的版本是1.18beta1，老版本的扩容代码和新版本有些许区别</p><p>代码位置：src&#x2F;runtime&#x2F;slice.go</p><pre><code class="hljs haxe"><span class="hljs-comment">//老版本</span><span class="hljs-keyword">new</span><span class="hljs-type">cap</span> :<span class="hljs-type"></span>= old.cap<span class="hljs-keyword">if</span> <span class="hljs-keyword">new</span><span class="hljs-type">cap</span>+<span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &lt; cap &#123;    <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = cap&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">for</span> &#123;        <span class="hljs-keyword">if</span> old.len &lt; <span class="hljs-number">1024</span> &#123;            <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> += <span class="hljs-keyword">new</span><span class="hljs-type">cap</span>        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> += <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> / <span class="hljs-number">4</span>        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &gt;= cap &#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;&#125;<span class="hljs-comment">// 1.18beta版</span><span class="hljs-keyword">new</span><span class="hljs-type">cap</span> :<span class="hljs-type"></span>= old.capdoublecap :<span class="hljs-type"></span>= <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> + <span class="hljs-keyword">new</span><span class="hljs-type">cap</span><span class="hljs-keyword">if</span> cap &gt; doublecap &#123;<span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = cap&#125; <span class="hljs-keyword">else</span> &#123;const threshold = <span class="hljs-number">256</span><span class="hljs-keyword">if</span> old.cap &lt; threshold &#123;<span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = doublecap&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span><span class="hljs-comment">// and prevent an infinite loop.</span><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &amp;&amp; <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &lt; cap &#123;<span class="hljs-comment">// Transition from growing 2x for small slices</span><span class="hljs-comment">// to growing 1.25x for large slices. This formula</span><span class="hljs-comment">// gives a smooth-ish transition between the two.</span><span class="hljs-keyword">new</span><span class="hljs-type">cap</span> += (<span class="hljs-keyword">new</span><span class="hljs-type">cap</span> + <span class="hljs-number">3</span>*threshold) / <span class="hljs-number">4</span>&#125;<span class="hljs-comment">// Set newcap to the requested cap when</span><span class="hljs-comment">// the newcap calculation overflowed.</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">new</span><span class="hljs-type">cap</span> &lt;= <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">new</span><span class="hljs-type">cap</span> = cap&#125;&#125;&#125;</code></pre><ul><li>第一行的 old.cap：扩容前的容量，对于此例，就是 2</li><li>第二行的 cap：扩容前容量加上扩容的元素数量，对于此例，就是 2+3</li></ul><p>新版本的和老版本的区别在于新版本把阈值设为256，并且改变了增长公式</p><p>newcap +&#x3D; (newcap + 3*threshold) &#x2F; 4，使之增长更加平滑</p><p><strong>看代码那最终容量不是5吗？</strong></p><p>其实不然，newcap是计算出扩容后的预估容量，并不是最终的容量，要计算最终的容量，还需要参考另一个维度，也就是内存分配。</p><p>关于内存管理模块的代码，在 <code>runtime/sizeclasses.go</code></p><pre><code class="hljs tap">// class  bytes/obj  bytes/span  objects  tail waste  max waste//    <span class="hljs-number"> 1 </span>        <span class="hljs-number"> 8 </span>      <span class="hljs-number"> 8192 </span>   <span class="hljs-number"> 1024 </span>         <span class="hljs-number"> 0 </span>    87.50%//    <span class="hljs-number"> 2 </span>       <span class="hljs-number"> 16 </span>      <span class="hljs-number"> 8192 </span>    <span class="hljs-number"> 512 </span>         <span class="hljs-number"> 0 </span>    43.75%//    <span class="hljs-number"> 3 </span>       <span class="hljs-number"> 32 </span>      <span class="hljs-number"> 8192 </span>    <span class="hljs-number"> 256 </span>         <span class="hljs-number"> 0 </span>    46.88%//    <span class="hljs-number"> 4 </span>       <span class="hljs-number"> 48 </span>      <span class="hljs-number"> 8192 </span>    <span class="hljs-number"> 170 </span>        <span class="hljs-number"> 32 </span>    31.52%...//   <span class="hljs-number"> 17 </span>      <span class="hljs-number"> 256 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 32 </span>         <span class="hljs-number"> 0 </span>     5.86%//   <span class="hljs-number"> 18 </span>      <span class="hljs-number"> 288 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 28 </span>       <span class="hljs-number"> 128 </span>    12.16%//   <span class="hljs-number"> 19 </span>      <span class="hljs-number"> 320 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 25 </span>       <span class="hljs-number"> 192 </span>    11.80%//   <span class="hljs-number"> 20 </span>      <span class="hljs-number"> 352 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 23 </span>        <span class="hljs-number"> 96 </span>     9.88%//   <span class="hljs-number"> 21 </span>      <span class="hljs-number"> 384 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 21 </span>       <span class="hljs-number"> 128 </span>     9.51%//   <span class="hljs-number"> 22 </span>      <span class="hljs-number"> 416 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 19 </span>       <span class="hljs-number"> 288 </span>    10.71%//   <span class="hljs-number"> 23 </span>      <span class="hljs-number"> 448 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 18 </span>       <span class="hljs-number"> 128 </span>     8.37%//   <span class="hljs-number"> 24 </span>      <span class="hljs-number"> 480 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 17 </span>        <span class="hljs-number"> 32 </span>     6.82%//   <span class="hljs-number"> 25 </span>      <span class="hljs-number"> 512 </span>      <span class="hljs-number"> 8192 </span>     <span class="hljs-number"> 16 </span>         <span class="hljs-number"> 0 </span>     6.05%...//   <span class="hljs-number"> 66 </span>    <span class="hljs-number"> 32768 </span>     <span class="hljs-number"> 32768 </span>      <span class="hljs-number"> 1 </span>         <span class="hljs-number"> 0 </span>    12.50%</code></pre><p>5个int是40字节，向上取整是48字节所以cap是6的原因。</p>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言chan缓存和阻塞</title>
    <link href="/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80chan%E7%BC%93%E5%AD%98%E5%92%8C%E9%98%BB%E5%A1%9E/"/>
    <url>/2022/01/21/%E5%90%8E%E5%8F%B0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/go/go%E8%AF%AD%E8%A8%80chan%E7%BC%93%E5%AD%98%E5%92%8C%E9%98%BB%E5%A1%9E/</url>
    
    <content type="html"><![CDATA[<p>问题：下面迭代会有什么问题</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>) <span class="hljs-comment">//下面的迭代会有什么问题？</span><span class="hljs-keyword">type</span> threadSafeSet <span class="hljs-keyword">struct</span> &#123;sync.RWMutexs []<span class="hljs-keyword">interface</span>&#123;&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(set *threadSafeSet)</span></span> Iter() &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// 解除注释看看！</span><span class="hljs-comment">//ch := make(chan interface&#123;&#125;,len(set.s))</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;set.RLock()<span class="hljs-keyword">for</span> elem,value := <span class="hljs-keyword">range</span> set.s &#123;ch &lt;- elemfmt.Println(<span class="hljs-string">&quot;Iter:&quot;</span>,elem,value)&#125;<span class="hljs-built_in">close</span>(ch)set.RUnlock()&#125;()<span class="hljs-keyword">return</span> ch&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;th:=threadSafeSet&#123;s:[]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>&#125;,&#125;vs := th.Iter()fmt.Println(&lt;- vs)&#125;</code></pre><p>结果</p><pre><code class="hljs apache"><span class="hljs-attribute">Iter</span>: <span class="hljs-number">0</span> <span class="hljs-number">1</span><span class="hljs-attribute">0</span></code></pre><p>解释一下这段代码，在iter（）里面有一个goroutin，用来执行输入数据到channel里面，这里创了一个0空间的channel缓存，只要输入一个数据就会阻塞，为什么这里还能输入一个，因为倒数第二行输出了一个channel，就可以再输入一个数据然后阻塞。</p><p>如果把vs这个变量取消掉，然后把prinln也去掉，就什么都不能输出了</p><p>为了方便你的理解，把代码里面注释的去掉，把原来那行注释</p><pre><code>ch := make(chan interface&#123;&#125;) //ch := make(chan interface&#123;&#125;,len(set.s))</code></pre><p>现在channel就有两个缓存了，只有能够把数据输入到channel里面不堵塞才能执行这句话</p><pre><code class="hljs reasonml">fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;Iter:&quot;</span>,<span class="hljs-params">elem</span>,<span class="hljs-params">value</span>)</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 27. 二叉树的镜像</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2027.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><font size=6px>二叉树的镜像</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><pre><code> 4</code></pre><p>   &#x2F;   <br>  2     7<br> &#x2F; \   &#x2F; <br>1   3 6   9<br>镜像输出：</p><pre><code> 4</code></pre><p>   &#x2F;   <br>  7     2<br> &#x2F; \   &#x2F; <br>9   6 3   1</p><p>示例 1：</p><p>输入：root &#x3D; [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>每次交互一个父节点的左右子结点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mirrorTree</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span>  root    &#125;    root.Left,root.Right = mirrorTree(root.Right),mirrorTree(root.Left)    <span class="hljs-keyword">return</span> root&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了18.27%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣第一题：两数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p><strong>观前啰嗦：</strong>这是我第一次做力扣题目，本题用c语言做的，接下来打算用go语言写，来锻炼我go语言能力，无论用哪种语言其实都一样，语言是一种工具，思想才是最重要的。</p><h2>1、两数之和</h2><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p> <strong>示例</strong></p><pre><code class="hljs inform7">给定 nums = <span class="hljs-comment">[2, 7, 11, 15]</span>, target = 9因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> = 2 + 7 = 9所以返回 <span class="hljs-comment">[0, 1]</span></code></pre><p>思想：这题思想不难理解，就是第一次错题有些细节要注意，target表示给的最终指，returnSize是个指针，表示最终的返回数个数。</p><p><strong>代码</strong></p><pre><code class="hljs c"><span class="hljs-comment">/*我用最传统的方法写的*/</span><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span>&#123;    *returnSize =<span class="hljs-number">2</span>;<span class="hljs-comment">//用来说明有几个返回大小</span>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a[<span class="hljs-number">2</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;numsSize;j++)        &#123;            <span class="hljs-keyword">if</span>((nums[i]+nums[j])==target)            &#123;                a[<span class="hljs-number">0</span>]=i;                a[<span class="hljs-number">1</span>]=j;                <span class="hljs-keyword">return</span> a;            &#125;         &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">  执行用时：12 ms, 在所有 C 提交中击败了30.82%的用户<br>  内存消耗：6 MB, 在所有 C 提交中击败了50.75%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
      <tag>array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十一;乘最多水的容器</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/11.%E4%B9%98%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/11.%E4%B9%98%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:乘最多水的容器</font></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><p>示例 1：</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"></p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br>示例 2：</p><p>输入：height &#x3D; [1,1]<br>输出：1<br>示例 3：</p><p>输入：height &#x3D; [4,3,2,1,4]<br>输出：16<br>示例 4：</p><p>输入：height &#x3D; [1,2,1]<br>输出：2</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>​            用到对撞指针的思路，指针开始指向开头和末尾，从开始和末尾分别判断， 如果  (height[end]&gt;height[first])，就first++。</p><h4 id="go代码"><a href="#go代码" class="headerlink" title="go代码"></a>go代码</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    max:=<span class="hljs-number">0</span>    end:=<span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span>    first:=<span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> first&lt;end&#123;        width := end-first        <span class="hljs-keyword">if</span>(height[end]&gt;height[first])&#123;            ans=width*height[first]            first++        &#125;<span class="hljs-keyword">else</span>&#123;            ans=width*height[end]            end--        &#125;        <span class="hljs-keyword">if</span>(max&lt;ans)&#123;            max=ans        &#125;    &#125;   <span class="hljs-keyword">return</span> max &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：20 ms, 在所有 Go 提交中击败了83.14%的用户<br>   内存消耗：6.3 MB, 在所有 Go 提交中击败了53.07%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十三：罗马数字转整数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目-罗马数字转整数"><a href="#题目-罗马数字转整数" class="headerlink" title="题目:罗马数字转整数"></a><font size=6px>题目:罗马数字转整数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>​    一个难点如果小的数字出现在大的数字前面的时候，这个数字变成减而不是加上这个数字的大小，用switch写比较清楚。其他比较简单易理解。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    sum:=<span class="hljs-number">0</span>    len_s:=<span class="hljs-built_in">len</span>(s)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;len_s;i++&#123;        <span class="hljs-keyword">switch</span> s[i]&#123;           <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>:                 sum++                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;V&#x27;</span>|| s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;X&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-2</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>:                sum+=<span class="hljs-number">5</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;V&#x27;</span>|| s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;X&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-2</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>:                sum+=<span class="hljs-number">10</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-20</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:                sum+=<span class="hljs-number">50</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;C&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-100</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:                sum+=<span class="hljs-number">100</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>||s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-200</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:                sum+=<span class="hljs-number">500</span>                <span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span>&lt;len_s&#123;                    <span class="hljs-keyword">if</span> s[i+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;M&#x27;</span>&#123;                        sum=sum<span class="hljs-number">-1000</span>                    &#125;                &#125;                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>:                sum+=<span class="hljs-number">1000</span>                <span class="hljs-keyword">break</span>         &#125;    &#125;    <span class="hljs-keyword">return</span> sum&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了47.27%的用户<br>   内存消耗：3.1 MB, 在所有 Go 提交中击败了99.24%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十五;三数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="题目-三数之和"><a href="#题目-三数之和" class="headerlink" title="题目:三数之和"></a><font size=6px>题目:三数之和</font></h4><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>难度中等</p><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c &#x3D;</em> 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><pre><code class="hljs inform7">给定数组 nums = <span class="hljs-comment">[-1, 0, 1, 2, -1, -4]</span>，满足要求的三元组集合为：<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[-1, 0, 1]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[-1, -1, 2]</span></span><span class="hljs-comment">]</span></code></pre><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>​    先排序，再用for从0到length-2中选一个k值，选定k值之后把k后面的数用对撞指针从k+1到length-1用对撞指针求一个值等于-num[k]，记得判断left右边和right左边的值是否和自己相同</p><p><strong>一直出现这个错误，检查之后发现最后少个大括号</strong></p><p><code>Line 40: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&lt;<span class="hljs-number">3</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    <span class="hljs-comment">//先排序</span>    sort.Ints(nums)    length:=<span class="hljs-built_in">len</span>(nums)    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    <span class="hljs-comment">//确认好一个数之后用对撞指针</span>     <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;length<span class="hljs-number">-2</span>;k++&#123;        <span class="hljs-keyword">if</span> nums[k]&gt;<span class="hljs-number">0</span> &#123;            <span class="hljs-keyword">break</span>        &#125;        <span class="hljs-keyword">if</span> k&gt;<span class="hljs-number">0</span>&amp;&amp;nums[k]==nums[k<span class="hljs-number">-1</span>]&#123;            <span class="hljs-keyword">continue</span>        &#125;        left:=k+<span class="hljs-number">1</span>        right:=length<span class="hljs-number">-1</span>        <span class="hljs-keyword">for</span> left&lt;right&#123;            sum := nums[left]+nums[right]+nums[k]            <span class="hljs-comment">//要判断left和它右边的值一不一样，right的值和它左边的一不一样</span>            <span class="hljs-keyword">if</span> sum&gt;<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">for</span> right=right<span class="hljs-number">-1</span>;right&gt;left &amp;&amp;nums[right]==nums[right+<span class="hljs-number">1</span>];right-- &#123;&#125;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum&lt;<span class="hljs-number">0</span> &#123;                <span class="hljs-keyword">for</span> left=left+<span class="hljs-number">1</span>;right&gt;left &amp;&amp;nums[left]==nums[left<span class="hljs-number">-1</span>];left++ &#123;&#125;            &#125;<span class="hljs-keyword">else</span>&#123;                res = <span class="hljs-built_in">append</span>(res,[]<span class="hljs-type">int</span>&#123;nums[k],nums[left],nums[right]&#125;)                <span class="hljs-keyword">for</span> right=right<span class="hljs-number">-1</span>;right&gt;left &amp;&amp;nums[right]==nums[right+<span class="hljs-number">1</span>];right-- &#123;&#125;                <span class="hljs-keyword">for</span> left=left+<span class="hljs-number">1</span>;right&gt;left &amp;&amp;nums[left]==nums[left<span class="hljs-number">-1</span>];left++ &#123;&#125;                     &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：40 ms, 在所有 Go 提交中击败了52.12%的用户<br>   内存消耗：7.3 MB, 在所有 Go 提交中击败了42.04%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣十六 最接近的三数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">庆祝自己第一次达到百分之95以上<p>执行用时：4 ms, 在所有 Go 提交中击败了95.59%的用户</p><p>内存消耗：2.7 MB, 在所有 Go 提交中击败了98.89%的用户</p></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</p><p><strong>提示：</strong></p><ul><li><p>3 &lt;&#x3D; nums.length &lt;&#x3D; 10^3</p></li><li><p>-10^3 &lt;&#x3D; nums[i] &lt;&#x3D; 10^3</p></li><li><p>*-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</p></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>和第十五题类似，先排序，后用对撞指针对后面的数字进行扫描，只需注意一点<strong>return的是sum的值，min却是target-sum</strong></p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-comment">//先排序</span>    min:=<span class="hljs-number">999999</span>    <span class="hljs-keyword">var</span> value <span class="hljs-type">int</span>    sort.Ints(nums)    length:=<span class="hljs-built_in">len</span>(nums)    <span class="hljs-comment">//确认好一个数之后用对撞指针</span>     <span class="hljs-keyword">for</span> k:=<span class="hljs-number">0</span>;k&lt;length<span class="hljs-number">-2</span>;k++&#123;        left:=k+<span class="hljs-number">1</span>        right:=length<span class="hljs-number">-1</span>        <span class="hljs-keyword">for</span> left&lt;right&#123;            sum := nums[left]+nums[right]+nums[k]            <span class="hljs-keyword">if</span>(sum==target)&#123;                <span class="hljs-keyword">return</span> sum            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target)&#123;                <span class="hljs-keyword">if</span>(target-sum&lt;min)&#123;                    min=target-sum                    value=sum  <span class="hljs-comment">//这里要注意，return的是sum的值，min却是target-sum</span>                &#125;                left++            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(sum-target&lt;min)&#123;                    min=sum-target                    value=sum                &#125;                right--            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> value&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><font size=6px>电话号码的字母组合</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png"></p><p>示例 1：</p><p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]<br>示例 2：</p><p>输入：digits &#x3D; “”<br>输出：[]<br>示例 3：</p><p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]</p><p>提示：</p><p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="map的初体验和使用"><a href="#map的初体验和使用" class="headerlink" title="map的初体验和使用"></a>map的初体验和使用</h5><p>还不知道golang里面的map是什么怎么用，上网搜了一下map是哈希表差不读的，有键值对，直接mp：&#x3D;map[string]string出来的是一个空的没开辟地址的map，要mp：&#x3D;make（map[string]string）才是开辟好地址的，在下面代码使用的结束时候别忘记加逗号</p><p>一道典型的dfs搜索算法，先把一个个字母放进path里面，等i&gt;&#x3D;len(digits)后就append到结果里面<br>还学会了自定义函数里面再自定义函数的用法。dfs看着很简洁，递归代码还是不好理解</p><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(digits <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(digits)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;    &#125;    mp:=<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;    <span class="hljs-string">&quot;2&quot;</span>:<span class="hljs-string">&quot;abc&quot;</span>,    <span class="hljs-string">&quot;3&quot;</span>:<span class="hljs-string">&quot;def&quot;</span>,    <span class="hljs-string">&quot;4&quot;</span>:<span class="hljs-string">&quot;ghi&quot;</span>,    <span class="hljs-string">&quot;5&quot;</span>:<span class="hljs-string">&quot;jkl&quot;</span>,    <span class="hljs-string">&quot;6&quot;</span>:<span class="hljs-string">&quot;mno&quot;</span>,    <span class="hljs-string">&quot;7&quot;</span>:<span class="hljs-string">&quot;pqrs&quot;</span>,    <span class="hljs-string">&quot;8&quot;</span>:<span class="hljs-string">&quot;tuv&quot;</span>,    <span class="hljs-string">&quot;9&quot;</span>:<span class="hljs-string">&quot;wxyz&quot;</span>,    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">string</span>)</span></span>    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">string</span>    dfs=<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>,path <span class="hljs-type">string</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> i&gt;=<span class="hljs-built_in">len</span>(digits)&#123;            ans=<span class="hljs-built_in">append</span>(ans,path)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> mp[<span class="hljs-type">string</span>(digits[i])]&#123;            <span class="hljs-comment">//第一次写的时候把path+string(v)写在了dfs上一行，结果会不对，回溯的时候回溯会不对</span>            dfs(i+<span class="hljs-number">1</span>,path+<span class="hljs-type">string</span>(v))        &#125;    &#125;    <span class="hljs-comment">//这里是dfs进入的入口</span>    dfs(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>)    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了93.14%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣二十：有效的括号</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="力扣二十：有效的括号"><a href="#力扣二十：有效的括号" class="headerlink" title="力扣二十：有效的括号"></a><font size=6px>力扣二十：有效的括号</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p>示例 1：</p><p>输入：s &#x3D; “()”<br>输出：true<br>示例 2：</p><p>输入：s &#x3D; “()[]{}”<br>输出：true<br>示例 3：</p><p>输入：s &#x3D; “(]”<br>输出：false<br>示例 4：</p><p>输入：s &#x3D; “([)]”<br>输出：false<br>示例 5：</p><p>输入：s &#x3D; “{[]}”<br>输出：true</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s 仅由括号 ‘()[]{}’ 组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="知道的golang语言知识"><a href="#知道的golang语言知识" class="headerlink" title="知道的golang语言知识"></a>知道的golang语言知识</h5><p>1、知道了golang里面没有数组里面++，–的情况，得写出来，比如是s[i++]不可以，i++可以</p><p>2、’a’在golang里面代表的是int类型，就是字母转ascii码之后的数字，string类型的s，s[0]就是int类型的数字，是rune类型。</p><p>讲一下思路把，简单的数组栈，碰到左边的括号就++，碰到右边的括号就判断–后的数组里面的字母是不是他的左括号，代码里面有三种特殊情况要考虑一些</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> str [<span class="hljs-number">5000</span>]<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> k <span class="hljs-type">int</span>    s_len:=<span class="hljs-built_in">len</span>(s)    <span class="hljs-comment">//情况1：如果括号个数不等于2的倍数或者为0 就说明是false</span>    <span class="hljs-keyword">if</span> s_len%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>||s_len==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;s_len;i++&#123;        <span class="hljs-keyword">if</span> s[i]==<span class="hljs-string">&#x27;(&#x27;</span>||s[i]==<span class="hljs-string">&#x27;[&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>&#123;            str[k]=<span class="hljs-type">string</span>(s[i])            k++        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//情况2：如果第一个就是‘）’，‘]’，‘&#125;’就说明的false</span>            <span class="hljs-keyword">if</span> k==<span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;            <span class="hljs-keyword">switch</span> s[i]&#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:                    k--                    <span class="hljs-keyword">if</span> str[k]!=<span class="hljs-string">&quot;(&quot;</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    &#125;                    <span class="hljs-keyword">break</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span>:                    k--                    <span class="hljs-keyword">if</span> str[k]!=<span class="hljs-string">&quot;[&quot;</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    &#125;                    <span class="hljs-keyword">break</span>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span>:                    k--                    <span class="hljs-keyword">if</span> str[k]!=<span class="hljs-string">&quot;&#123;&quot;</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    &#125;                    <span class="hljs-keyword">break</span>            &#125;        &#125;    &#125;    <span class="hljs-comment">//情况3：如果没有做到一一对应k会大于0 就false</span>    <span class="hljs-keyword">if</span> k&gt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了23.58%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣三：无重复字字符的最长字串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:无重复字字符的最长字串</font></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>示例 4:</p><p>输入: s &#x3D; “”<br>输出: 0</p><p>提示：</p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>s 由英文字母、数字、符号和空格组成</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>用滑动窗口法，设置一个数组，初始为0，再初设一个left和right，如果一个字母没有用过就把它</p><p>**&#96;&#96;&#96;**<em>freq[s[right+1]-‘a’]++</em></p><p>，并且往右边划，如果在往右边划的时候遇到一个用到过的字母，就left++，把left上面的字母的频率减1，</p><p>`&#96;&#96;freq[s[left]-‘a’]–</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="hljs golang"><span class="hljs-comment">//用滑动窗口法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;  left,right,max:=<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>  <span class="hljs-keyword">var</span> freq[<span class="hljs-number">256</span>] <span class="hljs-type">int</span>  <span class="hljs-keyword">for</span> left&lt;<span class="hljs-built_in">len</span>(s)&#123;​    <span class="hljs-comment">//go语言很严格，单个字符不能用“a”</span>​    <span class="hljs-keyword">if</span> right+<span class="hljs-number">1</span>&lt;<span class="hljs-built_in">len</span>(s)&amp;&amp;freq[s[right+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-number">0</span>&#123;​      freq[s[right+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]++​      right++​    &#125;<span class="hljs-keyword">else</span>&#123;​      freq[s[left]-<span class="hljs-string">&#x27;a&#x27;</span>]--​      left++​    &#125;​    <span class="hljs-keyword">if</span> max&lt;right-left+<span class="hljs-number">1</span>&#123;​      max=right-left+<span class="hljs-number">1</span>​    &#125;  &#125;  <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.5 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣四十二：接雨水</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:接雨水</font></p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="示例1图片"></p><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：height &#x3D; [4,2,0,3,2,5]<br>输出：9</p><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><li>n == height.length</li><li>0 <= n <= 3 * 104</li><li>0 <= height[i] <= 105</li><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p class="note note-primary">    单词注释：     height[left] left位置上的格子的数量    maxl 左边格子最大的格子</p><p>  这题比较难，用双指针方法代码比较简洁，用示例1举例子，先找height[left]与height[right]中小的数字，然后执行小数字方代码，如果height[left]比maxl还要大,就把maxl&#x3D;height[left]，如果不是，那就说明这一格肯定可以装水（可以看代码的第一个注释的解释），把所有可以装水的格子的装水量加起来就是答案。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    left,right,maxl,maxr,res := <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> left&lt;=right&#123;         <span class="hljs-keyword">if</span> height[left]&lt;height[right]&#123;             <span class="hljs-keyword">if</span> maxl&lt;=height[left]&#123;                maxl=height[left]             &#125;<span class="hljs-keyword">else</span>&#123;                 <span class="hljs-comment">//左边肯定有比height[left]高的墙，右边有maxr＞maxl，右边肯定有比height[left]高的墙，水在这一格的高度就是maxl-height[left]，下面同理</span>                res = res+maxl-height[left]             &#125;             left++         &#125;<span class="hljs-keyword">else</span>&#123;             <span class="hljs-keyword">if</span> maxr&lt;height[right]&#123;                 maxr=height[right]             &#125;<span class="hljs-keyword">else</span>&#123;                 <span class="hljs-comment">//右边肯定有比height[right]高的墙</span>                res = res+maxr-height[right];             &#125;             right--         &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了74.89%的用户<br>   内存消耗：2.8 MB, 在所有 Go 提交中击败了81.87%的用户</p><pre><code class="hljs go"><span class="hljs-comment">// 单调栈解法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> stack []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i,h := <span class="hljs-keyword">range</span> height&#123;        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span> &amp;&amp; height[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] &lt; h&#123;            top := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span>&#123;                <span class="hljs-keyword">continue</span>             &#125;            left := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            width := i-left<span class="hljs-number">-1</span>            height := min(h, height[left]) - height[top]            res += width*height        &#125;        stack = <span class="hljs-built_in">append</span>(stack, i)    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>; <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size:22px&quot;</span>&gt;</span>   执行用时：8 ms, 在所有 Go 提交中击败了67.12%的用户<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>   内存消耗：4.9 MB, 在所有 Go 提交中击败了31.09%的用户<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣-四十一：缺失一个正数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/41.%E7%BC%BA%E5%A4%B1%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/41.%E7%BC%BA%E5%A4%B1%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p> <font size=6px>题目:缺失一个正数</font></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>​    给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><p>输入: [1,2,0]<br>输出: 3</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><p>输入: [3,4,-1,1]<br>输出: 2</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h4><p>输入: [7,8,9,11,12]<br>输出: 1</p><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><p>你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>用map做，先把数放进map里面<code>map_num[v]=v</code>，再用哈希的思想，判断这个下标和值相不相同。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    map_num:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))    <span class="hljs-keyword">for</span> _,v :=<span class="hljs-keyword">range</span> nums&#123;        map_num[v]=v    &#125;    <span class="hljs-comment">//用map来判断这个值在不在确实很方便</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> _,ok:=map_num[i];!ok&#123;            <span class="hljs-keyword">return</span> i        &#125;    &#125;    <span class="hljs-comment">//如果数字全部有序，就输出个数加一</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了9.44%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣四十八：旋转图像</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/48.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/48.%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<p><font size=6px>题目:旋转图像</font></p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong></p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><p><strong>示例 1:</strong></p><pre><code class="hljs inform7">给定 matrix = <span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[4,5,6]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[7,8,9]</span></span><span class="hljs-comment">]</span>,原地旋转输入矩阵，使其变为:<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[7,4,1]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[8,5,2]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[9,6,3]</span></span><span class="hljs-comment">]</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs inform7">给定 matrix =<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[ 5, 1, 9,11]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[ 2, 4, 8,10]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[13, 3, 6, 7]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[15,14,12,16]</span></span><span class="hljs-comment">]</span>, 原地旋转输入矩阵，使其变为:<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[15,13, 2, 5]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[14, 3, 4, 1]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[12, 6, 8, 9]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[16, 7,10,11]</span></span><span class="hljs-comment">]</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这题想清楚了不难，找找规律，就是<strong>矩阵转置</strong>再<strong>镜像翻转</strong>一下就得到结果</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span>  &#123;    swap:=<span class="hljs-number">0</span>    a:=<span class="hljs-built_in">len</span>(matrix)     b:=<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])    <span class="hljs-comment">//下面是矩阵转置部分</span>    <span class="hljs-keyword">for</span> k:=a<span class="hljs-number">-1</span>;k&gt;<span class="hljs-number">0</span>;k--&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;            swap=matrix[a-k<span class="hljs-number">-1</span>][a-i<span class="hljs-number">-1</span>]            matrix[a-k<span class="hljs-number">-1</span>][a-i<span class="hljs-number">-1</span>]=matrix[a-i<span class="hljs-number">-1</span>][a-k<span class="hljs-number">-1</span>]            matrix[a-i<span class="hljs-number">-1</span>][a-k<span class="hljs-number">-1</span>]=swap        &#125;    &#125;    <span class="hljs-comment">//下面是矩阵镜像翻转部分</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;a;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=b/<span class="hljs-number">2</span>;j++&#123;            swap = matrix[i][j<span class="hljs-number">-1</span>]            matrix[i][j<span class="hljs-number">-1</span>] = matrix[i][b-j]            matrix[i][b-j] =swap        &#125;    &#125;&#125;</code></pre><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣九十三：复原IP地址</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/93.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/93.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a><font size=6px>复原IP地址</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#x39;&#50;&#46;&#x31;&#54;&#x38;&#64;&#49;&#x2e;&#49;">&#49;&#x39;&#50;&#46;&#x31;&#54;&#x38;&#64;&#49;&#x2e;&#49;</a>“ 是 无效的 IP 地址。</p><p>示例 1：</p><p>输入：s &#x3D; “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]<br>示例 2：</p><p>输入：s &#x3D; “0000”<br>输出：[“0.0.0.0”]<br>示例 3：</p><p>输入：s &#x3D; “1111”<br>输出：[“1.1.1.1”]<br>示例 4：</p><p>输入：s &#x3D; “010010”<br>输出：[“0.10.0.10”,”0.100.1.0”]<br>示例 5：</p><p>输入：s &#x3D; “101023”<br>输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</p><p>提示：</p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 3000<br>s 仅由数字组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h5 id="学到的东西"><a href="#学到的东西" class="headerlink" title="学到的东西"></a>学到的东西</h5><p>1、搞清楚了切片和数组的区别，切片要导入的话得用append，没有大小限制</p><p>2、s[i]-‘0’出来的结果是byte类型的</p><p>3、要重置一个字符串型的变量，var一个新的string变量，然后要它等于新的string变量</p><p>4、要返回一个空的字符串切片，return []string{}</p><p>5、要用len求数字的长度，要用strconv.Itoa把数字转化成字符串才能求</p><p>思路：</p><p>第一步先求长度符不符合标准，第二步求有无非法字符，第三步开始正式处理，这道题好像是一串数字，在里面加上3个点，然后判断被三个点隔开的4个数字符不符合标准，把4个数字取出来，然后分别判断是否小于255，然后判断这4个数字的长度和s的长度一不一样，如果不一样说明数字前面有0，就不符合条件</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-keyword">var</span> s_len <span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> s1 ,s3 <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> s2 []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> n1,n2,n3,n4,sum_len <span class="hljs-type">int</span>    s_len=<span class="hljs-built_in">len</span>(s)    <span class="hljs-comment">//如果长度不达标</span>    <span class="hljs-keyword">if</span> s_len&lt;<span class="hljs-number">4</span> || s_len&gt;<span class="hljs-number">12</span>&#123;        <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;    &#125;    <span class="hljs-comment">//如果出现非法字符</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;s_len;i++&#123;        <span class="hljs-keyword">if</span> s[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span> || s[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>&#123;            <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;s_len<span class="hljs-number">-3</span>&amp;&amp;i&lt;=<span class="hljs-number">2</span>;i++&#123;        <span class="hljs-keyword">for</span> j:=i+<span class="hljs-number">1</span>;j&lt;s_len<span class="hljs-number">-2</span>&amp;&amp;j-i&lt;=<span class="hljs-number">3</span>;j++&#123;            <span class="hljs-keyword">for</span> k:=j+<span class="hljs-number">1</span>;k&lt;s_len<span class="hljs-number">-1</span>&amp;&amp;k-j&lt;=<span class="hljs-number">3</span>;k++&#123;                n1,n2,n3,n4,sum_len=stio(s,i,j,k)                <span class="hljs-keyword">if</span> n1&lt;=<span class="hljs-number">255</span>&amp;&amp;n2&lt;=<span class="hljs-number">255</span>&amp;&amp;n3&lt;=<span class="hljs-number">255</span>&amp;&amp;n4&lt;=<span class="hljs-number">255</span>&amp;&amp;sum_len==s_len&#123;                    <span class="hljs-keyword">for</span> m:=<span class="hljs-number">0</span>;m&lt;s_len;m++&#123;                        s1=s1+<span class="hljs-type">string</span>(s[m])                        <span class="hljs-keyword">if</span> m==i||m==j||m==k&#123;                            s1=s1+<span class="hljs-string">&quot;.&quot;</span>                        &#125;                    &#125;                    s2=<span class="hljs-built_in">append</span>(s2,s1)                    <span class="hljs-comment">//重置s1</span>                    s1=s3                &#125;                n1,n2,n3=<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> s2&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stio</span><span class="hljs-params">(s <span class="hljs-type">string</span>,a <span class="hljs-type">int</span>,b <span class="hljs-type">int</span> ,c <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">var</span> n1,n2,n3,n4 <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> sum_len <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=a;i++&#123;        n1=n1*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=a+<span class="hljs-number">1</span>;i&lt;=b;i++&#123;        n2=n2*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=b+<span class="hljs-number">1</span>;i&lt;=c;i++&#123;        n3=n3*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;    <span class="hljs-keyword">for</span> i:=c+<span class="hljs-number">1</span>;i&lt;s_len;i++&#123;        n4=n4*<span class="hljs-number">10</span>+<span class="hljs-type">int</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)    &#125;        sum_len=<span class="hljs-built_in">len</span>(strconv.Itoa(n1))+<span class="hljs-built_in">len</span>(strconv.Itoa(n2))+<span class="hljs-built_in">len</span>(strconv.Itoa(n3))+<span class="hljs-built_in">len</span>(strconv.Itoa(n4))    <span class="hljs-keyword">return</span> n1,n2,n3,n4,sum_len&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了56.25%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 116. 省份数量</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20116.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20116.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a><font size=6px>省份数量</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p>示例 1：</p><p>输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]<br>输出：2<br>示例 2：</p><p>输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]<br>输出：3</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 200<br>n &#x3D;&#x3D; isConnected.length<br>n &#x3D;&#x3D; isConnected[i].length<br>isConnected[i][j] 为 1 或 0<br>isConnected[i][i] &#x3D;&#x3D; 1<br>isConnected[i][j] &#x3D;&#x3D; isConnected[j][i]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用并查集思路，两个城市连起来就把city【i】 &#x3D;j，判断city【i】是否等于i就知道有几个省了，并查集合并有点困难</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(isConnected [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> city [<span class="hljs-number">201</span>]<span class="hljs-type">int</span><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">201</span>; i++ &#123;city[i] = i&#125;<span class="hljs-keyword">var</span> find <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>find = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> city[x] != x &#123;city[x] = find(city[x])&#125;<span class="hljs-keyword">return</span> city[x]&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(isConnected); i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span> &#123;city[find(i)] = find(j)&#125;&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(isConnected); i++ &#123;<span class="hljs-keyword">if</span> city[i] == i &#123;res++&#125;&#125;<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了91.90%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了95.76%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>547. 省份数量</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/547.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/547.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a><font size=6px>省份数量</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><p>示例 1：</p><p>输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]<br>输出：2<br>示例 2：</p><p>输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]<br>输出：3</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 200<br>n &#x3D;&#x3D; isConnected.length<br>n &#x3D;&#x3D; isConnected[i].length<br>isConnected[i][j] 为 1 或 0<br>isConnected[i][i] &#x3D;&#x3D; 1<br>isConnected[i][j] &#x3D;&#x3D; isConnected[j][i]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用并查集思路，两个城市连起来就把city【i】 &#x3D;j，判断city【i】是否等于i就知道有几个省了，并查集合并有点困难</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(isConnected [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> city [<span class="hljs-number">201</span>]<span class="hljs-type">int</span><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">201</span>; i++ &#123;city[i] = i&#125;<span class="hljs-keyword">var</span> find <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>find = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> city[x] != x &#123;city[x] = find(city[x])&#125;<span class="hljs-keyword">return</span> city[x]&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(isConnected); i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span> &#123;city[find(i)] = find(j)&#125;&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(isConnected); i++ &#123;<span class="hljs-keyword">if</span> city[i] == i &#123;res++&#125;&#125;<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：24 ms, 在所有 Go 提交中击败了91.90%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了95.76%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>56. 合并区间</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><font size=6px>合并区间</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p><p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p><p>提示：</p><p>1 &lt;&#x3D; intervals.length &lt;&#x3D; 104<br>intervals[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; starti &lt;&#x3D; endi &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>思路很简单，按第一个数字升序排序，然后判断pre的第二个数字是否大于等于cur的第一个数字，如果大就合并</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">//第二版代码</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> a &gt; b &#123;<span class="hljs-keyword">return</span> a&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> b&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]&#125;)pre :=intervals[<span class="hljs-number">0</span>]<span class="hljs-keyword">var</span> arr [][]<span class="hljs-type">int</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> ;i&lt;<span class="hljs-built_in">len</span>(intervals);i++&#123;    cur :=intervals[i]    <span class="hljs-keyword">if</span> pre[<span class="hljs-number">1</span>] &gt;= cur[<span class="hljs-number">0</span>]&#123;        pre [<span class="hljs-number">1</span>] = max(pre[<span class="hljs-number">1</span>],cur[<span class="hljs-number">1</span>])        &#125;<span class="hljs-keyword">else</span>&#123;            arr = <span class="hljs-built_in">append</span>(arr,pre)            pre = cur        &#125;    &#125;    arr = <span class="hljs-built_in">append</span>(arr,pre)    <span class="hljs-keyword">return</span>  arr&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了99.84%的用户<br>   内存消耗：4.5 MB, 在所有 Go 提交中击败了90.14%的用户</p><pre><code class="hljs angelscript"><span class="hljs-comment">//第一版代码，时间很慢，因为是合并数组中把原数组这个数去除的做法太费时间</span>func max (a,b <span class="hljs-built_in">int</span>)<span class="hljs-built_in">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;func merge(<span class="hljs-built_in">int</span>ervals [][]<span class="hljs-built_in">int</span>) [][]<span class="hljs-built_in">int</span> &#123;    <span class="hljs-comment">//sortclass := new(Sort)</span><span class="hljs-comment">//sortclass.arr = intervals</span>    <span class="hljs-comment">//</span><span class="hljs-comment">//sort.Sort(sortclass)</span>    sort.Slice(<span class="hljs-built_in">int</span>ervals, func(i, j <span class="hljs-built_in">int</span>) <span class="hljs-built_in">bool</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>] &lt;<span class="hljs-built_in">int</span>ervals[j][<span class="hljs-number">0</span>]    &#125;)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; len(<span class="hljs-built_in">int</span>ervals)<span class="hljs-number">-1</span>; i++ &#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>] &gt;= <span class="hljs-built_in">int</span>ervals[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &#123;            <span class="hljs-built_in">int</span>ervals = mergearray(<span class="hljs-built_in">int</span>ervals, i)            i--        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals&#125;func mergearray(<span class="hljs-built_in">int</span>ervals [][]<span class="hljs-built_in">int</span>, start <span class="hljs-built_in">int</span>) [][]<span class="hljs-built_in">int</span> &#123;    first := <span class="hljs-built_in">int</span>ervals[start][<span class="hljs-number">0</span>]    last := max(<span class="hljs-built_in">int</span>ervals[start][<span class="hljs-number">1</span>],<span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])    <span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = first    <span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = last    <span class="hljs-built_in">int</span>ervals = append(<span class="hljs-built_in">int</span>ervals[:start], <span class="hljs-built_in">int</span>ervals[start+<span class="hljs-number">1</span>:]...)    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals&#125;</code></pre><p class="note note-primary"; style="font-size:22px">   执行用时：28 ms, 在所有 Go 提交中击败了10.27%的用户<br>   内存消耗：4.4 MB, 在所有 Go 提交中击败了99.10%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>567. 字符串的排列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/567.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><font size=6px>字符串的排列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的 子串 。</p><p>示例 1：</p><p>输入: s1 &#x3D; “ab” s2 &#x3D; “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).<br>示例 2：</p><p>输入: s1&#x3D; “ab” s2 &#x3D; “eidboaoo”<br>输出: False</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>判断相不相等就是判断26个字母的个数相不相等，用滑动窗口法，第一次传入len（s1）开始判断，移动一次第一个字母的数量减去，加上最后一个字母的数量</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(s1 <span class="hljs-type">string</span>, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s1) &gt; <span class="hljs-built_in">len</span>(s2) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;     mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,<span class="hljs-number">26</span>)    mp2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,<span class="hljs-number">26</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s1);i++&#123;        mp[s1[i]]++        mp2[s2[i]]++    &#125;    <span class="hljs-keyword">if</span> check(mp,mp2)==<span class="hljs-literal">true</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(s1);i&lt;<span class="hljs-built_in">len</span>(s2);i++&#123;        mp2[s2[i-<span class="hljs-built_in">len</span>(s1)]]--        mp2[s2[i]]++        <span class="hljs-keyword">if</span> check(mp,mp2)==<span class="hljs-literal">true</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(mp1 <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>,mp2 <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> i <span class="hljs-type">byte</span>    <span class="hljs-keyword">for</span> i=<span class="hljs-string">&#x27;a&#x27;</span>;i&lt;<span class="hljs-string">&#x27;z&#x27;</span>;i++&#123;        <span class="hljs-keyword">if</span> mp1[i]!=mp2[i]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了43.98%的用户<br>   内存消耗：2.6 MB, 在所有 Go 提交中击败了23.90%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>sting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>60. 排列序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/60.%20%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/60.%20%E6%8E%92%E5%88%97%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="排列序列"><a href="#排列序列" class="headerlink" title="排列序列"></a><font size=6px>排列序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当 n &#x3D; 3 时, 所有排列如下：</p><p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p><p>示例 1：</p><p>输入：n &#x3D; 3, k &#x3D; 3<br>输出：”213”<br>示例 2：</p><p>输入：n &#x3D; 4, k &#x3D; 9<br>输出：”2314”<br>示例 3：</p><p>输入：n &#x3D; 3, k &#x3D; 1<br>输出：”123”</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 9<br>1 &lt;&#x3D; k &lt;&#x3D; n!</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>难得双百分比，思路是参考题解大神的，是一道类似于数学题，就例子中 3 3举例，第一个数字是怎么判断的呢，是 3 除以 2（1*2）等于1，知道第一个数为2，就是k &#x2F;（n-1）的阶乘就知道第一个数是哪个数，以此类推求出之后的数，记得求出一个数就把这个数从数组中取出</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getPermutation</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;num ,total := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>,<span class="hljs-number">0</span>,n),<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        num = <span class="hljs-built_in">append</span>(num,<span class="hljs-type">byte</span>(i)+<span class="hljs-string">&#x27;0&#x27;</span>)        total *= i    &#125;    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>,<span class="hljs-number">0</span>,n)    <span class="hljs-keyword">for</span> i:=n;i&gt;<span class="hljs-number">0</span>;i--&#123;        t :=total / i           idx := k / t <span class="hljs-number">-1</span>          <span class="hljs-keyword">if</span> k % t !=<span class="hljs-number">0</span>&#123;            idx+=<span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">if</span> idx&lt;<span class="hljs-number">0</span>&#123;            idx = <span class="hljs-number">0</span>        &#125;        res = <span class="hljs-built_in">append</span>(res,num[idx])        total , k = t , k-t*idx        num = <span class="hljs-built_in">append</span>(num[:idx],num[idx+<span class="hljs-number">1</span>:]...)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(res)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>64. 最小路径和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><font size=6px>最小路径和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例 1：</p><p>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p><p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>可以用dfs和动态规划做，我是动态规划</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> a    &#125;       &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> grid == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    m,n := <span class="hljs-built_in">len</span>(grid),<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m;i++ &#123;        grid[i][<span class="hljs-number">0</span>] += grid[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++ &#123;        grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]    &#125;    <span class="hljs-keyword">for</span>  i:=<span class="hljs-number">1</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;n;j++ &#123;            grid[i][j] = min(grid[i][j<span class="hljs-number">-1</span>],grid[i<span class="hljs-number">-1</span>][j]) + grid[i][j]            &#125;    &#125;    <span class="hljs-keyword">return</span> grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了97.88%的用户<br>   内存消耗：3.7 MB, 在所有 Go 提交中击败了92.14%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>674. 最长连续递增序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/674.%20%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a><font size=6px>最长连续递增序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;&#x3D; i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,5,4,7]<br>输出：3<br>解释：最长连续递增序列是 [1,3,5], 长度为3。<br>尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。<br>示例 2：</p><p>输入：nums &#x3D; [2,2,2,2,2]<br>输出：1<br>解释：最长连续递增序列是 [2], 长度为1。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>无</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    count :=<span class="hljs-number">1</span>    max :=<span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> nums[i<span class="hljs-number">-1</span>]&lt;nums[i]&#123;            count ++        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> count&gt;max&#123;                max = count            &#125;            count =<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> count&gt;max&#123;            max = count        &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了81.10%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>69. x 的平方根</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><p>输入: 4<br>输出: 2<br>示例 2:</p><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一般会说不能用sqrt，就用二分法查找最合适的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;     l:=<span class="hljs-number">0</span>     r:=x     <span class="hljs-keyword">for</span> l&lt;=r&#123;        mid := (l+r)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> mid*mid&gt;x&#123;            r=mid<span class="hljs-number">-1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            l=mid+<span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> r&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.1 MB, 在所有 Go 提交中击败了99.92%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70. 爬楼梯</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><font size=6px>爬楼梯</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶<br>示例 2：</li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>斐波那契数列</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> f []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>    &#125;    f = <span class="hljs-built_in">append</span>(f,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>; i&lt;=n;i++&#123;        f = <span class="hljs-built_in">append</span>(f,f[i<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-2</span>])    &#125;    <span class="hljs-keyword">return</span> f[n<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了43.50%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>695. 岛屿的最大面积</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/695.%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a><font size=6px>岛屿的最大面积</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><p>示例 1:</p><p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p><p>示例 2:</p><p>[[0,0,0,0,0,0,0,0]]<br>对于上面这个给定的矩阵, 返回 0。</p><p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>经典dfs题目，加一个flag【i】【j】，如果访问了就把它置1，这样就不会有回去原来的位置</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>number := <span class="hljs-number">1</span><span class="hljs-keyword">var</span> flag [<span class="hljs-number">51</span>][<span class="hljs-number">51</span>]<span class="hljs-type">int</span>move := [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(grid); i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]); j++ &#123;<span class="hljs-keyword">if</span> grid[i][j] != <span class="hljs-number">0</span> &amp;&amp; flag[i][j] == <span class="hljs-number">0</span> &#123;queue := []<span class="hljs-type">int</span>&#123;i, j&#125;flag[i][j] = <span class="hljs-number">1</span><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;tmppoint1 := queue[<span class="hljs-number">0</span>]tmppoint2 := queue[<span class="hljs-number">1</span>]<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> move &#123;<span class="hljs-keyword">if</span> tmppoint1+v[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; tmppoint1+v[<span class="hljs-number">0</span>] &lt; <span class="hljs-built_in">len</span>(grid) &amp;&amp; tmppoint2+v[<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; tmppoint2+v[<span class="hljs-number">1</span>] &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) &amp;&amp; grid[tmppoint1+v[<span class="hljs-number">0</span>]][tmppoint2+v[<span class="hljs-number">1</span>]] == <span class="hljs-number">1</span> &amp;&amp; flag[tmppoint1+v[<span class="hljs-number">0</span>]][tmppoint2+v[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span> &#123;queue = <span class="hljs-built_in">append</span>(queue, tmppoint1+v[<span class="hljs-number">0</span>], tmppoint2+v[<span class="hljs-number">1</span>])flag[tmppoint1+v[<span class="hljs-number">0</span>]][tmppoint2+v[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>number++&#125;&#125;queue = <span class="hljs-built_in">append</span>(queue[<span class="hljs-number">2</span>:])&#125;<span class="hljs-keyword">if</span> number &gt; max &#123;max = number&#125;number = <span class="hljs-number">1</span>&#125;&#125;&#125;<span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>71. 简化路径</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/71.%20%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/71.%20%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a><font size=6px>简化路径</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘&#x2F;‘ 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’&#x2F;&#x2F;‘）都被视为单个斜杠 ‘&#x2F;‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件&#x2F;目录名称。</p><p>请注意，返回的 规范路径 必须遵循下述格式：</p><p>始终以斜杠 ‘&#x2F;‘ 开头。<br>两个目录名之间必须只有一个斜杠 ‘&#x2F;‘ 。<br>最后一个目录名（如果存在）不能 以 ‘&#x2F;‘ 结尾。<br>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。<br>返回简化后得到的 规范路径 。</p><p>示例 1：</p><p>输入：path &#x3D; “&#x2F;home&#x2F;“<br>输出：”&#x2F;home”<br>解释：注意，最后一个目录名后面没有斜杠。<br>示例 2：</p><p>输入：path &#x3D; “&#x2F;..&#x2F;“<br>输出：”&#x2F;“<br>解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。<br>示例 3：</p><p>输入：path &#x3D; “&#x2F;home&#x2F;&#x2F;foo&#x2F;“<br>输出：”&#x2F;home&#x2F;foo”<br>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br>示例 4：</p><p>输入：path &#x3D; “&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;“<br>输出：”&#x2F;c”</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>代码参考题解，写的特别巧妙和简洁，先用split函数分成一个切片，用switch-case(判断。。和。)最后再组合</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">simplifyPath</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> path==<span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> path    &#125;    <span class="hljs-keyword">var</span> str []<span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> strs <span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> _,v :=<span class="hljs-keyword">range</span> strings.Split(path,<span class="hljs-string">&quot;/&quot;</span>)&#123;        <span class="hljs-keyword">switch</span> v &#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&quot;</span>:  <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;.&quot;</span>: <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;..&quot;</span>: <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(str)&gt;<span class="hljs-number">0</span>&#123;            str = str[:<span class="hljs-built_in">len</span>(str)<span class="hljs-number">-1</span>]        &#125;        <span class="hljs-keyword">default</span>:str = <span class="hljs-built_in">append</span>(str,v)        &#125;    &#125;    strs = <span class="hljs-string">&quot;/&quot;</span>+strings.Join(str,<span class="hljs-string">&quot;/&quot;</span>)    <span class="hljs-keyword">return</span>  strs&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.1 MB, 在所有 Go 提交中击败了73.61%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>81. 搜索旋转排序数组 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="搜索旋转排序数组-II"><a href="#搜索旋转排序数组-II" class="headerlink" title="搜索旋转排序数组 II"></a><font size=6px>搜索旋转排序数组 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0<br>输出：true<br>示例 2：</p><p>输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3<br>输出：false</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p><p>进阶：</p><p>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。<br>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>跟旋转排序数组差不多，就是把重复的前几个数去掉保证第一个和最后一个事不相同</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>&amp;&amp;nums[i]==nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>];&#123;        nums = <span class="hljs-built_in">append</span>(nums[<span class="hljs-number">1</span>:])    &#125;    <span class="hljs-keyword">if</span> search1(nums,target)==<span class="hljs-number">-1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search1</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) ==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] ==target&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        &#125;    &#125;        i,j:=<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i&lt;=j&#123;        mid := (i+j)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> nums[mid] == target&#123;            <span class="hljs-keyword">return</span> mid        &#125;        <span class="hljs-keyword">if</span> nums[mid] &gt;=nums[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">if</span> target &lt;nums[mid]&amp;&amp;target&gt;=nums[<span class="hljs-number">0</span>]&#123;                j = mid<span class="hljs-number">-1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                i = mid+<span class="hljs-number">1</span>            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> nums[mid]&lt;target&amp;&amp;target&lt;=nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#123;                i = mid+<span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                j = mid<span class="hljs-number">-1</span>            &#125;        &#125;            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了92.09%的用户<br>   内存消耗：3.2 MB, 在所有 Go 提交中击败了99.94%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>84. 柱状图中最大的矩形</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a><font size=6px>柱状图中最大的矩形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。</p><h4 id="思路-‘"><a href="#思路-‘" class="headerlink" title="思路:‘"></a>思路:‘</h4><p>第一种解法，暴力，这道问题的暴力解法比「接雨水」那道题要其实好想得多：可以枚举以每个柱形为高度的最大矩形的面积。</p><p>具体来说就是：依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。（golang会超时）</p><p>第二种解法是哨兵加上单调栈，就是如果出现前一个和后一个都比这个数小，就说明这个数的最大面积已经算出来的，可以出局了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">//第一种解法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(heights)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> sum,max,i,j <span class="hljs-type">int</span>     <span class="hljs-keyword">for</span> k,v :=<span class="hljs-keyword">range</span> heights&#123;        <span class="hljs-keyword">for</span> i = k<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;<span class="hljs-built_in">len</span>(heights);i--&#123;            <span class="hljs-keyword">if</span> heights[i]&lt;heights[k]&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        <span class="hljs-keyword">for</span> j = k+<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;<span class="hljs-built_in">len</span>(heights);j++&#123;            <span class="hljs-keyword">if</span> heights[j]&lt;heights[k]&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;        sum = (j-i<span class="hljs-number">-1</span>) *v        fmt.Println(sum)        <span class="hljs-keyword">if</span> sum&gt;max&#123;            max = sum        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><pre><code class="hljs go"><span class="hljs-comment">//解法二</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(heights) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;stack := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(heights))heights = <span class="hljs-built_in">append</span>(heights, <span class="hljs-number">-1</span>)heights = <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>&#125;, heights...)<span class="hljs-keyword">var</span> maxsize <span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(heights); i++ &#123;<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span>&amp;&amp;heights[Peek(stack)] &gt; heights[i] &#123;stack, v := Pop(stack)<span class="hljs-keyword">if</span> sum := (i - Peek(stack) - <span class="hljs-number">1</span>) * heights[v]; sum &gt; maxsize &#123;maxsize = sum&#125;&#125;stack = <span class="hljs-built_in">append</span>(stack, i)&#125;<span class="hljs-keyword">return</span> maxsize&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pop</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> ([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;s := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<span class="hljs-keyword">return</span> stack, s&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Peek</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：108 ms, 在所有 Go 提交中击败了49.43%的用户<br>   内存消耗：9.1 MB, 在所有 Go 提交中击败了30.36%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>85. 最大矩形</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/85.%20%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a><font size=6px>最大矩形</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p>示例 1：</p><p>输入：matrix &#x3D; [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：6<br>解释：最大矩形如上图所示。<br>示例 2：</p><p>输入：matrix &#x3D; []<br>输出：0<br>示例 3：</p><p>输入：matrix &#x3D; [[“0”]]<br>输出：0<br>示例 4：</p><p>输入：matrix &#x3D; [[“1”]]<br>输出：1<br>示例 5：</p><p>输入：matrix &#x3D; [[“0”,”0”]]<br>输出：0</p><p>提示：</p><p>rows &#x3D;&#x3D; matrix.length<br>cols &#x3D;&#x3D; matrix[0].length<br>0 &lt;&#x3D; row, cols &lt;&#x3D; 200<br>matrix[i][j] 为 ‘0’ 或 ‘1’</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用哨兵和单调栈思路，和84题思路相同，区别是这得一行一行遍历，算出这一行的最大矩阵，最后得出最大矩阵</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(matrix [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> levelheight []<span class="hljs-type">int</span><span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>num := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(matrix);i++&#123;<span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]);j++&#123;<span class="hljs-keyword">for</span> k:=i;k&gt;=<span class="hljs-number">0</span>;k--&#123;                <span class="hljs-keyword">if</span> matrix[k][j]==<span class="hljs-string">&#x27;1&#x27;</span>&#123;                    num++                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">break</span>                &#125;            &#125;levelheight = <span class="hljs-built_in">append</span>(levelheight,num)            num = <span class="hljs-number">0</span>&#125;        <span class="hljs-comment">//fmt.Println(levelheight)</span>linemax :=largestRectangleArea(levelheight)levelheight = levelheight[:<span class="hljs-number">0</span>]<span class="hljs-keyword">if</span> max &lt; linemax&#123;max = linemax&#125;&#125;<span class="hljs-keyword">return</span> max&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(heights) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;stack := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(heights))heights = <span class="hljs-built_in">append</span>(heights, <span class="hljs-number">-1</span>)heights = <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>&#125;, heights...)<span class="hljs-keyword">var</span> maxsize <span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(heights); i++ &#123;<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span>&amp;&amp;heights[Peek(stack)] &gt; heights[i] &#123;s, v := Pop(stack)stack = s<span class="hljs-keyword">if</span> sum := (i - Peek(stack) - <span class="hljs-number">1</span>) * heights[v]; sum &gt; maxsize &#123;maxsize = sum&#125;&#125;stack = <span class="hljs-built_in">append</span>(stack, i)&#125;<span class="hljs-keyword">return</span> maxsize&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pop</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> ([]<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;s := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<span class="hljs-keyword">return</span> stack, s&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Peek</span><span class="hljs-params">(stack []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了86.94%的用户<br>   内存消耗：4.9 MB, 在所有 Go 提交中击败了35.08%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23. 合并K个升序链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a><font size=6px>合并K个升序链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例 1：</p><p>输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>示例 2：</p><p>输入：lists &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：lists &#x3D; [[]]<br>输出：[]</p><p>提示：</p><p>k &#x3D;&#x3D; lists.length<br>0 &lt;&#x3D; k &lt;&#x3D; 10^4<br>0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500<br>-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4<br>lists[i] 按 升序 排列<br>lists[i].length 的总和不超过 10^4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>思路很简单，写一个两个链表合并的函数，每次两个链表合并最后输出</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists []*ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lists)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lists)&lt;<span class="hljs-number">2</span>&#123;         <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>]            &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(lists);i++&#123;        lists[<span class="hljs-number">0</span>] = mergeTwoLists(lists[i],lists[<span class="hljs-number">0</span>])    &#125;    <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;    <span class="hljs-keyword">if</span> l1==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> l2    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> l1    &#125;    head,l3 := &amp;ListNode&#123;&#125;,&amp;ListNode&#123;&#125;    <span class="hljs-keyword">if</span> l1.Val&gt;l2.Val&#123;        head = l2    &#125;<span class="hljs-keyword">else</span>&#123;        head = l1    &#125;        <span class="hljs-keyword">for</span> l1!=<span class="hljs-literal">nil</span>&amp;&amp;l2!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">if</span> l1.Val &gt; l2.Val&#123;            l3.Next=l2            l3 = l2            l2 = l2.Next        &#125;<span class="hljs-keyword">else</span>&#123;            l3.Next=l1            l3 = l1            l1 = l1.Next        &#125;    &#125;    <span class="hljs-keyword">if</span> l1!=<span class="hljs-literal">nil</span>&#123;        l3.Next = l1    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l2!=<span class="hljs-literal">nil</span>&#123;        l3.Next = l2    &#125;    <span class="hljs-keyword">return</span> head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：112 ms, 在所有 Go 提交中击败了32.23%的用户<br>   内存消耗：5.3 MB, 在所有 Go 提交中击败了73.77%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>234. 回文链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><font size=6px>234. 回文链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p><p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第一种简单的思路是遍历一遍，将数据保存在数组里面，然后从两边开始遍历</p><p>第二种是进阶算法，用快慢指针，一个指针一次走两步，一个一次走一步，然后快指针走完慢指针刚刚走到一半，将后半链表逆置，然后前半链表和后半比较</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> head.Next==<span class="hljs-literal">nil</span>||head==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">var</span> pre *ListNode=<span class="hljs-literal">nil</span>    fast,slow :=head,head    <span class="hljs-keyword">for</span> fast!=<span class="hljs-literal">nil</span>&amp;&amp;fast.Next!=<span class="hljs-literal">nil</span>&#123;        fast=fast.Next.Next        pre=slow        slow=slow.Next    &#125;    pre.Next=<span class="hljs-literal">nil</span><span class="hljs-comment">//翻转链表</span><span class="hljs-keyword">var</span> head2 *ListNode=<span class="hljs-literal">nil</span><span class="hljs-keyword">for</span>(slow!=<span class="hljs-literal">nil</span>)&#123;    tmp:=slow.Next    slow.Next=head2    head2=slow    slow=tmp&#125;    <span class="hljs-keyword">for</span> head!=<span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">if</span> head2.Val!=head.Val&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;<span class="hljs-keyword">else</span>&#123;                head=head.Next                head2=head2.Next            &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：172 ms, 在所有 Go 提交中击败了23.75%的用户<br>   内存消耗：9.3 MB, 在所有 Go 提交中击败了29.47%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>236. 二叉树的最近公共祖先</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><font size=6px>二叉树的最近公共祖先</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例 1：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>示例 2：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<br>示例 3：</p><p>输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>输出：1</p><p>提示：</p><p>树中节点数目在范围 [2, 105] 内。<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>所有 Node.val 互不相同 。<br>p !&#x3D; q<br>p 和 q 均存在于给定的二叉树中。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用递归的思路做，从下往上找，如果left！&#x3D;nil&amp;&amp;right!&#x3D;nil 则代表找到了，返回那个结点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    <span class="hljs-keyword">if</span> q.Val==root.Val||p.Val==root.Val&#123;        <span class="hljs-keyword">return</span> root    &#125;    left := lowestCommonAncestor(root.Left,p,q)    right := lowestCommonAncestor(root.Right,p,q)    <span class="hljs-comment">//代表左右结点都找到了</span>    <span class="hljs-keyword">if</span> left!=<span class="hljs-literal">nil</span> &amp;&amp; right!=<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> root    &#125;    <span class="hljs-keyword">if</span> right==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> left    &#125;    <span class="hljs-keyword">return</span> right&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了91.60%的用户<br>   内存消耗：7.6 MB, 在所有 Go 提交中击败了31.55%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25. K 个一组翻转链表</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/25.%20K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title=" K 个一组翻转链表"></a><font size=6px> K 个一组翻转链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[2,1,4,3,5]<br>示例 2：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3<br>输出：[3,2,1,4,5]<br>示例 3：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 1<br>输出：[1,2,3,4,5]<br>示例 4：</p><p>输入：head &#x3D; [1], k &#x3D; 1<br>输出：[1]<br>提示：</p><p>列表中节点的数量在范围 sz 内<br>1 &lt;&#x3D; sz &lt;&#x3D; 5000<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>1 &lt;&#x3D; k &lt;&#x3D; sz</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>先遍历k遍判断有没有到终点，遍历之后找到一段的tail和head，然后进入reverse函数，倒转head和tail，表的head和tail连接主表的pre和nex</p><pre><code class="hljs ini"><span class="hljs-attr">pre.Next</span>=head<span class="hljs-attr">tail.Next</span>=nex</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;    hair := &amp;ListNode&#123;Next: head&#125;    pre:=hair    <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> head    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span> head!=<span class="hljs-literal">nil</span>&#123;            tail:=pre            <span class="hljs-comment">//判断结点数量大不大于k个</span>            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;k;i++&#123;                tail=tail.Next                <span class="hljs-keyword">if</span> tail==<span class="hljs-literal">nil</span>&#123;                    <span class="hljs-keyword">return</span> hair.Next                &#125;            &#125;            nex:=tail.Next            head,tail=reverse(head,tail)            pre.Next=head            tail.Next=nex            pre=tail            head=tail.Next                    &#125;    &#125;    <span class="hljs-keyword">return</span> hair.Next&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head,tail *ListNode)</span></span>(*ListNode,*ListNode)&#123;    <span class="hljs-keyword">var</span> head2 *ListNode=<span class="hljs-literal">nil</span>    p:=head    tail.Next=<span class="hljs-literal">nil</span>    <span class="hljs-keyword">for</span> p!=<span class="hljs-literal">nil</span>&#123;        tmp:=p.Next        p.Next=head2        head2=p        p=tmp    &#125;    <span class="hljs-keyword">return</span> head2,head&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了90.13%的用户<br>   内存消耗：3.6 MB, 在所有 Go 提交中击败了50.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>300. 最长递增子序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><font size=6px>最长递增子序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p><p>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p><p>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p><p>进阶：</p><p>你可以设计时间复杂度为 O(n2) 的解决方案吗？<br>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>进阶的还没想出来，本方法时间复杂度位O（n^2）</p><p>用动态规划，在 第i个数，arr[i] 比0到第i-1个数大，就找dp[i-1到0]最大的那个数加1，dp数组意思是这个数为结尾的最大递增序列为多少。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> nums==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> dp [<span class="hljs-number">2501</span>]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">2501</span> ;i++&#123;        dp[i]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        max =<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;i;j++&#123;            <span class="hljs-keyword">if</span> nums[i]&gt;nums[j]&#123;                <span class="hljs-keyword">if</span> max&lt;dp[j]+<span class="hljs-number">1</span>&#123;                    max = dp[j]+<span class="hljs-number">1</span>                &#125;            &#125;        &#125;        dp[i] = max            &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> max &lt; dp[i]&#123;            max = dp[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：64 ms, 在所有 Go 提交中击败了68.43%的用户<br>   内存消耗：3.5 MB, 在所有 Go 提交中击败了95.62%的用户</p><p>优化版本</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(nums)    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    <span class="hljs-built_in">len</span> := <span class="hljs-number">1</span>    dp[<span class="hljs-built_in">len</span>] = nums[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> dp[<span class="hljs-built_in">len</span>] &lt; nums[i]&#123;            <span class="hljs-built_in">len</span>++            dp[<span class="hljs-built_in">len</span>] = nums[i]        &#125;<span class="hljs-keyword">else</span>&#123;            l,r,pos := <span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>,<span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> l &lt;= r&#123;                mid := (l+r)&gt;&gt;<span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> dp[mid] &lt; nums[i]&#123;                     l = mid+<span class="hljs-number">1</span>                    pos = mid                                    &#125;<span class="hljs-keyword">else</span>&#123;                   r = mid<span class="hljs-number">-1</span>                &#125;            &#125;            dp[pos+<span class="hljs-number">1</span>] = nums[i]        &#125;        <span class="hljs-comment">//fmt.Println(dp)</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>&#125;</code></pre><p>执行用时：4 ms, 在所有 Go 提交中击败了98.09%的用户</p><p>内存消耗：3.4 MB, 在所有 Go 提交中击败了89.60%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>32. 最长有效括号</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a><font size=6px>最长有效括号</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>示例 1：</p><p>输入：s &#x3D; “(()”<br>输出：2<br>解释：最长有效括号子串是 “()”<br>示例 2：</p><p>输入：s &#x3D; “)()())”<br>输出：4<br>解释：最长有效括号子串是 “()()”<br>示例 3：</p><p>输入：s &#x3D; “”<br>输出：0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用栈的思想做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> stack []<span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> maxnum <span class="hljs-type">int</span>    stack = <span class="hljs-built_in">append</span>(stack,<span class="hljs-number">-1</span>)        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;            stack = <span class="hljs-built_in">append</span>(stack,i)        &#125;<span class="hljs-keyword">else</span>&#123;            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack ) == <span class="hljs-number">0</span>&#123;                stack = <span class="hljs-built_in">append</span>(stack,i)            &#125;<span class="hljs-keyword">else</span>&#123;                maxnum = max(maxnum,i-stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> maxnum&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">( a <span class="hljs-type">int</span>,b <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.5 MB, 在所有 Go 提交中击败了30.20%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a><font size=6px>搜索旋转排序数组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>示例 1：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出：4<br>示例 2：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>输出：-1<br>示例 3：</p><p>输入：nums &#x3D; [1], target &#x3D; 0<br>输出：-1</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>第二个是顺序查找的快速版，主要讲第一个二分查找版，因为mid两边肯定有一边是有序的，如果左边有序，并且target大于有序的边的最小数，那就往有序边查，如果没有那就往半有序边查</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">//二分查找版</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) ==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] ==target&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>        &#125;    &#125;        i,j:=<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">for</span> i&lt;=j&#123;        mid := (i+j)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> nums[mid] == target&#123;            <span class="hljs-keyword">return</span> mid        &#125;        <span class="hljs-keyword">if</span> nums[mid] &gt;=nums[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">if</span> target &lt;nums[mid]&amp;&amp;target&gt;=nums[<span class="hljs-number">0</span>]&#123;                j = mid<span class="hljs-number">-1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                i = mid+<span class="hljs-number">1</span>            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span> nums[mid]&lt;target&amp;&amp;target&lt;=nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#123;                i = mid+<span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                j = mid<span class="hljs-number">-1</span>            &#125;        &#125;            &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;    <span class="hljs-keyword">if</span> target&gt;nums[<span class="hljs-number">0</span>]&#123;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums)&amp;&amp;nums[i<span class="hljs-number">-1</span>]&lt;nums[i];i++&#123;            <span class="hljs-keyword">if</span> target == nums[i]&#123;                <span class="hljs-keyword">return</span> i            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> target == nums[<span class="hljs-number">0</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> target == nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>    &#125; <span class="hljs-keyword">else</span>  &#123;        <span class="hljs-keyword">for</span> j:= <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>;j&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[j] &lt; nums[j+<span class="hljs-number">1</span>];j--&#123;            <span class="hljs-keyword">if</span> target ==nums[j]&#123;                <span class="hljs-keyword">return</span> j            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>354. 俄罗斯套娃信封问题</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/354.%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/354.%20%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="俄罗斯套娃信封问题"><a href="#俄罗斯套娃信封问题" class="headerlink" title="俄罗斯套娃信封问题"></a><font size=6px>俄罗斯套娃信封问题</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] &#x3D; [wi, hi] ，表示第 i 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>注意：不允许旋转信封。</p><p>示例 1：</p><p>输入：envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]<br>输出：3<br>解释：最多信封的个数为 3, 组合为: [2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]。<br>示例 2：</p><p>输入：envelopes &#x3D; [[1,1],[1,1],[1,1]]<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; envelopes.length &lt;&#x3D; 5000<br>envelopes[i].length &#x3D;&#x3D; 2<br>1 &lt;&#x3D; wi, hi &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>把二维排序 先固定一维，就变成了一维问题，先按第一列升序，第二列降序排序，之后就变成第二列的最大升序问题，就可以求出答案</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(envelopes [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    myarr:=&amp;Intarr&#123;envelopes,<span class="hljs-number">0</span>&#125;    sort.Sort(myarr)    max:=lengthOfLIS(envelopes)    <span class="hljs-keyword">return</span> max&#125;<span class="hljs-keyword">type</span> Intarr <span class="hljs-keyword">struct</span> &#123;    marr [][]<span class="hljs-type">int</span>    line <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr *Intarr)</span></span>Len() <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(arr.marr)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr *Intarr)</span></span>Swap(i,j <span class="hljs-type">int</span>)  &#123;    arr.marr[i],arr.marr[j]=arr.marr[j],arr.marr[i]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr *Intarr)</span></span>Less(i,j <span class="hljs-type">int</span>)<span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">if</span> arr.marr[i][arr.line] &lt; arr.marr[j][arr.line]&#123;        <span class="hljs-keyword">return</span>  <span class="hljs-literal">true</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> arr.marr[i][arr.line] &gt; arr.marr[j][arr.line]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">if</span> arr.marr[i][<span class="hljs-number">1</span>]&gt;arr.marr[j][<span class="hljs-number">1</span>]&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> nums==<span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-keyword">var</span> dp [<span class="hljs-number">5001</span>]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">5001</span>;i++&#123;        dp[i]=<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        max =<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;i;j++&#123;            <span class="hljs-keyword">if</span> nums[i][<span class="hljs-number">1</span>]&gt;nums[j][<span class="hljs-number">1</span>]&#123;                <span class="hljs-keyword">if</span> max&lt;dp[j]+<span class="hljs-number">1</span>&#123;                    max = dp[j]+<span class="hljs-number">1</span>                &#125;            &#125;        &#125;        dp[i] = max            &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> max &lt; dp[i]&#123;            max = dp[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：268 ms, 在所有 Go 提交中击败了42.09%的用户<br>   内存消耗：6.3 MB, 在所有 Go 提交中击败了99.65%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39. 组合总和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><font size=6px>组合总和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p>示例 1：</p><p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。<br>示例 2：</p><p>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]<br>示例 3：</p><p>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []<br>示例 4：</p><p>输入: candidates &#x3D; [1], target &#x3D; 1<br>输出: [[1]]<br>示例 5：</p><p>输入: candidates &#x3D; [1], target &#x3D; 2<br>输出: [[1,1]]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用dfs遍历</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span>temp := []<span class="hljs-type">int</span>&#123;&#125;dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;cpy := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(temp))<span class="hljs-built_in">copy</span>(cpy, temp)res = <span class="hljs-built_in">append</span>(res, cpy)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">for</span> i := idx; i &lt; <span class="hljs-built_in">len</span>(candidates); i++ &#123;<span class="hljs-keyword">if</span> target-candidates[i] &gt;= <span class="hljs-number">0</span> &#123;temp = <span class="hljs-built_in">append</span>(temp, candidates[i])dfs(target-candidates[i], i)temp = temp[:<span class="hljs-built_in">len</span>(temp)<span class="hljs-number">-1</span>]&#125;&#125;&#125;dfs(target, <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.7 MB, 在所有 Go 提交中击败了98.82%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>393. UTF-8 编码验证</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/393.%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/393.%20UTF-8%20%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h3 id="UTF-8-编码验证"><a href="#UTF-8-编码验证" class="headerlink" title="UTF-8 编码验证"></a><font size=6px>UTF-8 编码验证</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：</p><p>对于 1 字节的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。<br>对于 n 字节的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。<br>这是 UTF-8 编码的工作方式：</p><p>   Char. number range  |        UTF-8 octet sequence<br>      (hexadecimal)    |              (binary)<br>   ——————–+———————————————<br>   0000 0000-0000 007F | 0xxxxxxx<br>   0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br>给定一个表示数据的整数数组，返回它是否为有效的 utf-8 编码。</p><p>注意：<br>输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。</p><p>示例 1：</p><p>data &#x3D; [197, 130, 1], 表示 8 位的序列: 11000101 10000010 00000001.</p><p>返回 true 。<br>这是有效的 utf-8 编码，为一个2字节字符，跟着一个1字节字符。<br>示例 2：</p><p>data &#x3D; [235, 140, 4], 表示 8 位的序列: 11101011 10001100 00000100.</p><p>返回 false 。<br>前 3 位都是 1 ，第 4 位为 0 表示它是一个3字节字符。<br>下一个字节是开头为 10 的延续字节，这是正确的。<br>但第二个延续字节不以 10 开头，所以是不符合规则的。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>相信很多人都跟我一样读不懂题目，我稍微讲解一下，要看第一个数字，第一个数字的最后八位如果是110xxxxx，说明之后有1个数是10xxxxxx，0xxxxxx的数字可以有好多个，如果是1110xxxx，说明有2个数字10xxxxxx，0xxxxxxx依旧可以有好多个，理解了题目做起来不难，不会看我的代码</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validUtf8</span><span class="hljs-params">(data []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    count :=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(data);i++&#123;        <span class="hljs-keyword">if</span> count==<span class="hljs-number">0</span>&#123;            count = bitNuber(data[i])        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//等不等于10xxxxxx</span>            <span class="hljs-keyword">if</span> (data[i] &gt;&gt;<span class="hljs-number">6</span>) != <span class="hljs-number">2</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;            count--            <span class="hljs-keyword">if</span> count==<span class="hljs-number">-1</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;                   &#125;    &#125;    <span class="hljs-keyword">return</span> count==<span class="hljs-number">0</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bitNuber</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-comment">//0xxxxxxx</span>    <span class="hljs-keyword">if</span> num&gt;&gt;<span class="hljs-number">7</span> ==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    <span class="hljs-comment">//11110xxx</span>    <span class="hljs-keyword">if</span> num &gt;&gt;<span class="hljs-number">3</span> ==<span class="hljs-number">30</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>    &#125;    <span class="hljs-comment">//1110xxxx</span>    <span class="hljs-keyword">if</span> num &gt;&gt;<span class="hljs-number">4</span> == <span class="hljs-number">14</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>    &#125;    <span class="hljs-comment">//110xxxxx</span>    <span class="hljs-keyword">if</span> num &gt;&gt;<span class="hljs-number">5</span> ==<span class="hljs-number">6</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    &#125;     <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了75.95%的用户<br>   内存消耗：5.2 MB, 在所有 Go 提交中击败了29.11%的用户</p><h2 id="后面第二次又因为每日一题做到了，就再做了一次"><a href="#后面第二次又因为每日一题做到了，就再做了一次" class="headerlink" title="后面第二次又因为每日一题做到了，就再做了一次"></a>后面第二次又因为每日一题做到了，就再做了一次</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h3><p>硬模拟就行了，代码丑但是竟然效率还高了</p><pre><code class="hljs kotlin">func validUtf8(<span class="hljs-keyword">data</span> []int) bool &#123;    cnt :=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;len(<span class="hljs-keyword">data</span>);&#123;        <span class="hljs-keyword">if</span> cnt != <span class="hljs-number">0</span>&#123;            <span class="hljs-comment">// 后面的数字个数符不符合</span>            <span class="hljs-keyword">if</span> i+cnt &gt;len(<span class="hljs-keyword">data</span>)&#123;                               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">for</span> j:=i;j&lt;i+cnt;j++&#123;                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">data</span>[j]&lt;<span class="hljs-number">128</span> || <span class="hljs-keyword">data</span>[j]&gt;<span class="hljs-number">191</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>                    &#125;                &#125;                i += cnt                cnt = <span class="hljs-number">0</span>                <span class="hljs-keyword">continue</span>            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">data</span>[i]&lt;<span class="hljs-number">128</span>&#123;            i++            <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">data</span>[i] &gt;<span class="hljs-number">247</span>&#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>  (<span class="hljs-keyword">data</span>[i] &amp; <span class="hljs-number">240</span>) == <span class="hljs-number">240</span>&#123;                cnt = <span class="hljs-number">3</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span>[i] &amp; <span class="hljs-number">224</span>) == <span class="hljs-number">224</span>&#123;            cnt = <span class="hljs-number">2</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span>[i] &amp; <span class="hljs-number">192</span> == <span class="hljs-number">192</span>)&#123;            cnt = <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        i++    &#125;    <span class="hljs-keyword">if</span> cnt != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>; <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size:22px&quot;</span>&gt;</span>   执行用时：8 ms, 在所有 Go 提交中击败了97.44%的用户<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>   内存消耗：5 MB, 在所有 Go 提交中击败了92.31%的用户<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>43. 字符串相乘</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/43.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a><font size=6px>字符串相乘</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><p>输入: num1 &#x3D; “2”, num2 &#x3D; “3”<br>输出: “6”<br>示例 2:</p><p>输入: num1 &#x3D; “123”, num2 &#x3D; “456”<br>输出: “56088”<br>说明：</p><p>num1 和 num2 的长度小于110。<br>num1 和 num2 只包含数字 0-9。<br>num1 和 num2 均不以零开头，除非是数字 0 本身。<br>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>很普通的大数相乘，就是golang如果想用【】byte来处理会溢出，记得用数组处理</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiply</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> num1[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> || num2[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>&#125;s1, s2 := []<span class="hljs-type">byte</span>(num1), []<span class="hljs-type">byte</span>(num2)s3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s1)+<span class="hljs-built_in">len</span>(s2))<span class="hljs-comment">//string reverse</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s1)/<span class="hljs-number">2</span>; i++ &#123;s1[i], s1[<span class="hljs-built_in">len</span>(s1)<span class="hljs-number">-1</span>-i] = s1[<span class="hljs-built_in">len</span>(s1)<span class="hljs-number">-1</span>-i], s1[i]&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s2)/<span class="hljs-number">2</span>; i++ &#123;s2[i], s2[<span class="hljs-built_in">len</span>(s2)<span class="hljs-number">-1</span>-i] = s2[<span class="hljs-built_in">len</span>(s2)<span class="hljs-number">-1</span>-i], s2[i]&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s1); i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(s2); j++ &#123;s3[i+j] += <span class="hljs-type">int</span>((s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (s2[j] - <span class="hljs-string">&#x27;0&#x27;</span>))&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s1)+<span class="hljs-built_in">len</span>(s2); i++ &#123;<span class="hljs-keyword">if</span> s3[i] &gt;= <span class="hljs-number">10</span> &#123;s3[i+<span class="hljs-number">1</span>] += s3[i] / <span class="hljs-number">10</span>s3[i] = s3[i] % <span class="hljs-number">10</span>&#125;&#125;i := <span class="hljs-built_in">len</span>(s1) + <span class="hljs-built_in">len</span>(s2) - <span class="hljs-number">1</span><span class="hljs-keyword">for</span> s3[i] == <span class="hljs-number">0</span> &#123;i--&#125;s3 = s3[<span class="hljs-number">0</span> : i+<span class="hljs-number">1</span>]<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(s3)/<span class="hljs-number">2</span>; j++ &#123;s3[j], s3[<span class="hljs-built_in">len</span>(s3)<span class="hljs-number">-1</span>-j] = s3[<span class="hljs-built_in">len</span>(s3)<span class="hljs-number">-1</span>-j], s3[j]&#125;<span class="hljs-keyword">var</span> tmp []<span class="hljs-type">byte</span><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s3); i++ &#123;tmp = <span class="hljs-built_in">append</span>(tmp, <span class="hljs-type">byte</span>(s3[i])+<span class="hljs-string">&#x27;0&#x27;</span>)&#125;<span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(tmp)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了84.69%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>432. 全 O(1) 的数据结构</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/432.%20%E5%85%A8%20O(1)%20%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/432.%20%E5%85%A8%20O(1)%20%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="全-O-1-的数据结构"><a href="#全-O-1-的数据结构" class="headerlink" title="全 O(1) 的数据结构"></a><font size=6px>全 O(1) 的数据结构</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请你实现一个数据结构支持以下操作：</p><p>Inc(key) - 插入一个新的值为 1 的 key。或者使一个存在的 key 增加一，保证 key 不为空字符串。<br>Dec(key) - 如果这个 key 的值是 1，那么把他从数据结构中移除掉。否则使一个存在的 key 值减一。如果这个 key 不存在，这个函数不做任何事情。key 保证不为空字符串。<br>GetMaxKey() - 返回 key 中值最大的任意一个。如果没有元素存在，返回一个空字符串”” 。<br>GetMinKey() - 返回 key 中值最小的任意一个。如果没有元素存在，返回一个空字符串””。</p><p>挑战：</p><p>你能够以 O(1) 的时间复杂度实现所有操作吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>跟LRU类似，用哈希双向链表来做，还有很多不足，代码有些插入和删除可以提取出来写成函数，懒了。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">type</span> AllOne <span class="hljs-keyword">struct</span> &#123;mp   <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*nodetail *nodehead *node&#125;<span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;next  *nodepre   *nodekey   <span class="hljs-type">string</span>value <span class="hljs-type">int</span>&#125;<span class="hljs-comment">/** Initialize your data structure here. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> AllOne &#123;tail := &amp;node&#123;&#125;head := &amp;node&#123;&#125;head.next = tailtail.pre = head<span class="hljs-keyword">return</span> AllOne&#123;mp: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node), tail: tail, head: head&#125;&#125;<span class="hljs-comment">/** Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> Inc(key <span class="hljs-type">string</span>) &#123;<span class="hljs-keyword">if</span> _, ok := this.mp[key]; ok &#123;this.mp[key].value++nodeNext := this.mp[key].next<span class="hljs-comment">//delete the node</span>this.mp[key].pre.next = this.mp[key].nextthis.mp[key].next.pre = this.mp[key].pre<span class="hljs-keyword">for</span> this.mp[key].value &gt;= nodeNext.value &amp;&amp; nodeNext != this.tail &#123;nodeNext = nodeNext.next&#125;nodeNext.pre.next = this.mp[key]this.mp[key].pre = nodeNext.prethis.mp[key].next = nodeNextnodeNext.pre = this.mp[key]&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//insert</span>headNext := this.head.nextnode := &amp;node&#123;key: key, value: <span class="hljs-number">1</span>&#125;this.mp[key] = nodethis.head.next = this.mp[key]this.mp[key].pre = this.headthis.mp[key].next = headNextheadNext.pre = this.mp[key]&#125;&#125;<span class="hljs-comment">/* Decrements an existing key by 1. If Key&#x27;s value is 1, remove it from the data structure. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> Dec(key <span class="hljs-type">string</span>) &#123;<span class="hljs-keyword">if</span> this.mp[key].value &gt; <span class="hljs-number">1</span> &#123;this.mp[key].value--&#125; <span class="hljs-keyword">else</span> &#123;this.mp[key].pre.next = this.mp[key].nextthis.mp[key].next.pre = this.mp[key].pre<span class="hljs-built_in">delete</span>(this.mp, key)&#125;&#125;<span class="hljs-comment">/** Returns one of the keys with maximal value. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> GetMaxKey() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> this.tail.pre == this.head &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> this.tail.pre.key&#125;&#125;<span class="hljs-comment">/** Returns one of the keys with Minimal value. */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *AllOne)</span></span> GetMinKey() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> this.tail.pre == this.head &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> this.head.next.key&#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：36 ms, 在所有 Go 提交中击败了84.78%的用户<br>   内存消耗：9.3 MB, 在所有 Go 提交中击败了99.46%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53. 最大子序和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a><font size=6px>最大子序和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例 1：</p><p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p><p>输入：nums &#x3D; [1]<br>输出：1<br>示例 3：</p><p>输入：nums &#x3D; [0]<br>输出：0<br>示例 4：</p><p>输入：nums &#x3D; [-1]<br>输出：-1<br>示例 5：</p><p>输入：nums &#x3D; [-100000]<br>输出：-100000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>就累加，如果小于0就重新累加，如果都是负数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> i,sum,flag <span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> max <span class="hljs-type">int</span>=<span class="hljs-number">-999</span>    max=nums[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        sum+=nums[i]        <span class="hljs-keyword">if</span> sum&lt;<span class="hljs-number">0</span>&#123;            sum=<span class="hljs-number">0</span>        &#125;<span class="hljs-keyword">else</span>&#123;            flag=<span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> max&lt;sum&#123;                max=sum            &#125;        &#125;    &#125;    <span class="hljs-comment">//为了防止都是负数的情况</span>    <span class="hljs-keyword">if</span> flag==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">for</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;            <span class="hljs-keyword">if</span> max&lt;nums[i]&#123;                max=nums[i]            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> max&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了45.81%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>动态规划</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>46. 全排列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/46.%20%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/46.%20%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><font size=6px>46. 全排列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>一道经典dfs的题目，记得使用完之后得复原之前的样子，为什么要复制一份再append进去，因为这个path所指向的内存空间在之后还得用，所以path所引用的内容会变化</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> [][]<span class="hljs-type">int</span>&#123;&#125;    &#125;res := [][]<span class="hljs-type">int</span>&#123;&#125;<span class="hljs-keyword">var</span> recall <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(path []<span class="hljs-type">int</span>,start <span class="hljs-type">int</span>)</span></span>recall = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(path []<span class="hljs-type">int</span>,start <span class="hljs-type">int</span>)</span></span>&#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(nums)&#123;            temp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(path))<span class="hljs-built_in">copy</span>(temp, path)res = <span class="hljs-built_in">append</span>(res, temp)            <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-keyword">for</span> i:=start;i&lt;<span class="hljs-built_in">len</span>(nums)&amp;&amp;i&gt;=<span class="hljs-number">0</span>;i++&#123;            flag := <span class="hljs-literal">false</span>            <span class="hljs-comment">//看是否有重复的数字</span>            <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> path&#123;                <span class="hljs-keyword">if</span> v ==nums[i]&#123;                    flag = <span class="hljs-literal">true</span>                    <span class="hljs-keyword">break</span>                &#125;            &#125;            <span class="hljs-keyword">if</span> flag==<span class="hljs-literal">true</span>&#123;                <span class="hljs-keyword">continue</span>            &#125;            path = <span class="hljs-built_in">append</span>(path,nums[i])            recall(path,start)            path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]        &#125;&#125;    recall([]<span class="hljs-type">int</span>&#123;&#125;,<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.7 MB, 在所有 Go 提交中击败了56.75%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><font size=6px><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例 1：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCCED”<br>输出：true<br>示例 2：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “SEE”<br>输出：true<br>示例 3：</p><p>输入：board &#x3D; [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word &#x3D; “ABCB”<br>输出：false</p><p>提示：</p><p>m &#x3D;&#x3D; board.length<br>n &#x3D; board[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 6<br>1 &lt;&#x3D; word.length &lt;&#x3D; 15<br>board 和 word 仅由大小写英文字母组成</p><p>进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>经典dfs题，visit访问时要置1，最后访问完后重新置0</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exist</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>, word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;    m,n := <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])     visit := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(board))    valid := <span class="hljs-literal">false</span>    move := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(board); i++&#123;        visit[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(board[i]))    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num, x,y <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(count,x,y <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> count == <span class="hljs-built_in">len</span>(word)&#123;            valid = <span class="hljs-literal">true</span>        &#125;        <span class="hljs-keyword">if</span> valid&#123;            <span class="hljs-keyword">return</span>         &#125;        visit[x][y] = <span class="hljs-literal">true</span>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>;i++&#123;            new_x := x+move[i*<span class="hljs-number">2</span>]            new_y := y+move[i*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>]            <span class="hljs-keyword">if</span> new_x &gt;= <span class="hljs-number">0</span> &amp;&amp; new_x &lt; m &amp;&amp; new_y &gt;=<span class="hljs-number">0</span> &amp;&amp; new_y &lt;n &amp;&amp; visit[new_x][new_y] == <span class="hljs-literal">false</span> &amp;&amp; board[new_x][new_y ] == word[count]&#123;                                dfs(count+<span class="hljs-number">1</span>, new_x,new_y)            &#125;        &#125;        visit[x][y] = <span class="hljs-literal">false</span>    &#125;        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(board); i++&#123;        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j&lt;<span class="hljs-built_in">len</span>(board[i]); j++&#123;            count := <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> board[i][j] == word[<span class="hljs-number">0</span>] &amp;&amp; !valid&#123;                                dfs(count, i, j)            &#125;                    &#125;     &#125;    <span class="hljs-keyword">return</span> valid&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：92 ms, 在所有 Go 提交中击败了59.42%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了91.92%的用户</p>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 029. 排序的循环链表</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20029.%20%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20029.%20%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="排序的循环链表"><a href="#排序的循环链表" class="headerlink" title="排序的循环链表"></a><font size=6px>排序的循环链表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。</p><p>给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。</p><p>如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。</p><p>如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。</p><p>示例 1：</p><p>输入：head &#x3D; [3,4,1], insertVal &#x3D; 2<br>输出：[3,4,1,2]<br>解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。</p><p>示例 2：</p><p>输入：head &#x3D; [], insertVal &#x3D; 1<br>输出：[1]<br>解释：列表为空（给定的节点是 null），创建一个循环有序列表并返回这个节点。<br>示例 3：</p><p>输入：head &#x3D; [1], insertVal &#x3D; 0<br>输出：[1,0]</p><p>提示：</p><p>0 &lt;&#x3D; Number of Nodes &lt;&#x3D; 5 * 10^4<br>-10^6 &lt;&#x3D; Node.val &lt;&#x3D; 10^6<br>-10^6 &lt;&#x3D; insertVal &lt;&#x3D; 10^6</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>先找到有序的头部，比如3 1 2，先找到有序的开头1，然后把这个作为头部，开始遍历找到插入点</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a Node.</span><span class="hljs-comment"> * type Node struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Next *Node</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">news</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span>*Node&#123;    node := Node&#123;&#125;    node.Val = x    node.Next = <span class="hljs-literal">nil</span>    <span class="hljs-keyword">return</span> &amp;node&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insert</span><span class="hljs-params">(aNode *Node, x <span class="hljs-type">int</span>)</span></span> *Node &#123;    node := news(x)    <span class="hljs-keyword">if</span> aNode == <span class="hljs-literal">nil</span>&#123;        node.Next = node        <span class="hljs-keyword">return</span> node    &#125;    <span class="hljs-keyword">if</span> aNode.Next == aNode&#123;        aNode.Next = node        node.Next = aNode        <span class="hljs-keyword">return</span> aNode    &#125;    head := aNode    tmp := aNode    <span class="hljs-keyword">for</span> aNode.Next != head&#123;        next := aNode.Next        <span class="hljs-keyword">if</span> next.Val &lt; aNode.Val&#123;            head = next            <span class="hljs-keyword">break</span>        &#125;        aNode = next    &#125;    bNode := head    flag := <span class="hljs-literal">false</span>    <span class="hljs-keyword">for</span> bNode.Next != head&#123;        next := bNode.Next        <span class="hljs-keyword">if</span> next.Val &gt;=x &amp;&amp; bNode.Val &lt;=x&#123;            bNode.Next = node            node.Next = next            flag = <span class="hljs-literal">true</span>            <span class="hljs-keyword">break</span>        &#125;        bNode = next    &#125;    <span class="hljs-keyword">if</span> !flag&#123;        bNode.Next = node        node.Next = head    &#125;    <span class="hljs-keyword">return</span> tmp&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.5 MB, 在所有 Go 提交中击败了98.29%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer II 091. 粉刷房子</title>
    <link href="/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20091.%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"/>
    <url>/2022/01/21/%E5%89%91%E6%8C%87offer/%E5%89%91%E6%8C%87%20Offer%20II%20091.%20%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="粉刷房子"><a href="#粉刷房子" class="headerlink" title="粉刷房子"></a><font size=6px>粉刷房子</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p><p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。</p><p>例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。</p><p>请计算出粉刷完所有房子最少的花费成本。</p><p>示例 1：</p><p>输入: costs &#x3D; [[17,2,17],[16,16,5],[14,3,19]]<br>输出: 10<br>解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。<br>     最少花费: 2 + 5 + 3 &#x3D; 10。<br>示例 2：</p><p>输入: costs &#x3D; [[7,6,2]]<br>输出: 2</p><p>提示:</p><p>costs.length &#x3D;&#x3D; n<br>costs[i].length &#x3D;&#x3D; 3<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>1 &lt;&#x3D; costs[i][j] &lt;&#x3D; 20</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用动态规划做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCost</span><span class="hljs-params">(costs [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(costs)    dp1,dp2,dp3 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(costs)),<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(costs)),<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(costs))    dp1[<span class="hljs-number">0</span>],dp2[<span class="hljs-number">0</span>], dp3[<span class="hljs-number">0</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],costs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>; i&lt;<span class="hljs-built_in">len</span>(costs); i++&#123;        dp1[i] = min(dp2[i<span class="hljs-number">-1</span>],dp3[i<span class="hljs-number">-1</span>]) + costs[i][<span class="hljs-number">0</span>]        dp2[i] = min(dp1[i<span class="hljs-number">-1</span>],dp3[i<span class="hljs-number">-1</span>]) + costs[i][<span class="hljs-number">1</span>]        dp3[i] = min(dp1[i<span class="hljs-number">-1</span>],dp2[i<span class="hljs-number">-1</span>]) + costs[i][<span class="hljs-number">2</span>]    &#125;    <span class="hljs-keyword">return</span> min(min(dp1[n<span class="hljs-number">-1</span>],dp2[n<span class="hljs-number">-1</span>]),dp3[n<span class="hljs-number">-1</span>])&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了84.92%的用户<br>   内存消耗：3 MB, 在所有 Go 提交中击败了56.98%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>181. 超过经理收入的员工</title>
    <link href="/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93/181.%20%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/"/>
    <url>/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93/181.%20%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="超过经理收入的员工"><a href="#超过经理收入的员工" class="headerlink" title="超过经理收入的员工"></a><font size=6px>超过经理收入的员工</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>表：Employee </p><p>+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| id          | int     |<br>| name        | varchar |<br>| salary      | int     |<br>| managerId   | int     |<br>+————-+———+<br>Id是该表的主键。<br>该表的每一行都表示雇员的ID、姓名、工资和经理的ID。</p><p>编写一个SQL查询来查找收入比经理高的员工。</p><p>以 任意顺序 返回结果表。</p><p>查询结果格式如下所示。</p><p>示例 1:</p><p>输入:<br>Employee 表:<br>+—-+——-+——–+———–+<br>| id | name  | salary | managerId |<br>+—-+——-+——–+———–+<br>| 1  | Joe   | 70000  | 3         |<br>| 2  | Henry | 80000  | 4         |<br>| 3  | Sam   | 60000  | Null      |<br>| 4  | Max   | 90000  | Null      |<br>+—-+——-+——–+———–+<br>输出:<br>+———-+<br>| Employee |<br>+———-+<br>| Joe      |<br>+———-+<br>解释: Joe 是唯一挣得比经理多的雇员。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>子查询做</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">select</span> a.name as Employee from Employee a where salary &gt; (<span class="hljs-keyword">select</span> b.salary from Employee b where id = a.managerId);</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：991 ms, 在所有 MySQL 提交中击败了5.06%的用户<br>   内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>175. 组合两个表</title>
    <link href="/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93/175.%20%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/"/>
    <url>/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93/175.%20%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="组合两个表"><a href="#组合两个表" class="headerlink" title="组合两个表"></a><font size=6px>组合两个表</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>表1: Person</p><p>+————-+———+<br>| 列名         | 类型     |<br>+————-+———+<br>| PersonId    | int     |<br>| FirstName   | varchar |<br>| LastName    | varchar |<br>+————-+———+<br>PersonId 是上表主键<br>表2: Address</p><p>+————-+———+<br>| 列名         | 类型    |<br>+————-+———+<br>| AddressId   | int     |<br>| PersonId    | int     |<br>| City        | varchar |<br>| State       | varchar |<br>+————-+———+<br>AddressId 是上表主键</p><p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p><p>FirstName, LastName, City, State</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">select</span> p.firstName, p.lastName, a.city, a.state from Person p left join Address a on p.PersonId = a.PersonId</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：426 ms, 在所有 MySQL 提交中击败了75.79%的用户<br>   内存消耗：0 B, 在所有 MySQL 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>头条笔试题</title>
    <link href="/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%A4%B4%E6%9D%A1%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/21/%E7%89%9B%E5%AE%A2%E7%BD%91/%E5%A4%B4%E6%9D%A1%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1、折木棍"><a href="#1、折木棍" class="headerlink" title="1、折木棍"></a><font size=6px>1、折木棍</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>在你的面前从左到右摆放着 nn 根长短不一的木棍，你每次可以折断一根木棍，并将折断后得到的两根木棍一左一右放在原来的位置（即若原木棍有左邻居，则两根新木棍必须放在左邻居的右边，若原木棍有右邻居，新木棍必须放在右邻居的左边，所有木棍保持左右排列）。折断后的两根木棍的长度必须为整数，且它们之和等于折断前的木棍长度。你希望最终从左到右的木棍长度单调不减，那么你需要折断多少次呢？</p><p>输入描述<br>第一行是一个数 nn，表示开始时有多少根木棍 (1&lt;&#x3D;n&lt;&#x3D;3000)(1&lt;&#x3D;n&lt;&#x3D;3000) 第二行有 nn 个数，从第 11 个到第 nn 个分别表示从左到右的木棍长度。对任意木棍的长度 ll，有 1&lt;&#x3D;l&lt;&#x3D;30001&lt;&#x3D;l&lt;&#x3D;3000。</p><p>输出描述<br>输出一行，一个数，你最少所需的折断木棍的次数 xx</p><p>示例</p><p>输入:<br>5<br>3 5 13 9 12</p><p>输出:<br>1<br>说明<br>你可以将长度为 1313 的木棍折成长度分别为 55 和 88 的两根木棍，最终得到的排列是 3 5 5 8 9 12</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>从后往前遍历，建立一个单调栈，如果遇到比top大的，就想办法折出均匀的几段，这是在要比后一个小前一个大的情况，并且把折的最小的一个放栈里面</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-type">int</span> breakNum(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;    stack&lt;<span class="hljs-type">int</span>&gt; st;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">if</span> (!st.empty() &amp;&amp; st.top() &lt; nums[i]) &#123;            <span class="hljs-type">int</span> t = (nums[i] - <span class="hljs-number">1</span>) / st.top();            ans += t;            st.push(nums[i] / (t + <span class="hljs-number">1</span>));            <span class="hljs-keyword">continue</span>;        &#125;        st.push(nums[i]);    &#125;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre><h3 id="2、打印出失序的线程ID"><a href="#2、打印出失序的线程ID" class="headerlink" title="2、打印出失序的线程ID"></a>2、打印出失序的线程ID</h3><blockquote><p><strong>题目描述</strong></p></blockquote><p>输入一个正整数n.表示接下来有n行数字，每行一个数字（不重复，可能无序），表示线程id,输出未出现的失序的线程ID</p><p>n的大小是小于等于2的32次方</p><blockquote><p><strong>示例</strong></p></blockquote><p><strong>例如1：</strong></p><pre><code class="hljs properties"><span class="hljs-attr">输入(输入的线程ID不一定有序)</span><span class="hljs-attr">5</span><span class="hljs-attr">2</span><span class="hljs-attr">3</span><span class="hljs-attr">4</span><span class="hljs-attr">5</span><span class="hljs-attr">6</span><span class="hljs-attr">输出：</span><span class="hljs-attr">1</span></code></pre><p><strong>例如2：</strong></p><pre><code class="hljs properties"><span class="hljs-attr">输入：</span><span class="hljs-attr">4</span><span class="hljs-attr">1</span><span class="hljs-attr">2</span><span class="hljs-attr">3</span><span class="hljs-attr">4</span><span class="hljs-attr">输出：</span><span class="hljs-attr">5</span></code></pre><p>思路：</p><p>输入数组中，排序一个，然后从前往后遍历，找出空缺的位置。</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1014. 最佳观光组合</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1014.%20%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1014.%20%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="最佳观光组合"><a href="#最佳观光组合" class="headerlink" title="最佳观光组合"></a><font size=6px>最佳观光组合</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。</p><p>一对景点（i &lt; j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><p>示例 1：</p><p>输入：values &#x3D; [8,1,5,2,6]<br>输出：11<br>解释：i &#x3D; 0, j &#x3D; 2, values[i] + values[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11<br>示例 2：</p><p>输入：values &#x3D; [1,2]<br>输出：2</p><p>提示：</p><p>2 &lt;&#x3D; values.length &lt;&#x3D; 5 * 104<br>1 &lt;&#x3D; values[i] &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>可以拆分成num[i] +i 和 num[j]-j，后面这个是不变的，前面这个是变的</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxScoreSightseeingPair</span><span class="hljs-params">(values []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(values)    ans,maxNum := <span class="hljs-number">0</span>,values[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        ans = max(ans, maxNum+values[i]-i)        maxNum = max(maxNum,values[i]+i)    &#125;    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：44 ms, 在所有 Go 提交中击败了42.68%的用户<br>   内存消耗：6.8 MB, 在所有 Go 提交中击败了91.46%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1000. 合并石头的最低成本</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1000.%20%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1000.%20%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="合并石头的最低成本"><a href="#合并石头的最低成本" class="headerlink" title="合并石头的最低成本"></a><font size=6px>合并石头的最低成本</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。</p><p>每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。</p><p>找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。</p><p>示例 1：</p><p>输入：stones &#x3D; [3,2,4,1], K &#x3D; 2<br>输出：20<br>解释：<br>从 [3, 2, 4, 1] 开始。<br>合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。<br>合并 [4, 1]，成本为 5，剩下 [5, 5]。<br>合并 [5, 5]，成本为 10，剩下 [10]。<br>总成本 20，这是可能的最小值。<br>示例 2：</p><p>输入：stones &#x3D; [3,2,4,1], K &#x3D; 3<br>输出：-1<br>解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.<br>示例 3：</p><p>输入：stones &#x3D; [3,5,1,2,6], K &#x3D; 3<br>输出：25<br>解释：<br>从 [3, 5, 1, 2, 6] 开始。<br>合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。<br>合并 [3, 8, 6]，成本为 17，剩下 [17]。<br>总成本 25，这是可能的最小值。</p><p>提示：</p><p>1 &lt;&#x3D; stones.length &lt;&#x3D; 30<br>2 &lt;&#x3D; K &lt;&#x3D; 30<br>1 &lt;&#x3D; stones[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><p>区间dp经典题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeStones</span><span class="hljs-params">(stones []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;n := <span class="hljs-built_in">len</span>(stones)<span class="hljs-keyword">if</span> (n<span class="hljs-number">-1</span>)%(k<span class="hljs-number">-1</span>) != <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123;dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)&#125;sum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;sum[i] = sum[i<span class="hljs-number">-1</span>] + stones[i<span class="hljs-number">-1</span>]&#125;<span class="hljs-keyword">for</span> l := k; l &lt;= n;l++ &#123; <span class="hljs-comment">// 枚举区间长度</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>;i+l<span class="hljs-number">-1</span> &lt;= n;i++ &#123; <span class="hljs-comment">// 枚举区间起点</span>j := i + l - <span class="hljs-number">1</span>dp[i][j] = math.MaxInt32<span class="hljs-keyword">for</span> p := i; p &lt; j;p += k - <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 枚举分界点</span><span class="hljs-keyword">if</span> dp[i][j]&gt; dp[i][p]+dp[p+<span class="hljs-number">1</span>][j]&#123;dp[i][j] = dp[i][p]+dp[p+<span class="hljs-number">1</span>][j]&#125;&#125;<span class="hljs-keyword">if</span> (j-i)%(k<span class="hljs-number">-1</span>) == <span class="hljs-number">0</span> &#123;dp[i][j] += sum[j] - sum[i<span class="hljs-number">-1</span>]&#125;&#125;&#125;<span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>][n]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了71.43%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1020. 飞地的数量</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1020.%20%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1020.%20%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="飞地的数量"><a href="#飞地的数量" class="headerlink" title="飞地的数量"></a><font size=6px>飞地的数量</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。</p><p>一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。</p><p>返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。</p><p>示例 1：</p><p>输入：grid &#x3D; [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]<br>输出：3<br>解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。<br>示例 2：</p><p>输入：grid &#x3D; [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]<br>输出：0<br>解释：所有 1 都在边界上或可以到达边界。</p><p>提示：</p><p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 500<br>grid[i][j] 的值为 0 或 1</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>Dfs 题，遍历周边的，然后遍历中间的数有几个岛屿</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numEnclaves</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> dirs = []<span class="hljs-keyword">struct</span>&#123; x, y <span class="hljs-type">int</span> &#125;&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    vis := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, m)    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> vis &#123;        vis[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>,<span class="hljs-type">bool</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r, c <span class="hljs-type">int</span> , flag <span class="hljs-type">bool</span>)</span></span> &#123;        <span class="hljs-keyword">if</span> r &lt; <span class="hljs-number">0</span> || r &gt;= m || c &lt; <span class="hljs-number">0</span> || c &gt;= n || grid[r][c] == <span class="hljs-number">0</span> || vis[r][c] &#123;            <span class="hljs-keyword">return</span>        &#125;        vis[r][c] = <span class="hljs-literal">true</span>        <span class="hljs-keyword">if</span> flag&#123;            count++        &#125;        <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;            dfs(r+d.x, c+d.y,flag)        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> grid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">1</span> &amp;&amp; vis[<span class="hljs-number">0</span>][i] == <span class="hljs-literal">false</span>&#123;            dfs(<span class="hljs-number">0</span>,i,<span class="hljs-literal">false</span>)        &#125;         <span class="hljs-keyword">if</span> grid[m<span class="hljs-number">-1</span>][i] == <span class="hljs-number">1</span> &amp;&amp; vis[m<span class="hljs-number">-1</span>][i] == <span class="hljs-literal">false</span>&#123;            dfs(m<span class="hljs-number">-1</span>,i,<span class="hljs-literal">false</span>)        &#125;    &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m<span class="hljs-number">-1</span>;i++&#123;        <span class="hljs-keyword">if</span> grid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; vis[i][<span class="hljs-number">0</span>] == <span class="hljs-literal">false</span>&#123;            dfs(i,<span class="hljs-number">0</span>,<span class="hljs-literal">false</span>)        &#125;         <span class="hljs-keyword">if</span> grid[i][n<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span> &amp;&amp; vis[i][n<span class="hljs-number">-1</span>] == <span class="hljs-literal">false</span>&#123;            dfs(i,n<span class="hljs-number">-1</span>,<span class="hljs-literal">false</span>)        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;m<span class="hljs-number">-1</span>;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;n<span class="hljs-number">-1</span>;j++&#123;            <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span> &amp;&amp; vis[i][j] == <span class="hljs-literal">false</span>&#123;                dfs(i,j,<span class="hljs-literal">true</span>)                            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：60 ms, 在所有 Go 提交中击败了35.64%的用户<br>   内存消耗：6.8 MB, 在所有 Go 提交中击败了75.25%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1022. 从根到叶的二进制数之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1022.%20%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1022.%20%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="从根到叶的二进制数之和"><a href="#从根到叶的二进制数之和" class="headerlink" title="从根到叶的二进制数之和"></a><font size=6px>从根到叶的二进制数之和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。</p><p>例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。<br>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p><p>返回这些数字之和。题目数据保证答案是一个 32 位 整数。</p><p>示例 1：</p><p>输入：root &#x3D; [1,0,1,0,1,0,1]<br>输出：22<br>解释：(100) + (101) + (110) + (111) &#x3D; 4 + 5 + 6 + 7 &#x3D; 22<br>示例 2：</p><p>输入：root &#x3D; [0]<br>输出：0</p><p>提示：</p><p>树中的节点数在 [1, 1000] 范围内<br>Node.val 仅为 0 或 1 </p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>只要递归求出二叉树叶子节点的值就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumRootToLeaf</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;    sum,res := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        sum = sum*<span class="hljs-number">2</span>+root.Val        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span>&#123;            dfs(root.Left)        &#125;        <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span>&#123;            dfs(root.Right)        &#125;        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span>&#123;                      res += sum        &#125;        sum /=<span class="hljs-number">2</span>            &#125;    dfs(root)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.9 MB, 在所有 Go 提交中击败了80.30%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1037. 有效的回旋镖</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1037.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%97%8B%E9%95%96/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1037.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%97%8B%E9%95%96/</url>
    
    <content type="html"><![CDATA[<h3 id="有效的回旋镖"><a href="#有效的回旋镖" class="headerlink" title="有效的回旋镖"></a><font size=6px>有效的回旋镖</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个数组 points ，其中 points[i] &#x3D; [xi, yi] 表示 X-Y 平面上的一个点，如果这些点构成一个 回旋镖 则返回 true 。</p><p>回旋镖 定义为一组三个点，这些点 各不相同 且 不在一条直线上 。</p><p>示例 1：</p><p>输入：points &#x3D; [[1,1],[2,3],[3,2]]<br>输出：true<br>示例 2：</p><p>输入：points &#x3D; [[1,1],[2,2],[3,3]]<br>输出：false</p><p>提示：</p><p>points.length &#x3D;&#x3D; 3<br>points[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; xi, yi &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>简单题，把情况判断清楚就好，好久没双百了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBoomerang</span><span class="hljs-params">(points [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">if</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &amp;&amp; points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] == points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &amp;&amp; points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&amp;&amp;points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] == points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]&amp;&amp;points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]&amp;&amp;points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] == points[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">var</span> a,b <span class="hljs-type">float64</span>    a = <span class="hljs-type">float64</span>(points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]-points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])/<span class="hljs-type">float64</span>(points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])    b = <span class="hljs-type">float64</span>(points[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]-points[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])/<span class="hljs-type">float64</span>(points[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]-points[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])    <span class="hljs-keyword">if</span> a == b&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>538. Convert BST to Greater Tree</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1038.%20Convert%20BST%20to%20Greater%20Tree/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1038.%20Convert%20BST%20to%20Greater%20Tree/</url>
    
    <content type="html"><![CDATA[<h3 id="Convert-BST-to-Greater-Tree"><a href="#Convert-BST-to-Greater-Tree" class="headerlink" title="Convert BST to Greater Tree"></a><font size=6px>Convert BST to Greater Tree</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p><p>As a reminder, a binary search tree is a tree that satisfies these constraints:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p><p>Example 1:</p><p>Input: root &#x3D; [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]<br>Example 2:</p><p>Input: root &#x3D; [0,null,1]<br>Output: [1,null,1]</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [0, 104].<br>-104 &lt;&#x3D; Node.val &lt;&#x3D; 104<br>All the values in the tree are unique.<br>root is guaranteed to be a valid binary search tree.</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>dfs 搜索，右中左序列就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertBST</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    <span class="hljs-keyword">var</span> maxNum <span class="hljs-type">int</span>     dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        dfs(root.Right)        root.Val += maxNum        maxNum = root.Val        dfs(root.Left)            &#125;dfs(root)<span class="hljs-keyword">return</span> root&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1051. 高度检查器</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1051.%20%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1051.%20%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="高度检查器"><a href="#高度检查器" class="headerlink" title="高度检查器"></a><font size=6px>高度检查器</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 非递减 的高度顺序排成一行。</p><p>排序后的高度情况用整数数组 expected 表示，其中 expected[i] 是预计排在这一行中第 i 位的学生的高度（下标从 0 开始）。</p><p>给你一个整数数组 heights ，表示 当前学生站位 的高度情况。heights[i] 是这一行中第 i 位学生的高度（下标从 0 开始）。</p><p>返回满足 heights[i] !&#x3D; expected[i] 的 下标数量 。</p><p>示例：</p><p>输入：heights &#x3D; [1,1,4,2,1,3]<br>输出：3<br>解释：<br>高度：[1,1,4,2,1,3]<br>预期：[1,1,1,2,3,4]<br>下标 2 、4 、5 处的学生高度不匹配。<br>示例 2：</p><p>输入：heights &#x3D; [5,1,2,3,4]<br>输出：5<br>解释：<br>高度：[5,1,2,3,4]<br>预期：[1,2,3,4,5]<br>所有下标的对应学生高度都不匹配。<br>示例 3：</p><p>输入：heights &#x3D; [1,2,3,4,5]<br>输出：0<br>解释：<br>高度：[1,2,3,4,5]<br>预期：[1,2,3,4,5]<br>所有下标的对应学生高度都匹配。</p><p>提示：</p><p>1 &lt;&#x3D; heights.length &lt;&#x3D; 100<br>1 &lt;&#x3D; heights[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><p>排序后求</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heightChecker</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    height2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    res := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> heights&#123;        height2 = <span class="hljs-built_in">append</span>(height2, v)    &#125;    sort.Ints(height2)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(height2); i++&#123;        <span class="hljs-keyword">if</span> height2[i] != heights[i]&#123;            res ++        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了5.75%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><font size=6px>从前序与中序遍历序列构造二叉树</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p>示例 1:</p><p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p><p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1]</p><p>提示:</p><p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>用递归写最容易，前序的第一个节点是根结点，找到前序第一个节点在中序中第几个，中序左边的左子树，右边是右子树</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    &#125;    root := &amp;TreeNode&#123;preorder[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;    i:=<span class="hljs-number">0</span>     <span class="hljs-keyword">for</span> ;i&lt;<span class="hljs-built_in">len</span>(inorder); i++&#123;        <span class="hljs-keyword">if</span> inorder[i] == preorder[<span class="hljs-number">0</span>]&#123;            <span class="hljs-keyword">break</span>        &#125;    &#125;    root.Left = buildTree(preorder[<span class="hljs-number">1</span>:i+<span class="hljs-number">1</span>], inorder[:i])    root.Right = buildTree(preorder[i+<span class="hljs-number">1</span>:], inorder[i+<span class="hljs-number">1</span>:])    <span class="hljs-keyword">return</span> root&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了94.86%的用户<br>   内存消耗：4 MB, 在所有 Go 提交中击败了96.69%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1089. 复写零</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1089.%20%E5%A4%8D%E5%86%99%E9%9B%B6/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1089.%20%E5%A4%8D%E5%86%99%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="复写零"><a href="#复写零" class="headerlink" title="复写零"></a><font size=6px>复写零</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。</p><p>注意：请不要在超过该数组长度的位置写入元素。</p><p>要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。</p><p>示例 1：</p><p>输入：[1,0,2,3,0,4,5,0]<br>输出：null<br>解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]<br>示例 2：</p><p>输入：[1,2,3]<br>输出：null<br>解释：调用函数后，输入的数组将被修改为：[1,2,3]</p><p>提示：</p><p>1 &lt;&#x3D; arr.length &lt;&#x3D; 10000<br>0 &lt;&#x3D; arr[i] &lt;&#x3D; 9</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>额外开辟n的空间来存储中间结果然后覆盖</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">duplicateZeros</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span>  &#123;    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(arr))    n := <span class="hljs-built_in">len</span>(arr)    <span class="hljs-keyword">var</span> i,j <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span>  ;i&lt;n;&#123;        <span class="hljs-keyword">if</span> arr[j] != <span class="hljs-number">0</span>&#123;            res[i] = arr[j]            j++            i++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i&lt;n<span class="hljs-number">-1</span>&#123;            res[i],res[i+<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>            i += <span class="hljs-number">2</span>            j++        &#125;<span class="hljs-keyword">else</span>&#123;            i++        &#125;    &#125;    <span class="hljs-keyword">for</span> k,v :=<span class="hljs-keyword">range</span> res&#123;        arr[k] = v    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3.3 MB, 在所有 Go 提交中击败了14.81%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1021. 删除最外层的括号</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1021.%20%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1021.%20%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="删除最外层的括号"><a href="#删除最外层的括号" class="headerlink" title="删除最外层的括号"></a><font size=6px>删除最外层的括号</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有效括号字符串为空 “”、”(“ + A + “)” 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。</p><p>例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。<br>如果有效字符串 s 非空，且不存在将其拆分为 s &#x3D; A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p><p>给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s &#x3D; P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p><p>对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。</p><p>示例 1：</p><p>输入：s &#x3D; “(()())(())”<br>输出：”()()()”<br>解释：<br>输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，<br>删除每个部分中的最外层括号后得到 “()()” + “()” &#x3D; “()()()”。<br>示例 2：</p><p>输入：s &#x3D; “(()())(())(()(()))”<br>输出：”()()()()(())”<br>解释：<br>输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，<br>删除每个部分中的最外层括号后得到 “()()” + “()” + “()(())” &#x3D; “()()()()(())”。<br>示例 3：</p><p>输入：s &#x3D; “()()”<br>输出：””<br>解释：<br>输入字符串为 “()()”，原语化分解得到 “()” + “()”，<br>删除每个部分中的最外层括号后得到 “” + “” &#x3D; “”。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>用栈做，每次栈空就找到一个原语了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeOuterParentheses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>    &#125;    <span class="hljs-keyword">var</span> res <span class="hljs-type">string</span>    <span class="hljs-keyword">var</span> stack []<span class="hljs-type">byte</span>    stack = <span class="hljs-built_in">append</span>(stack, s[<span class="hljs-number">0</span>])    tmp := <span class="hljs-type">string</span>(stack[<span class="hljs-number">0</span>])    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++&#123;          tmp += <span class="hljs-type">string</span>(s[i])        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span>&#123;            stack = <span class="hljs-built_in">append</span>(stack, s[i])                      <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-keyword">if</span> s[i]==<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>&#123;                        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]                    &#125;<span class="hljs-keyword">else</span>&#123;            stack = <span class="hljs-built_in">append</span>(stack, s[i])        &#125;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span>&#123;            res += tmp[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]            tmp = <span class="hljs-string">&quot;&quot;</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了48.68%的用户<br>   内存消耗：6.5 MB, 在所有 Go 提交中击败了43.42%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1108. IP 地址无效化</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="IP-地址无效化"><a href="#IP-地址无效化" class="headerlink" title="IP 地址无效化"></a><font size=6px>IP 地址无效化</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。</p><p>所谓无效化 IP 地址，其实就是用 “[.]” 代替了每个 “.”。</p><p>示例 1：</p><p>输入：address &#x3D; “1.1.1.1”<br>输出：”1[.]1[.]1[.]1”<br>示例 2：</p><p>输入：address &#x3D; “255.100.50.0”<br>输出：”255[.]100[.]50[.]0”</p><p>提示：</p><p>给出的 address 是一个有效的 IPv4 地址</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>模拟</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defangIPaddr</span><span class="hljs-params">(address <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> address&#123;        <span class="hljs-keyword">if</span> v == <span class="hljs-string">&#x27;.&#x27;</span>&#123;            res += <span class="hljs-string">&quot;[.]&quot;</span>        &#125;<span class="hljs-keyword">else</span>&#123;            res += <span class="hljs-type">string</span>(v)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了86.23%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>112. 路径总和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><font size=6px>路径总和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。<br>示例 2：</p><p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：false<br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 –&gt; 2): 和为 3<br>(1 –&gt; 3): 和为 4<br>不存在 sum &#x3D; 5 的根节点到叶子节点的路径。<br>示例 3：</p><p>输入：root &#x3D; [], targetSum &#x3D; 0<br>输出：false<br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。</p><p>提示：</p><p>树中节点的数目在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>Dfs 遍历搜查</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;    <span class="hljs-keyword">var</span> flag  <span class="hljs-type">bool</span>     flag = <span class="hljs-literal">false</span>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> flag    &#125;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sum <span class="hljs-type">int</span>,root *TreeNode)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(sum <span class="hljs-type">int</span>,root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span>&#123;            dfs(sum+root.Val, root.Left)        &#125;        <span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span>&#123;            dfs(sum+root.Val, root.Right)        &#125;        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">if</span> sum+root.Val == targetSum&#123;                flag = <span class="hljs-literal">true</span>            &#125;        &#125;    &#125;    dfs(<span class="hljs-number">0</span>, root)    <span class="hljs-keyword">return</span> flag&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了91.38%的用户<br>   内存消耗：4.4 MB, 在所有 Go 提交中击败了96.55%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>114. Flatten Binary Tree to Linked List</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/114.%20Flatten%20Binary%20Tree%20to%20Linked%20List/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/114.%20Flatten%20Binary%20Tree%20to%20Linked%20List/</url>
    
    <content type="html"><![CDATA[<h3 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a><font size=6px>Flatten Binary Tree to Linked List</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given the root of a binary tree, flatten the tree into a “linked list”:</p><p>The “linked list” should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.<br>The “linked list” should be in the same order as a pre-order traversal of the binary tree.</p><p>Example 1:</p><p>Input: root &#x3D; [1,2,5,3,4,null,6]<br>Output: [1,null,2,null,3,null,4,null,5,null,6]<br>Example 2:</p><p>Input: root &#x3D; []<br>Output: []<br>Example 3:</p><p>Input: root &#x3D; [0]<br>Output: [0]</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [0, 2000].<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p>Follow up: Can you flatten the tree in-place (with O(1) extra space)?</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;    curr := root    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">if</span> curr.Left != <span class="hljs-literal">nil</span> &#123;            next := curr.Left            predecessor := next            <span class="hljs-keyword">for</span> predecessor.Right != <span class="hljs-literal">nil</span> &#123;                predecessor = predecessor.Right            &#125;            predecessor.Right = curr.Right            curr.Left, curr.Right = <span class="hljs-literal">nil</span>, next        &#125;        curr = curr.Right    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.8 MB, 在所有 Go 提交中击败了98.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>113. 路径总和 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a><font size=6px>路径总和 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p><p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1,2], targetSum &#x3D; 0<br>输出：[]</p><p>提示：</p><p>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>dfs遍历到根节点就判断是否等于target</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode,tmp []<span class="hljs-type">int</span>,sum <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode,tmp []<span class="hljs-type">int</span>,sum <span class="hljs-type">int</span>)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>        &#125;        tmp = <span class="hljs-built_in">append</span>(tmp,root.Val)        sum += root.Val        dfs(root.Left,tmp,sum)        dfs(root.Right,tmp,sum)         <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">if</span> sum == targetSum&#123;                tmp2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(tmp))                <span class="hljs-built_in">copy</span>(tmp2,tmp)                res = <span class="hljs-built_in">append</span>(res,tmp2)            &#125;        &#125;    &#125;    dfs(root,[]<span class="hljs-type">int</span>&#123;&#125;,<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了85.39%的用户<br>   内存消耗：4.4 MB, 在所有 Go 提交中击败了44.71%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1143. 最长公共子序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1143.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><font size=6px>最长公共子序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p>示例 1：</p><p>输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。<br>示例 2：</p><p>输入：text1 &#x3D; “abc”, text2 &#x3D; “abc”<br>输出：3<br>解释：最长公共子序列是 “abc” ，它的长度为 3 。<br>示例 3：</p><p>输入：text1 &#x3D; “abc”, text2 &#x3D; “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0 。</p><p>提示：</p><p>1 &lt;&#x3D; text1.length, text2.length &lt;&#x3D; 1000<br>text1 和 text2 仅由小写英文字符组成。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span></code></pre><p>dp</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(text1),<span class="hljs-built_in">len</span>(text2)    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,m+<span class="hljs-number">1</span>)    dp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=m;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=n;j++&#123;            <span class="hljs-keyword">if</span> text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>]&#123;                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>            &#125;<span class="hljs-keyword">else</span>&#123;                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])            &#125;                    &#125;    &#125;    <span class="hljs-keyword">return</span> dp[m][n]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了76.63%的用户<br>   内存消耗：10.5 MB, 在所有 Go 提交中击败了90.96%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分模块刷力扣题</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/0%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E5%8A%9B%E6%89%A3%E9%A2%98/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/0%E5%88%86%E6%A8%A1%E5%9D%97%E5%88%B7%E5%8A%9B%E6%89%A3%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><style>table th:first-of-type {    width: 20%;}table th:nth-of-type(2) {    width: 50%;}table th:nth-of-type(3) {    width: 20%;} table th:nth-of-type(4) {    width: 30%;}</style><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">题目</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">两数之和</td><td align="center">c</td><td align="center">Easy</td></tr><tr><td align="center">11</td><td align="center">乘最多的水</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">15.三数之和</td><td align="center">学会了双指针法</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">16</td><td align="center">最接近的三数之和</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">33. 搜索旋转排序数组</td><td align="center">学会半有序的二分查找</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">41</td><td align="center">缺失一个正数</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">42</td><td align="center">接雨水</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">46. 全排列</td><td align="center">学会dfs</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">48</td><td align="center">旋转图像</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">56. 合并区间</td><td align="center">学会简便排序二维数组</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">81. 搜索旋转排序数组 II</td><td align="center">和33题差不多</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">84. 柱状图中最大的矩形</td><td align="center">学会哨兵和单调栈</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">121</td><td align="center">买卖股票的最佳时机</td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">122</td><td align="center">买卖股票的最佳时机||</td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">123</td><td align="center">买卖股票的最佳时机|||</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">128. 最长连续序列</td><td align="center">学会遍历map</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">215. 数组中的第K个最大元素</td><td align="center">学会了堆排序</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">300. 最长递增子序列</td><td align="center">学会了用动态规划求最大子序列</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">393. UTF-8 编码验证</td><td align="center">学会了位运算</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">547. 省份数量</td><td align="center">学会并查集合并</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">674. 最长连续递增序列</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">695. 岛屿的最大面积</td><td align="center">锻炼了dfs</td><td align="center">go</td><td align="center">medium</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">3无重复字符的最长子串</td><td align="center"></td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">13罗马数字转整数</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">43. 字符串相乘</td><td align="center">学会大数乘法</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">71. 简化路径</td><td align="center">学会了split函数和怎么删除切片指定字符串</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">20</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">22</td><td align="center"></td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">14. 最长公共前缀</td><td align="center"></td><td align="center">go</td><td align="center">Easy</td></tr><tr><td align="center">567. 字符串的排列</td><td align="center">复习了移动窗口法</td><td align="center">go</td><td align="center">Medium</td></tr></tbody></table><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">53. 最大子序和</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">85. 最大矩形</td><td align="center">学会单调栈和哨兵的另外一种应用</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center">120. 三角形最小路径和</td><td align="center">数塔问题</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">1416 恢复数组</td><td align="center">锻炼了递推思路</td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center">354. 俄罗斯套娃信封问题</td><td align="center">学会自定义快排和求最大升序序列</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">21. 合并两个有序链表</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">23. 合并K个升序链表</td><td align="center"></td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center">25. K 个一组翻转链表</td><td align="center">指针逆置，后面复习，再写一次</td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center">141. 环形链表</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">143. 重排链表</td><td align="center">锻炼了插入链表的顺序，学会了归并排序排序链表</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">160. 相交链表</td><td align="center">学会map的使用</td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">206. 反转链表</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">234. 回文链表</td><td align="center">知道什么原地让指针逆置</td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">236. 二叉树的最近公共祖先</td><td align="center">学会递归找公共祖先结点</td><td align="center">go</td><td align="center">medium</td></tr></tbody></table><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">102. 二叉树的层序遍历</td><td align="center">学会用队列遍历二叉树</td><td align="center">go</td><td align="center">medium</td></tr><tr><td align="center">103. 二叉树的锯齿形层序遍历</td><td align="center">学会把二叉树放进切片里面</td><td align="center">goeasy</td><td align="center">medium</td></tr><tr><td align="center">110. 平衡二叉树</td><td align="center">学会怎么判断平衡二叉树</td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">55. 最小栈</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">146. LRU 缓存机制</td><td align="center">学会了LRU算法，用链表哈希数据结构</td><td align="center">go</td><td align="center">Medium</td></tr><tr><td align="center">432. 全 O(1) 的数据结构</td><td align="center">学会哈希双向链表的使用</td><td align="center">go</td><td align="center">Hard</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><div style="font-size:20px"><table><thead><tr><th align="center">题号</th><th align="center">收获</th><th align="center">语言</th><th align="center">难易程度</th></tr></thead><tbody><tr><td align="center">55. 最小栈</td><td align="center"></td><td align="center">go</td><td align="center">easy</td></tr><tr><td align="center">60. 排列序列</td><td align="center">学会怎么快速知道在全排列中第几个数</td><td align="center">go</td><td align="center">hard</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>118. 杨辉三角</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    
    <content type="html"><![CDATA[<h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a><font size=6px>杨辉三角</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p>示例 1:</p><p>输入: numRows &#x3D; 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br>示例 2:</p><p>输入: numRows &#x3D; 1<br>输出: [[1]]</p><p>提示:</p><p>1 &lt;&#x3D; numRows &lt;&#x3D; 30</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generate</span><span class="hljs-params">(numRows <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    ans := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, numRows)    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ans &#123;        ans[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, i+<span class="hljs-number">1</span>)        ans[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>        ans[i][i] = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; i; j++ &#123;            ans[i][j] = ans[i<span class="hljs-number">-1</span>][j] + ans[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]        &#125;    &#125;    <span class="hljs-keyword">return</span> ans&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了55.44%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1175. 质数排列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1175.%20%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1175.%20%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="质数排列"><a href="#质数排列" class="headerlink" title="质数排列"></a><font size=6px>质数排列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。</p><p>让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。</p><p>由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。</p><p>示例 1：</p><p>输入：n &#x3D; 5<br>输出：12<br>解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。<br>示例 2：</p><p>输入：n &#x3D; 100<br>输出：682289015</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>数学题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numPrimeArrangements</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> primeSum <span class="hljs-type">int</span>    res := <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++&#123;        <span class="hljs-keyword">if</span> isprime(i)&#123;            primeSum++        &#125;    &#125;     <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=primeSum;i++&#123;        res *= i        res %= <span class="hljs-number">1000000007</span>    &#125;        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=(n-primeSum);i++&#123;        res *= i        res %= <span class="hljs-number">1000000007</span>    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isprime</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span><span class="hljs-type">bool</span>&#123;    <span class="hljs-keyword">if</span> a == <span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span> a == <span class="hljs-number">2</span>|| a == <span class="hljs-number">3</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span>;i&lt;=a/<span class="hljs-number">2</span>;i++&#123;        <span class="hljs-keyword">if</span> a %i == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了8.70%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1184. 公交站间的距离</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1184.%20%E5%85%AC%E4%BA%A4%E7%AB%99%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1184.%20%E5%85%AC%E4%BA%A4%E7%AB%99%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="公交站间的距离"><a href="#公交站间的距离" class="headerlink" title="公交站间的距离"></a><font size=6px>公交站间的距离</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。</p><p>环线上的公交车都可以按顺时针和逆时针的方向行驶。</p><p>返回乘客从出发点 start 到目的地 destination 之间的最短距离。</p><p>示例 1：</p><p>输入：distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 1<br>输出：1<br>解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。</p><p>示例 2：</p><p>输入：distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 2<br>输出：3<br>解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。</p><p>示例 3：</p><p>输入：distance &#x3D; [1,2,3,4], start &#x3D; 0, destination &#x3D; 3<br>输出：4<br>解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 10^4<br>distance.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; start, destination &lt; n<br>0 &lt;&#x3D; distance[i] &lt;&#x3D; 10^4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>比较两条路哪条比较近</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">distanceBetweenBusStops</span><span class="hljs-params">(distance []<span class="hljs-type">int</span>, start <span class="hljs-type">int</span>, destination <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(distance)    <span class="hljs-keyword">var</span> a,b <span class="hljs-type">int</span>    <span class="hljs-keyword">if</span> start &gt;destination&#123;        start,destination = destination,start    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> i&gt;=start &amp;&amp; i &lt; destination&#123;            a+= distance[i]        &#125;<span class="hljs-keyword">else</span>&#123;            b += distance[i]        &#125;    &#125;    <span class="hljs-keyword">return</span> min(a,b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.6 MB, 在所有 Go 提交中击败了65.22%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1186. 删除一次得到子数组最大和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1186.%20%E5%88%A0%E9%99%A4%E4%B8%80%E6%AC%A1%E5%BE%97%E5%88%B0%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1186.%20%E5%88%A0%E9%99%A4%E4%B8%80%E6%AC%A1%E5%BE%97%E5%88%B0%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="删除一次得到子数组最大和"><a href="#删除一次得到子数组最大和" class="headerlink" title="删除一次得到子数组最大和"></a><font size=6px>删除一次得到子数组最大和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</p><p>注意，删除一个元素后，子数组 不能为空。</p><p>示例 1：</p><p>输入：arr &#x3D; [1,-2,0,3]<br>输出：4<br>解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。<br>示例 2：</p><p>输入：arr &#x3D; [1,-2,-2,3]<br>输出：3<br>解释：我们直接选出 [3]，这就是最大和。<br>示例 3：</p><p>输入：arr &#x3D; [-1,-1,-1,-1]<br>输出：-1<br>解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。<br>     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。</p><p>提示：</p><p>1 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; arr[i] &lt;&#x3D; 104</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>动态规划题，dp[1][i] &#x3D; max(dp[0][i - 1], dp[1][i - 1] + arr[i])是关键</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumSum</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(arr)    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span> , <span class="hljs-number">2</span>)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    &#125;    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>]    res := arr[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;        dp[<span class="hljs-number">0</span>][i] = max(dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + arr[i], arr[i])        dp[<span class="hljs-number">1</span>][i] = max(dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + arr[i])        res = max(res, max(dp[<span class="hljs-number">0</span>][i], dp[<span class="hljs-number">1</span>][i]))    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a &gt; b &#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：28 ms, 在所有 Go 提交中击败了85.71%的用户<br>   内存消耗：9.4 MB, 在所有 Go 提交中击败了32.14%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1189. “气球” 的最大数量</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1189.%20%E2%80%9C%E6%B0%94%E7%90%83%E2%80%9D%20%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1189.%20%E2%80%9C%E6%B0%94%E7%90%83%E2%80%9D%20%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Maximum-Number-of-Balloons"><a href="#Maximum-Number-of-Balloons" class="headerlink" title="Maximum Number of Balloons"></a><font size=6px>Maximum Number of Balloons</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>Given a string text, you want to use the characters of text to form as many instances of the word “balloon” as possible.</p><p>You can use each character in text at most once. Return the maximum number of instances that can be formed.</p><p>Example 1:</p><p>Input: text &#x3D; “nlaebolko”<br>Output: 1<br>Example 2:</p><p>Input: text &#x3D; “loonbalxballpoon”<br>Output: 2<br>Example 3:</p><p>Input: text &#x3D; “leetcode”<br>Output: 0</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找这些词的频率，找到最短板的单词即可</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxNumberOfBalloons</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)    <span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span> ;i&lt;<span class="hljs-built_in">len</span>(text); i++&#123;        <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;b&#x27;</span>&#123;            s[<span class="hljs-number">0</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;a&#x27;</span>&#123;            s[<span class="hljs-number">1</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;l&#x27;</span>&#123;            s[<span class="hljs-number">2</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;o&#x27;</span>&#123;            s[<span class="hljs-number">3</span>]++        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;n&#x27;</span>&#123;            s[<span class="hljs-number">4</span>]++        &#125;    &#125;     s[<span class="hljs-number">2</span>] /= <span class="hljs-number">2</span>    s[<span class="hljs-number">3</span>] /= <span class="hljs-number">2</span>    sort.Ints(s)    <span class="hljs-keyword">return</span> s[<span class="hljs-number">0</span>]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1191. K 次串联后最大子数组之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1191.%20K%20%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1191.%20K%20%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="K-次串联后最大子数组之和"><a href="#K-次串联后最大子数组之和" class="headerlink" title="K 次串联后最大子数组之和"></a><font size=6px>K 次串联后最大子数组之和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 arr 和一个整数 k。</p><p>首先，我们要对该数组进行修改，即把原数组 arr 重复 k 次。</p><p>举个例子，如果 arr &#x3D; [1, 2] 且 k &#x3D; 3，那么修改后的数组就是 [1, 2, 1, 2, 1, 2]。</p><p>然后，请你返回修改后的数组中的最大的子数组之和。</p><p>注意，子数组长度可以是 0，在这种情况下它的总和也是 0。</p><p>由于 结果可能会很大，所以需要 模（mod） 10^9 + 7 后再返回。 </p><p>示例 1：</p><p>输入：arr &#x3D; [1,2], k &#x3D; 3<br>输出：9<br>示例 2：</p><p>输入：arr &#x3D; [1,-2,1], k &#x3D; 5<br>输出：2<br>示例 3：</p><p>输入：arr &#x3D; [-1,-2], k &#x3D; 7<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5<br>1 &lt;&#x3D; k &lt;&#x3D; 10^5<br>-10^4 &lt;&#x3D; arr[i] &lt;&#x3D; 10^4</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>需要考虑三种情况，k&#x3D;1,k&#x3D;2,k&gt;2,k&#x3D;1就是最大子序列问题，k&#x3D;2是两个连续最大子序列问题，k&gt;2是max(ans2,(ans2+(k-2) * sum) ) ，ans2是k&#x3D;2时最大连续子序列的大小。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kConcatenationMaxSum</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> r ,ans, ans2 <span class="hljs-type">int</span>    base := <span class="hljs-number">1000000007</span>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(arr);i++&#123;        r = max(r+arr[i], arr[i])        ans = max(r, ans)        sum += arr[i]    &#125;    <span class="hljs-keyword">if</span> k==<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">return</span> ans %base    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(arr); i++&#123;        r= max(r+arr[i], arr[i])        ans2 = max(r, ans2)    &#125;    <span class="hljs-keyword">if</span> k ==<span class="hljs-number">2</span>&#123;        <span class="hljs-keyword">return</span> ans2 % base    &#125;    <span class="hljs-keyword">return</span> max(ans2,(ans2+(k<span class="hljs-number">-2</span>) * sum) % base) % base&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a&gt;b &#123;        <span class="hljs-keyword">return</span> a    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> b    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：52 ms, 在所有 Go 提交中击败了85.71%的用户<br>   内存消耗：8.3 MB, 在所有 Go 提交中击败了50.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1200. 最小绝对差</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1200.%20%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1200.%20%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="最小绝对差"><a href="#最小绝对差" class="headerlink" title="最小绝对差"></a><font size=6px>最小绝对差</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你个整数数组 arr，其中每个元素都 不相同。</p><p>请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。</p><p>示例 1：</p><p>输入：arr &#x3D; [4,2,1,3]<br>输出：[[1,2],[2,3],[3,4]]<br>示例 2：</p><p>输入：arr &#x3D; [1,3,6,10,15]<br>输出：[[1,3]]<br>示例 3：</p><p>输入：arr &#x3D; [3,8,-10,23,19,-4,-14,27]<br>输出：[[-14,-10],[19,23],[23,27]]</p><p>提示：</p><p>2 &lt;&#x3D; arr.length &lt;&#x3D; 10^5<br>-10^6 &lt;&#x3D; arr[i] &lt;&#x3D; 10^6</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlogn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>排序后两个数字间比较</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumAbsDifference</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    n := <span class="hljs-built_in">len</span>(arr)    sort.Ints(arr)    minNum := <span class="hljs-number">9999999</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> arr[i]-arr[i<span class="hljs-number">-1</span>]&lt;minNum&#123;            minNum = arr[i]-arr[i<span class="hljs-number">-1</span>]            res = [][]<span class="hljs-type">int</span>&#123;&#125;            res = <span class="hljs-built_in">append</span>(res,[]<span class="hljs-type">int</span>&#123;arr[i<span class="hljs-number">-1</span>],arr[i]&#125;)        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> arr[i]-arr[i<span class="hljs-number">-1</span>] == minNum&#123;            res = <span class="hljs-built_in">append</span>(res,[]<span class="hljs-type">int</span>&#123;arr[i<span class="hljs-number">-1</span>],arr[i]&#125;)        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：60 ms, 在所有 Go 提交中击败了94.52%的用户<br>   内存消耗：8.1 MB, 在所有 Go 提交中击败了82.19%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>115. 不同的子序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/115.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/115.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a><font size=6px>不同的子序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p>示例 1：</p><p>输入：s &#x3D; “rabbbit”, t &#x3D; “rabbit”<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 “rabbit” 的方案。<br>rabbbit<br>rabbbit<br>rabbbit<br>示例 2：</p><p>输入：s &#x3D; “babgbag”, t &#x3D; “bag”<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 “bag” 的方案。<br>babgbag<br>babgbag<br>babgbag<br>babgbag<br>babgbag</p><p>提示：</p><p>0 &lt;&#x3D; s.length, t.length &lt;&#x3D; 1000<br>s 和 t 由英文字母组成</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">m</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span></code></pre><p>使用dp做，有两个字符串使用二维dp，如果相同dp[i] [j] &#x3D; dp[i-1] [j-1]+dp[i-1] [j]</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(s),<span class="hljs-built_in">len</span>(t)    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=m;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>; j&lt;=n ; j++&#123;            <span class="hljs-keyword">if</span> s[i<span class="hljs-number">-1</span>] == t[j<span class="hljs-number">-1</span>]&#123;                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-1</span>][j]            &#125;<span class="hljs-keyword">else</span> &#123;                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]            &#125;        &#125;    &#125;    <span class="hljs-comment">//fmt.Println(dp)</span>    <span class="hljs-keyword">return</span> dp[m][n]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了84.24%的用户<br>   内存消耗：14.3 MB, 在所有 Go 提交中击败了63.42%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>119. 杨辉三角 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="杨辉三角-II"><a href="#杨辉三角-II" class="headerlink" title="杨辉三角 II"></a><font size=6px>杨辉三角 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p>示例 1:</p><p>输入: rowIndex &#x3D; 3<br>输出: [1,3,3,1]<br>示例 2:</p><p>输入: rowIndex &#x3D; 0<br>输出: [1]<br>示例 3:</p><p>输入: rowIndex &#x3D; 1<br>输出: [1,1]</p><p>提示:</p><p>0 &lt;&#x3D; rowIndex &lt;&#x3D; 33</p><p>进阶：</p><p>你可以优化你的算法到 O(rowIndex) 空间复杂度吗？</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRow</span><span class="hljs-params">(rowIndex <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    C := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, rowIndex+<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> C &#123;        C[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, i+<span class="hljs-number">1</span>)        C[i][<span class="hljs-number">0</span>], C[i][i] = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; i; j++ &#123;            C[i][j] = C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + C[i<span class="hljs-number">-1</span>][j]        &#125;    &#125;    <span class="hljs-keyword">return</span> C[rowIndex]&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1219. 黄金矿工</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1219.%20%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1219.%20%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="黄金矿工"><a href="#黄金矿工" class="headerlink" title="黄金矿工"></a><font size=6px>黄金矿工</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。</p><p>为了使收益最大化，矿工需要按以下规则来开采黄金：</p><p>每当矿工进入一个单元，就会收集该单元格中的所有黄金。<br>矿工每次可以从当前位置向上下左右四个方向走。<br>每个单元格只能被开采（进入）一次。<br>不得开采（进入）黄金数目为 0 的单元格。<br>矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。</p><p>示例 1：</p><p>输入：grid &#x3D; [[0,6,0],[5,8,7],[0,9,0]]<br>输出：24<br>解释：<br>[[0,6,0],<br> [5,8,7],<br> [0,9,0]]<br>一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。<br>示例 2：</p><p>输入：grid &#x3D; [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]<br>输出：28<br>解释：<br>[[1,0,7],<br> [2,0,6],<br> [3,4,5],<br> [0,3,0],<br> [9,0,20]]<br>一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>带回溯的dfs题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-keyword">var</span> dirs = []<span class="hljs-keyword">struct</span>&#123; x, y <span class="hljs-type">int</span> &#125;&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMaximumGold</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y, gold <span class="hljs-type">int</span>)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y, gold <span class="hljs-type">int</span>)</span></span> &#123;        gold += grid[x][y]        <span class="hljs-keyword">if</span> gold &gt; ans &#123;            ans = gold        &#125;        rec := grid[x][y]        grid[x][y] = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;            nx, ny := x+d.x, y+d.y            <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &amp;&amp; nx &lt; <span class="hljs-built_in">len</span>(grid) &amp;&amp; <span class="hljs-number">0</span> &lt;= ny &amp;&amp; ny &lt; <span class="hljs-built_in">len</span>(grid[nx]) &amp;&amp; grid[nx][ny] &gt; <span class="hljs-number">0</span> &#123;                dfs(nx, ny, gold)            &#125;        &#125;        grid[x][y] = rec    &#125;    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> grid &#123;        <span class="hljs-keyword">for</span> j, gold := <span class="hljs-keyword">range</span> row &#123;            <span class="hljs-keyword">if</span> gold &gt; <span class="hljs-number">0</span> &#123;                dfs(i, j, <span class="hljs-number">0</span>)            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span>&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>124. Binary Tree Maximum Path Sum</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/124.%20Binary%20Tree%20Maximum%20Path%20Sum/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/124.%20Binary%20Tree%20Maximum%20Path%20Sum/</url>
    
    <content type="html"><![CDATA[<h3 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a><font size=6px>Binary Tree Maximum Path Sum</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.</p><p>The path sum of a path is the sum of the node’s values in the path.</p><p>Given the root of a binary tree, return the maximum path sum of any non-empty path.</p><p>Example 1:</p><p>Input: root &#x3D; [1,2,3]<br>Output: 6<br>Explanation: The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 &#x3D; 6.<br>Example 2:</p><p>Input: root &#x3D; [-10,9,20,null,null,15,7]<br>Output: 42<br>Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 &#x3D; 42.</p><p>Constraints:</p><p>The number of nodes in the tree is in the range [1, 3 * 104].<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>使用dfs遍历，返回左或者右子树加上自身值的最大值，算最大值的时候需要特殊处理，需要计算左+右子树+自身值是否是最大值，是就更换最大值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    maxNum := <span class="hljs-number">-99999</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><span class="hljs-type">int</span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><span class="hljs-type">int</span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;        l := dfs(root.Left)        r := dfs(root.Right)        maxNum = max(maxNum, max(root.Val, max(root.Val+l,max(root.Val+r, root.Val+r+l))))        root.Val = max(root.Val, max(root.Val+l,root.Val+r))        <span class="hljs-keyword">return</span> root.Val    &#125;    dfs(root)    <span class="hljs-keyword">return</span> maxNum    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> i &gt;j&#123;        <span class="hljs-keyword">return</span> i    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> j    &#125;&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了80.91%的用户<br>   内存消耗：7.4 MB, 在所有 Go 提交中击败了89.68%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1217. 玩筹码</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1217.%20%E7%8E%A9%E7%AD%B9%E7%A0%81/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1217.%20%E7%8E%A9%E7%AD%B9%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="玩筹码"><a href="#玩筹码" class="headerlink" title="玩筹码"></a><font size=6px>玩筹码</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个筹码。第 i 个筹码的位置是 position[i] 。</p><p>我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 i 个筹码的位置从 position[i] 改变为:</p><p>position[i] + 2 或 position[i] - 2 ，此时 cost &#x3D; 0<br>position[i] + 1 或 position[i] - 1 ，此时 cost &#x3D; 1<br>返回将所有筹码移动到同一位置上所需要的 最小代价 。</p><p>示例 1：</p><p>输入：position &#x3D; [1,2,3]<br>输出：1<br>解释：第一步:将位置3的筹码移动到位置1，成本为0。<br>第二步:将位置2的筹码移动到位置1，成本&#x3D; 1。<br>总成本是1。<br>示例 2：</p><p>输入：position &#x3D; [2,2,2,3,3]<br>输出：2<br>解释：我们可以把位置3的两个筹码移到位置2。每一步的成本为1。总成本&#x3D; 2。<br>示例 3:</p><p>输入：position &#x3D; [1,1000000000]<br>输出：1</p><p>提示：</p><p>1 &lt;&#x3D; chips.length &lt;&#x3D; 100<br>1 &lt;&#x3D; chips[i] &lt;&#x3D; 10^9</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>最小奇偶数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostToMoveChips</span><span class="hljs-params">(position []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> a,b <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> position&#123;        <span class="hljs-keyword">if</span> v %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#123;            a++        &#125;<span class="hljs-keyword">else</span>&#123;            b++        &#125;    &#125;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了64.44%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1260. 二维网格迁移</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="二维网格迁移"><a href="#二维网格迁移" class="headerlink" title="二维网格迁移"></a><font size=6px>二维网格迁移</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。</p><p>每次「迁移」操作将会引发下述活动：</p><p>位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。<br>位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。<br>位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。<br>请你返回 k 次迁移操作后最终得到的 二维网格。</p><p>示例 1：</p><p>输入：grid &#x3D; [[1,2,3],[4,5,6],[7,8,9]], k &#x3D; 1<br>输出：[[9,1,2],[3,4,5],[6,7,8]]<br>示例 2：</p><p>输入：grid &#x3D; [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k &#x3D; 4<br>输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]<br>示例 3：</p><p>输入：grid &#x3D; [[1,2,3],[4,5,6],[7,8,9]], k &#x3D; 9<br>输出：[[1,2,3],[4,5,6],[7,8,9]]</p><p>提示：</p><p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m &lt;&#x3D; 50<br>1 &lt;&#x3D; n &lt;&#x3D; 50<br>-1000 &lt;&#x3D; grid[i][j] &lt;&#x3D; 1000<br>0 &lt;&#x3D; k &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span><span class="hljs-operator">*</span><span class="hljs-params">m</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span><span class="hljs-operator">*</span><span class="hljs-params">m</span>)</span></code></pre><p>变成一维位移后再变成二维</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shiftGrid</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;       m,n := <span class="hljs-built_in">len</span>(grid),<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])    <span class="hljs-keyword">var</span> tmp []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;            tmp = <span class="hljs-built_in">append</span>(tmp,grid[i][j])        &#125;    &#125;    k = k%(m*n)    tmp2 := tmp[m*n-k:]    tmp = tmp[:m*n-k]    tmp = <span class="hljs-built_in">append</span>(tmp2,tmp...)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;            grid[i][j] = tmp[i*n+j]        &#125;    &#125;    <span class="hljs-keyword">return</span> grid&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：16 ms, 在所有 Go 提交中击败了95.12%的用户<br>   内存消耗：6.8 MB, 在所有 Go 提交中击败了90.24%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1282. 用户分组</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1282.%20%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1282.%20%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="用户分组"><a href="#用户分组" class="headerlink" title="用户分组"></a><font size=6px>用户分组</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>有 n 个人被分成数量未知的组。每个人都被标记为一个从 0 到 n - 1 的唯一ID 。</p><p>给定一个整数数组 groupSizes ，其中 groupSizes[i] 是第 i 个人所在的组的大小。例如，如果 groupSizes[1] &#x3D; 3 ，则第 1 个人必须位于大小为 3 的组中。</p><p>返回一个组列表，使每个人 i 都在一个大小为 groupSizes[i] 的组中。</p><p>每个人应该 恰好只 出现在 一个组 中，并且每个人必须在一个组中。如果有多个答案，返回其中 任何 一个。可以 保证 给定输入 至少有一个 有效的解。</p><p>示例 1：</p><p>输入：groupSizes &#x3D; [3,3,3,3,3,1,3]<br>输出：[[5],[0,1,2],[3,4,6]]<br>解释：<br>第一组是 [5]，大小为 1，groupSizes[5] &#x3D; 1。<br>第二组是 [0,1,2]，大小为 3，groupSizes[0] &#x3D; groupSizes[1] &#x3D; groupSizes[2] &#x3D; 3。<br>第三组是 [3,4,6]，大小为 3，groupSizes[3] &#x3D; groupSizes[4] &#x3D; groupSizes[6] &#x3D; 3。<br>其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。<br>示例 2：</p><p>输入：groupSizes &#x3D; [2,1,3,3,3,2]<br>输出：[[1],[0,5],[2,3,4]]</p><p>提示：</p><p>groupSizes.length &#x3D;&#x3D; n<br>1 &lt;&#x3D; n &lt;&#x3D; 500<br>1 &lt;&#x3D; groupSizes[i] &lt;&#x3D; n</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>()</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">groupThePeople</span><span class="hljs-params">(groupSizes []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(groupSizes); i++&#123;        mp[groupSizes[i]] = <span class="hljs-built_in">append</span>(mp[groupSizes[i]], i)    &#125;    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> k,v := <span class="hljs-keyword">range</span> mp&#123;        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(v) !=<span class="hljs-number">0</span>&#123;            res =<span class="hljs-built_in">append</span>(res,v[:k])            v = v[k:]        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了40.91%的用户<br>   内存消耗：5.2 MB, 在所有 Go 提交中击败了59.09%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>129. 求根节点到叶节点数字之和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/129.%20%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/129.%20%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="求根节点到叶节点数字之和"><a href="#求根节点到叶节点数字之和" class="headerlink" title="求根节点到叶节点数字之和"></a><font size=6px>求根节点到叶节点数字之和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。</p><p>示例 1：</p><p>输入：root &#x3D; [1,2,3]<br>输出：25<br>解释：<br>从根到叶子节点路径 1-&gt;2 代表数字 12<br>从根到叶子节点路径 1-&gt;3 代表数字 13<br>因此，数字总和 &#x3D; 12 + 13 &#x3D; 25<br>示例 2：</p><p>输入：root &#x3D; [4,9,0,5,1]<br>输出：1026<br>解释：<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491<br>从根到叶子节点路径 4-&gt;0 代表数字 40<br>因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026</p><p>提示：</p><p>树中节点的数目在范围 [1, 1000] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9<br>树的深度不超过 10</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>用dfs做就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, prevSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    &#125;    sum := prevSum*<span class="hljs-number">10</span> + root.Val    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> sum    &#125;    <span class="hljs-keyword">return</span> dfs(root.Left, sum) + dfs(root.Right, sum)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了76.78%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1305. 两棵二叉搜索树中的所有元素</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1305.%20%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1305.%20%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="两棵二叉搜索树中的所有元素"><a href="#两棵二叉搜索树中的所有元素" class="headerlink" title="两棵二叉搜索树中的所有元素"></a><font size=6px>两棵二叉搜索树中的所有元素</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。.</p><p>示例 1：</p><p>输入：root1 &#x3D; [2,1,4], root2 &#x3D; [1,0,3]<br>输出：[0,1,1,2,3,4]<br>示例 2：</p><p>输入：root1 &#x3D; [1,null,8], root2 &#x3D; [8,1]<br>输出：[1,1,8,8]</p><p>提示：</p><p>每棵树的节点数在 [0, 5000] 范围内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">m</span>+<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">m</span>+<span class="hljs-params">n</span>)</span></code></pre><p>中序遍历，然后有个有序数组合并</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for a binary tree node.</span><span class="hljs-comment"> * type TreeNode struct &#123;</span><span class="hljs-comment"> *     Val int</span><span class="hljs-comment"> *     Left *TreeNode</span><span class="hljs-comment"> *     Right *TreeNode</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAllElements</span><span class="hljs-params">(root1 *TreeNode, root2 *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> res,res1,res2 []<span class="hljs-type">int</span>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span>&#123;        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;            <span class="hljs-keyword">return</span>         &#125;        dfs(root.Left)        res2 = <span class="hljs-built_in">append</span>(res2, root.Val)        dfs(root.Right)    &#125;    dfs(root1)    res1 = res2    res2 = []<span class="hljs-type">int</span>&#123;&#125;    dfs(root2)    l,r ,m,n := <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(res1),<span class="hljs-built_in">len</span>(res2)    <span class="hljs-keyword">for</span> l&lt;m &amp;&amp; r &lt;n&#123;        <span class="hljs-keyword">if</span> res1[l]&lt;res2[r]&#123;                       res = <span class="hljs-built_in">append</span>(res, res1[l])             l++        &#125;<span class="hljs-keyword">else</span>&#123;            res = <span class="hljs-built_in">append</span>(res, res2[r])             r++        &#125;    &#125;    <span class="hljs-keyword">for</span> ;l&lt;m;l++&#123;        res = <span class="hljs-built_in">append</span>(res, res1[l])    &#125;    <span class="hljs-keyword">for</span> ;r&lt;n;r++&#123;        res = <span class="hljs-built_in">append</span>(res, res2[r])    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：80 ms, 在所有 Go 提交中击败了86.21%的用户<br>   内存消耗：8 MB, 在所有 Go 提交中击败了63.79%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1314. 矩阵区域和</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1314.%20%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1314.%20%E7%9F%A9%E9%98%B5%E5%8C%BA%E5%9F%9F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="矩阵区域和"><a href="#矩阵区域和" class="headerlink" title="矩阵区域和"></a><font size=6px>矩阵区域和</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： </p><p>i - k &lt;&#x3D; r &lt;&#x3D; i + k,<br>j - k &lt;&#x3D; c &lt;&#x3D; j + k 且<br>(r, c) 在矩阵内。</p><p>示例 1：</p><p>输入：mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]], k &#x3D; 1<br>输出：[[12,21,16],[27,45,33],[24,39,28]]<br>示例 2：</p><p>输入：mat &#x3D; [[1,2,3],[4,5,6],[7,8,9]], k &#x3D; 2<br>输出：[[45,45,45],[45,45,45],[45,45,45]]</p><p>提示：</p><p>m &#x3D;&#x3D; mat.length<br>n &#x3D;&#x3D; mat[i].length<br>1 &lt;&#x3D; m, n, k &lt;&#x3D; 100<br>1 &lt;&#x3D; mat[i][j] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>^2)</span></code></pre><p>得先求得二维矩阵前缀和的方法</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">matrixBlockSum</span><span class="hljs-params">(mat [][]<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;    m,n := <span class="hljs-built_in">len</span>(mat), <span class="hljs-built_in">len</span>(mat[<span class="hljs-number">0</span>])    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)    res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;=m;i++&#123;        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        res[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;=n;j++&#123;            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>] - dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+ mat[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]        &#125;    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">0</span>;j&lt;n;j++&#123;            li,lj,ri,rj := max(<span class="hljs-number">0</span>,i-k),max(<span class="hljs-number">0</span>,j-k), min(m,i+k+<span class="hljs-number">1</span>),min(n, j+k+<span class="hljs-number">1</span>)            res[i][j] = dp[ri][rj] - dp[li][rj] - dp[ri][lj] + dp[li][lj]        &#125;    &#125;    <span class="hljs-keyword">return</span> res&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span> a    &#125;    <span class="hljs-keyword">return</span> b &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：8 ms, 在所有 Go 提交中击败了81.40%的用户<br>   内存消耗：6.1 MB, 在所有 Go 提交中击败了46.51%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1331. 数组序号转换</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1331.%20%E6%95%B0%E7%BB%84%E5%BA%8F%E5%8F%B7%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1331.%20%E6%95%B0%E7%BB%84%E5%BA%8F%E5%8F%B7%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="数组序号转换"><a href="#数组序号转换" class="headerlink" title="数组序号转换"></a><font size=6px>数组序号转换</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。</p><p>序号代表了一个元素有多大。序号编号的规则如下：</p><p>序号从 1 开始编号。<br>一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。<br>每个数字的序号都应该尽可能地小。</p><p>示例 1：</p><p>输入：arr &#x3D; [40,10,20,30]<br>输出：[4,1,2,3]<br>解释：40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。<br>示例 2：</p><p>输入：arr &#x3D; [100,100,100]<br>输出：[1,1,1]<br>解释：所有元素有相同的序号。<br>示例 3：</p><p>输入：arr &#x3D; [37,12,28,9,100,56,80,5,12]<br>输出：[5,3,4,2,8,6,7,1,3]</p><p>提示：</p><p>0 &lt;&#x3D; arr.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; arr[i] &lt;&#x3D; 109</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlogn</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>使用排序，然后利用map来存位置</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">arrayRankTransform</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    n := <span class="hljs-built_in">len</span>(arr)    arr2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)    <span class="hljs-built_in">copy</span>(arr2,arr)    sort.Ints(arr2)    mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)    cnt := <span class="hljs-number">1</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        <span class="hljs-keyword">if</span> i!= <span class="hljs-number">0</span> &amp;&amp; arr2[i] == arr2[i<span class="hljs-number">-1</span>] &#123;            <span class="hljs-keyword">continue</span>        &#125;        mp[arr2[i]] = cnt        cnt ++    &#125;    <span class="hljs-keyword">var</span> res []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        res = <span class="hljs-built_in">append</span>(res,mp[arr[i]])    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：64 ms, 在所有 Go 提交中击败了79.17%的用户<br>   内存消耗：14.2 MB, 在所有 Go 提交中击败了8.33%</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1342. 将数字变成 0 的操作次数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1342.%20%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%90%200%20%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1342.%20%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%90%200%20%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="将数字变成-0-的操作次数"><a href="#将数字变成-0-的操作次数" class="headerlink" title="将数字变成 0 的操作次数"></a><font size=6px>将数字变成 0 的操作次数</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p><p>示例 1：</p><p>输入：num &#x3D; 14<br>输出：6<br>解释：<br>步骤 1) 14 是偶数，除以 2 得到 7 。<br>步骤 2） 7 是奇数，减 1 得到 6 。<br>步骤 3） 6 是偶数，除以 2 得到 3 。<br>步骤 4） 3 是奇数，减 1 得到 2 。<br>步骤 5） 2 是偶数，除以 2 得到 1 。<br>步骤 6） 1 是奇数，减 1 得到 0 。<br>示例 2：</p><p>输入：num &#x3D; 8<br>输出：4<br>解释：<br>步骤 1） 8 是偶数，除以 2 得到 4 。<br>步骤 2） 4 是偶数，除以 2 得到 2 。<br>步骤 3） 2 是偶数，除以 2 得到 1 。<br>步骤 4） 1 是奇数，减 1 得到 0 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfSteps</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> count <span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> num != <span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">if</span> num %<span class="hljs-number">2</span> == <span class="hljs-number">1</span>&#123;            num--        &#125;<span class="hljs-keyword">else</span>&#123;            num /= <span class="hljs-number">2</span>        &#125;        count++    &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1374. 生成每种字符都是奇数个的字符串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1374.%20%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1374.%20%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="生成每种字符都是奇数个的字符串"><a href="#生成每种字符都是奇数个的字符串" class="headerlink" title="生成每种字符都是奇数个的字符串"></a><font size=6px>生成每种字符都是奇数个的字符串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。</p><p>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p><p>示例 1：</p><p>输入：n &#x3D; 4<br>输出：”pppz”<br>解释：”pppz” 是一个满足题目要求的字符串，因为 ‘p’ 出现 3 次，且 ‘z’ 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：”ohhh” 和 “love”。<br>示例 2：</p><p>输入：n &#x3D; 2<br>输出：”xy”<br>解释：”xy” 是一个满足题目要求的字符串，因为 ‘x’ 和 ‘y’ 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：”ag” 和 “ur”。<br>示例 3：</p><p>输入：n &#x3D; 7<br>输出：”holasss”</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 500</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>放松题</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateTheString</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> res <span class="hljs-type">string</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-1</span>;i++&#123;        res += <span class="hljs-string">&quot;a&quot;</span>    &#125;    <span class="hljs-keyword">if</span> n %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#123;        res += <span class="hljs-string">&quot;b&quot;</span>    &#125;<span class="hljs-keyword">else</span>&#123;        res += <span class="hljs-string">&quot;a&quot;</span>    &#125;    <span class="hljs-keyword">return</span> res&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：5.4 MB, 在所有 Go 提交中击败了35.29%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1380. 矩阵中的幸运数</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1380.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1380.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><font size=6px>题目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。</p><p>幸运数是指矩阵中满足同时下列两个条件的元素：</p><p>在同一行的所有元素中最小<br>在同一列的所有元素中最大</p><p>示例 1：</p><p>输入：matrix &#x3D; [[3,7,8],[9,11,13],[15,16,17]]<br>输出：[15]<br>解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。<br>示例 2：</p><p>输入：matrix &#x3D; [[1,10,4,2],[9,3,8,7],[15,16,17,12]]<br>输出：[12]<br>解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。<br>示例 3：</p><p>输入：matrix &#x3D; [[7,8],[1,2]]<br>输出：[7]</p><p>提示：</p><p>m &#x3D;&#x3D; mat.length<br>n &#x3D;&#x3D; mat[i].length<br>1 &lt;&#x3D; n, m &lt;&#x3D; 50<br>1 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 10^5<br>矩阵中的所有元素都是不同的</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>找到每一行最小的和每一列最大的，他们之间的相同数就是答案，用哈希了，内存占用比较大。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">luckyNumbers</span> <span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    m ,n := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])    hash := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-number">100002</span>)    <span class="hljs-keyword">var</span> ans []<span class="hljs-type">int</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;m;i++&#123;        minNUm := matrix[i][<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;n;j++&#123;            minNUm = min(minNUm, matrix[i][j])        &#125;        hash[minNUm] = <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;n;i++&#123;        maxNUm := matrix[<span class="hljs-number">0</span>][i]        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>;j&lt;m;j++&#123;            maxNUm = max(maxNUm, matrix[j][i])        &#125;        <span class="hljs-keyword">if</span> hash[maxNUm] == <span class="hljs-literal">true</span>&#123;            ans = <span class="hljs-built_in">append</span>(ans, maxNUm)        &#125;          &#125;    <span class="hljs-keyword">return</span> ans    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&gt;b&#123;        <span class="hljs-keyword">return</span>  a    &#125;    <span class="hljs-keyword">return</span> b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a ,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a&lt;b&#123;        <span class="hljs-keyword">return</span>  a    &#125;    <span class="hljs-keyword">return</span> b&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：12 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：6.6 MB, 在所有 Go 提交中击败了9.09%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1408. 数组中的字符串匹配</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1408.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1408.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="数组中的字符串匹配"><a href="#数组中的字符串匹配" class="headerlink" title="数组中的字符串匹配"></a><font size=6px>数组中的字符串匹配</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。</p><p>如果你可以删除 words[j] 最左侧和&#x2F;或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。</p><p>示例 1：</p><p>输入：words &#x3D; [“mass”,”as”,”hero”,”superhero”]<br>输出：[“as”,”hero”]<br>解释：”as” 是 “mass” 的子字符串，”hero” 是 “superhero” 的子字符串。<br>[“hero”,”as”] 也是有效的答案。<br>示例 2：</p><p>输入：words &#x3D; [“leetcode”,”et”,”code”]<br>输出：[“et”,”code”]<br>解释：”et” 和 “code” 都是 “leetcode” 的子字符串。<br>示例 3：</p><p>输入：words &#x3D; [“blue”,”green”,”bu”]<br>输出：[]</p><p>提示：</p><p>1 &lt;&#x3D; words.length &lt;&#x3D; 100<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 30<br>words[i] 仅包含小写英文字母。<br>题目数据 保证 每个 words[i] 都是独一无二的。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span><span class="hljs-operator">*</span><span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O()</span></code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stringMatching</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> (ret []<span class="hljs-type">string</span>) &#123;sentence := strings.Join(words, <span class="hljs-string">&quot;,&quot;</span>)<span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> words &#123;<span class="hljs-keyword">if</span> strings.Index(sentence, word) != strings.LastIndex(sentence, word) &#123;ret = <span class="hljs-built_in">append</span>(ret, word)&#125;&#125;<span class="hljs-keyword">return</span> &#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.2 MB, 在所有 Go 提交中击败了45.16%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1414. 和为 K 的最少斐波那契数字数目</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1414.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1414.%20%E5%92%8C%E4%B8%BA%20K%20%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="和为-K-的最少斐波那契数字数目"><a href="#和为-K-的最少斐波那契数字数目" class="headerlink" title="和为 K 的最少斐波那契数字数目"></a><font size=6px>和为 K 的最少斐波那契数字数目</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p><p>斐波那契数字定义为：</p><p>F1 &#x3D; 1<br>F2 &#x3D; 1<br>Fn &#x3D; Fn-1 + Fn-2 ， 其中 n &gt; 2 。<br>数据保证对于给定的 k ，一定能找到可行解。</p><p>示例 1：</p><p>输入：k &#x3D; 7<br>输出：2<br>解释：斐波那契数字为：1，1，2，3，5，8，13，……<br>对于 k &#x3D; 7 ，我们可以得到 2 + 5 &#x3D; 7 。<br>示例 2：</p><p>输入：k &#x3D; 10<br>输出：2<br>解释：对于 k &#x3D; 10 ，我们可以得到 2 + 8 &#x3D; 10 。<br>示例 3：</p><p>输入：k &#x3D; 19<br>输出：3<br>解释：对于 k &#x3D; 19 ，我们可以得到 1 + 5 + 13 &#x3D; 19 。</p><p>提示：</p><p>1 &lt;&#x3D; k &lt;&#x3D; 10^9</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>​    先找到斐波那切数列第一个大于k的数字，之后从后往前找减去这个数的第一个大于的数字。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMinFibonacciNumbers</span><span class="hljs-params">(k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> fibo []<span class="hljs-type">int</span>    fibo = <span class="hljs-built_in">append</span>(fibo, <span class="hljs-number">1</span>,<span class="hljs-number">1</span>)    i := <span class="hljs-number">1</span>    count := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> fibo[i] &lt;=k&#123;        fibo = <span class="hljs-built_in">append</span>(fibo, fibo[i<span class="hljs-number">-1</span>]+fibo[i])        i++    &#125;       <span class="hljs-keyword">for</span> k != <span class="hljs-number">0</span>&#123;       <span class="hljs-keyword">if</span> fibo[i]&lt;=k&#123;           k -= fibo[i]             count++       &#125;        i--   &#125;    <span class="hljs-keyword">return</span> count&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2.4 MB, 在所有 Go 提交中击败了33.33%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1405. 最长快乐字符串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1405.%20%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1405.%20%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="最长快乐字符串"><a href="#最长快乐字符串" class="headerlink" title="最长快乐字符串"></a><font size=6px>最长快乐字符串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>如果字符串中不含有任何 ‘aaa’，’bbb’ 或 ‘ccc’ 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。</p><p>给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：</p><p>s 是一个尽可能长的快乐字符串。<br>s 中 最多 有a 个字母 ‘a’、b 个字母 ‘b’、c 个字母 ‘c’ 。<br>s 中只含有 ‘a’、’b’ 、’c’ 三种字母。<br>如果不存在这样的字符串 s ，请返回一个空字符串 “”。</p><p>示例 1：</p><p>输入：a &#x3D; 1, b &#x3D; 1, c &#x3D; 7<br>输出：”ccaccbcc”<br>解释：”ccbccacc” 也是一种正确答案。<br>示例 2：</p><p>输入：a &#x3D; 2, b &#x3D; 2, c &#x3D; 1<br>输出：”aabbc”<br>示例 3：</p><p>输入：a &#x3D; 7, b &#x3D; 1, c &#x3D; 0<br>输出：”aabaa”<br>解释：这是该测试用例的唯一正确答案。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>贪心算法，每次选择个数最多的一个字母，如果连续两次使用相同字母，下次就需要使用第二多的字母。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestDiverseString</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>, c <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;    ans := []<span class="hljs-type">byte</span>&#123;&#125;    cnt := []<span class="hljs-keyword">struct</span>&#123; c <span class="hljs-type">int</span>; ch <span class="hljs-type">byte</span> &#125;&#123;&#123;a, <span class="hljs-string">&#x27;a&#x27;</span>&#125;, &#123;b, <span class="hljs-string">&#x27;b&#x27;</span>&#125;, &#123;c, <span class="hljs-string">&#x27;c&#x27;</span>&#125;&#125;    <span class="hljs-keyword">for</span> &#123;        sort.Slice(cnt, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> cnt[i].c &gt; cnt[j].c &#125;)        <span class="hljs-keyword">if</span> cnt[<span class="hljs-number">0</span>].c == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">break</span>        &#125;        ans = <span class="hljs-built_in">append</span>(ans, cnt[<span class="hljs-number">0</span>].ch)        cnt[<span class="hljs-number">0</span>].c --;        sort.Slice(cnt, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> cnt[i].c &gt; cnt[j].c &#125;)        <span class="hljs-keyword">if</span> cnt[<span class="hljs-number">0</span>].c == <span class="hljs-number">0</span>&#123;            <span class="hljs-keyword">break</span>        &#125;        ans = <span class="hljs-built_in">append</span>(ans, cnt[<span class="hljs-number">0</span>].ch)        cnt[<span class="hljs-number">0</span>].c--        <span class="hljs-keyword">if</span> ans[<span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-1</span>] == ans[<span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-2</span>]&#123;            <span class="hljs-keyword">if</span>(cnt[<span class="hljs-number">1</span>].c) &gt;<span class="hljs-number">0</span>&#123;                ans = <span class="hljs-built_in">append</span>(ans, cnt[<span class="hljs-number">1</span>].ch)                cnt[<span class="hljs-number">1</span>].c--            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(ans)&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：2 MB, 在所有 Go 提交中击败了82.41%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1417. 重新格式化字符串</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1417.%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1417.%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="重新格式化字符串"><a href="#重新格式化字符串" class="headerlink" title="重新格式化字符串"></a><font size=6px>重新格式化字符串</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。</p><p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p><p>请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。</p><p>示例 1：</p><p>输入：s &#x3D; “a0b1c2”<br>输出：”0a1b2c”<br>解释：”0a1b2c” 中任意两个相邻字符的类型都不同。 “a0b1c2”, “0a1b2c”, “0c2a1b” 也是满足题目要求的答案。<br>示例 2：</p><p>输入：s &#x3D; “leetcode”<br>输出：””<br>解释：”leetcode” 中只有字母，所以无法满足重新格式化的条件。<br>示例 3：</p><p>输入：s &#x3D; “1229857369”<br>输出：””<br>解释：”1229857369” 中只有数字，所以无法满足重新格式化的条件。<br>示例 4：</p><p>输入：s &#x3D; “covid2019”<br>输出：”c2o0v1i9d”<br>示例 5：</p><p>输入：s &#x3D; “ab123”<br>输出：”1a2b3”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 500<br>s 仅由小写英文字母和&#x2F;或数字组成。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>只需要计算字母和数字的数量就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reformat</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">var</span> ss,num,res []<span class="hljs-type">byte</span>        <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(s);i++ &#123;        <span class="hljs-keyword">if</span> s[i] &gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&#123;            num = <span class="hljs-built_in">append</span>(num, s[i])        &#125;<span class="hljs-keyword">else</span>&#123;            ss = <span class="hljs-built_in">append</span>(ss, s[i])        &#125;    &#125;    <span class="hljs-keyword">if</span> abs(<span class="hljs-built_in">len</span>(num)-<span class="hljs-built_in">len</span>(ss))&lt;=<span class="hljs-number">1</span>&#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(num) &gt;<span class="hljs-built_in">len</span>(ss)&#123;            res = <span class="hljs-built_in">append</span>(res,num[<span class="hljs-number">0</span>])            num = num[<span class="hljs-number">1</span>:]            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(num);i++&#123;                res = <span class="hljs-built_in">append</span>(res, ss[i])                res = <span class="hljs-built_in">append</span>(res, num[i])            &#125;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(num) &lt;<span class="hljs-built_in">len</span>(ss)&#123;            res = <span class="hljs-built_in">append</span>(res,ss[<span class="hljs-number">0</span>])            ss = ss[<span class="hljs-number">1</span>:]            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(num);i++&#123;                res = <span class="hljs-built_in">append</span>(res, num[i])                res = <span class="hljs-built_in">append</span>(res, ss[i])            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(num);i++&#123;                res = <span class="hljs-built_in">append</span>(res, ss[i])                res = <span class="hljs-built_in">append</span>(res, num[i])                            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(res)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">if</span> a &lt;<span class="hljs-number">0</span>&#123;        <span class="hljs-keyword">return</span> -a    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：3 MB, 在所有 Go 提交中击败了65.71%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1403. 非递增顺序的最小子序列</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1403.%20%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1403.%20%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="非递增顺序的最小子序列"><a href="#非递增顺序的最小子序列" class="headerlink" title="非递增顺序的最小子序列"></a><font size=6px>非递增顺序的最小子序列</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。</p><p>如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。</p><p>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。</p><p>注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。</p><p>示例 1：</p><p>输入：nums &#x3D; [4,3,10,9,8]<br>输出：[10,9]<br>解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。<br>示例 2：</p><p>输入：nums &#x3D; [4,4,7,6,7]<br>输出：[7,7,6]<br>解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 &#x3D; 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。<br>示例 3：</p><p>输入：nums &#x3D; [6]<br>输出：[6]</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 500<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">nlgon</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>先排序然后再做会比较简单</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minSubsequence</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    sort.Ints(nums)    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>;i++&#123;        nums[i],nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>-i] = nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>-i] ,nums[i]    &#125;    n := <span class="hljs-built_in">len</span>(nums)    sum := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))    sum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        sum[i] = nums[i]+sum[i<span class="hljs-number">-1</span>]    &#125;    <span class="hljs-comment">//fmt.Println(sum)</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;        <span class="hljs-keyword">if</span> sum[i]  &gt; sum[n<span class="hljs-number">-1</span>]-sum[i]&#123;            <span class="hljs-keyword">return</span> nums[:i+<span class="hljs-number">1</span>]        &#125;    &#125;    <span class="hljs-keyword">return</span> nums&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：4 ms, 在所有 Go 提交中击败了93.48%的用户<br>   内存消耗：3.2 MB, 在所有 Go 提交中击败了15.22%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1413. 逐步求和得到正数的最小值</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1413.%20%E9%80%90%E6%AD%A5%E6%B1%82%E5%92%8C%E5%BE%97%E5%88%B0%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1413.%20%E9%80%90%E6%AD%A5%E6%B1%82%E5%92%8C%E5%BE%97%E5%88%B0%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="逐步求和得到正数的最小值"><a href="#逐步求和得到正数的最小值" class="headerlink" title="逐步求和得到正数的最小值"></a><font size=6px>逐步求和得到正数的最小值</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。</p><p>你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。</p><p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。</p><p>示例 1：</p><p>输入：nums &#x3D; [-3,2,-3,4,2]<br>输出：5<br>解释：如果你选择 startValue &#x3D; 4，在第三次累加时，和小于 1 。<br>                累加求和<br>                startValue &#x3D; 4 | startValue &#x3D; 5 | nums<br>                  (4 -3 ) &#x3D; 1  | (5 -3 ) &#x3D; 2    |  -3<br>                  (1 +2 ) &#x3D; 3  | (2 +2 ) &#x3D; 4    |   2<br>                  (3 -3 ) &#x3D; 0  | (4 -3 ) &#x3D; 1    |  -3<br>                  (0 +4 ) &#x3D; 4  | (1 +4 ) &#x3D; 5    |   4<br>                  (4 +2 ) &#x3D; 6  | (5 +2 ) &#x3D; 7    |   2<br>示例 2：</p><p>输入：nums &#x3D; [1,2]<br>输出：1<br>解释：最小的 startValue 需要是正数。<br>示例 3：</p><p>输入：nums &#x3D; [1,-2,-3]<br>输出：5</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>-100 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs scss">时间复杂度：<span class="hljs-built_in">O</span>(n),空间复杂度<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)</code></pre><p>题目意思是累加求一个最小数然后去反加1</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minStartValue</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    accSum, accSumMin := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;        accSum += num        accSumMin = min(accSumMin, accSum)    &#125;    <span class="hljs-keyword">return</span> -accSumMin + <span class="hljs-number">1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> a &gt; b &#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.9 MB, 在所有 Go 提交中击败了100.00%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1422. 分割字符串的最大得分</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1422.%20%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1422.%20%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="分割字符串的最大得分"><a href="#分割字符串的最大得分" class="headerlink" title="分割字符串的最大得分"></a><font size=6px>分割字符串的最大得分</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。</p><p>「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。</p><p>示例 1：</p><p>输入：s &#x3D; “011101”<br>输出：5<br>解释：<br>将字符串 s 划分为两个非空子字符串的可行方案有：<br>左子字符串 &#x3D; “0” 且 右子字符串 &#x3D; “11101”，得分 &#x3D; 1 + 4 &#x3D; 5<br>左子字符串 &#x3D; “01” 且 右子字符串 &#x3D; “1101”，得分 &#x3D; 1 + 3 &#x3D; 4<br>左子字符串 &#x3D; “011” 且 右子字符串 &#x3D; “101”，得分 &#x3D; 1 + 2 &#x3D; 3<br>左子字符串 &#x3D; “0111” 且 右子字符串 &#x3D; “01”，得分 &#x3D; 1 + 1 &#x3D; 2<br>左子字符串 &#x3D; “01110” 且 右子字符串 &#x3D; “1”，得分 &#x3D; 2 + 1 &#x3D; 3<br>示例 2：</p><p>输入：s &#x3D; “00111”<br>输出：5<br>解释：当 左子字符串 &#x3D; “00” 且 右子字符串 &#x3D; “111” 时，我们得到最大得分 &#x3D; 2 + 3 &#x3D; 5<br>示例 3：</p><p>输入：s &#x3D; “1111”<br>输出：3</p><p>提示：</p><p>2 &lt;&#x3D; s.length &lt;&#x3D; 500<br>字符串 s 仅由字符 ‘0’ 和 ‘1’ 组成。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><pre><code class="hljs reasonml">时间复杂度：<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span>,空间复杂度<span class="hljs-constructor">O(<span class="hljs-params">n</span>)</span></code></pre><p>左边遍历一次右边遍历一次记录下来0和1的数量就行</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h4><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    score := <span class="hljs-type">int</span>(<span class="hljs-string">&#x27;1&#x27;</span>-s[<span class="hljs-number">0</span>]) + strings.Count(s[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot;1&quot;</span>)    ans := score    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s[<span class="hljs-number">1</span> : <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>] &#123;        <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;0&#x27;</span> &#123;            score++        &#125; <span class="hljs-keyword">else</span> &#123;            score--        &#125;        ans = max(ans, score)    &#125;    <span class="hljs-keyword">return</span> ans&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">if</span> b &gt; a &#123;        <span class="hljs-keyword">return</span> b    &#125;    <span class="hljs-keyword">return</span> a&#125;</code></pre><h4 id="代码效率："><a href="#代码效率：" class="headerlink" title="代码效率："></a>代码效率：</h4><p class="note note-primary"; style="font-size:22px">   执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户<br>   内存消耗：1.8 MB, 在所有 Go 提交中击败了84.21%的用户</p>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>array</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1463. 摘樱桃 II</title>
    <link href="/2022/01/21/%E5%8A%9B%E6%89%A3/1463.%20%E6%91%98%E6%A8%B1%E6%A1%83%20II/"/>
    <url>/2022/01/21/%E5%8A%9B%E6%89%A3/1463.%20%E6%91%98%E6%A8%B1%E6%A1%83%20II/</url>
    
    <content type="html"><![CDATA[<h3 id="摘樱桃-II"><a href="#摘樱桃-II" class="headerlink" title="摘樱桃 II"></a><font size=6px>摘樱桃 II</font></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个 rows x cols 的矩阵 grid 来表示一块樱桃地。 grid 中每个格子的数字表示你能获得的樱桃数目。</p><p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。</p><p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p><p>从格子 (i,j) 出发，机器人可以移动到格子 (i+1, j-1)，(i+1, j) 或者 (i+1, j+1) 。<br>当一个机器人经过某个格子时，它